// Generated by Haxe 4.0.0-rc.3+aa17f2a96
(function ($global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
var haxe_ds__$StringMap_StringMapIterator = function(map,keys) {
	this.map = map;
	this.keys = keys;
	this.index = 0;
	this.count = keys.length;
};
haxe_ds__$StringMap_StringMapIterator.__name__ = true;
haxe_ds__$StringMap_StringMapIterator.prototype = {
	hasNext: function() {
		return this.index < this.count;
	}
	,next: function() {
		var _this = this.map;
		var key = this.keys[this.index++];
		if(__map_reserved[key] != null) {
			return _this.getReserved(key);
		} else {
			return _this.h[key];
		}
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_Browser = function() { };
js_Browser.__name__ = true;
js_Browser.getLocalStorage = function() {
	try {
		var s = window.localStorage;
		s.getItem("");
		if(s.length == 0) {
			var key = "_hx_" + Math.random();
			s.setItem(key,key);
			s.removeItem(key);
		}
		return s;
	} catch( e ) {
		return null;
	}
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = true;
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var quake_CDAudio = function() { };
quake_CDAudio.__name__ = true;
quake_CDAudio.Init = function() {
	quake_Cmd.AddCommand("cd",quake_CDAudio.CD_f);
	if(quake_COM.CheckParm("-nocdaudio") != null) {
		return;
	}
	quake_CDAudio.known = [];
	var xhr = new XMLHttpRequest();
	var _g = 2;
	while(_g < 100) {
		var i = _g++;
		var track = "/music/track" + (i <= 9 ? "0" : "") + i + ".ogg";
		var j = quake_COM.searchpaths.length - 1;
		while(j >= 0) {
			xhr.open("HEAD",quake_COM.searchpaths[j].filename + track,false);
			xhr.send();
			if(xhr.status >= 200 && xhr.status <= 299) {
				quake_CDAudio.known[i - 2] = quake_COM.searchpaths[j].filename + track;
				break;
			}
			--j;
		}
		if(j < 0) {
			break;
		}
	}
	if(quake_CDAudio.known.length == 0) {
		return;
	}
	quake_CDAudio.initialized = quake_CDAudio.enabled = true;
	quake_CDAudio.Update();
	quake_Console.Print("CD Audio Initialized\n");
};
quake_CDAudio.Update = function() {
	if(!quake_CDAudio.initialized || !quake_CDAudio.enabled) {
		return;
	}
	if(quake_S.bgmvolume.value == quake_CDAudio.cdvolume) {
		return;
	}
	if(quake_S.bgmvolume.value < 0.0) {
		quake_S.bgmvolume.setValue(0.0);
	} else if(quake_S.bgmvolume.value > 1.0) {
		quake_S.bgmvolume.setValue(1.0);
	}
	quake_CDAudio.cdvolume = quake_S.bgmvolume.value;
	if(quake_CDAudio.cd != null) {
		quake_CDAudio.cd.volume = quake_CDAudio.cdvolume;
	}
};
quake_CDAudio.Play = function(track,looping) {
	if(!quake_CDAudio.initialized || !quake_CDAudio.enabled) {
		return;
	}
	track -= 2;
	if(quake_CDAudio.playTrack == track) {
		if(quake_CDAudio.cd != null) {
			quake_CDAudio.cd.loop = looping;
			if(looping && quake_CDAudio.cd.paused) {
				quake_CDAudio.cd.play();
			}
		}
		return;
	}
	if(track < 0 || track >= quake_CDAudio.known.length) {
		quake_Console.DPrint("CDAudio.Play: Bad track number " + (track + 2) + ".\n");
		return;
	}
	quake_CDAudio.Stop();
	quake_CDAudio.playTrack = track;
	quake_CDAudio.cd = new Audio(quake_CDAudio.known[track]);
	quake_CDAudio.cd.loop = looping;
	quake_CDAudio.cd.volume = quake_CDAudio.cdvolume;
	quake_CDAudio.cd.play();
};
quake_CDAudio.Stop = function() {
	if(!quake_CDAudio.initialized || !quake_CDAudio.enabled) {
		return;
	}
	if(quake_CDAudio.cd != null) {
		quake_CDAudio.cd.pause();
	}
	quake_CDAudio.playTrack = null;
	quake_CDAudio.cd = null;
};
quake_CDAudio.Pause = function() {
	if(!quake_CDAudio.initialized || !quake_CDAudio.enabled) {
		return;
	}
	if(quake_CDAudio.cd != null) {
		quake_CDAudio.cd.pause();
	}
};
quake_CDAudio.Resume = function() {
	if(!quake_CDAudio.initialized || !quake_CDAudio.enabled) {
		return;
	}
	if(quake_CDAudio.cd != null) {
		quake_CDAudio.cd.play();
	}
};
quake_CDAudio.CD_f = function() {
	if(!quake_CDAudio.initialized || quake_Cmd.argv.length <= 1) {
		return;
	}
	switch(quake_Cmd.argv[1].toLowerCase()) {
	case "info":
		quake_Console.Print(quake_CDAudio.known.length + " tracks\n");
		if(quake_CDAudio.cd != null) {
			if(!quake_CDAudio.cd.paused) {
				quake_Console.Print("Currently " + (quake_CDAudio.cd.loop ? "looping" : "playing") + " track " + (quake_CDAudio.playTrack + 2) + "\n");
			}
		}
		quake_Console.Print("Volume is " + quake_CDAudio.cdvolume + "\n");
		break;
	case "loop":
		quake_CDAudio.Play(quake_Q.atoi(quake_Cmd.argv[2]),true);
		break;
	case "off":
		quake_CDAudio.Stop();
		quake_CDAudio.enabled = false;
		break;
	case "on":
		quake_CDAudio.enabled = true;
		break;
	case "pause":
		quake_CDAudio.Pause();
		break;
	case "play":
		quake_CDAudio.Play(quake_Q.atoi(quake_Cmd.argv[2]),false);
		break;
	case "resume":
		quake_CDAudio.Resume();
		break;
	case "stop":
		quake_CDAudio.Stop();
		break;
	}
};
var quake__$CL_Beam = function() {
	this.entity = 0;
	this.model = null;
	this.endtime = 0;
	this.start = new Float32Array(3);
	this.end = new Float32Array(3);
};
quake__$CL_Beam.__name__ = true;
var quake__$CL_ClientStatic = function() {
	this.state = 0;
	this.spawnparms = "";
	this.demonum = 0;
	this.message = new quake_MSG(8192);
};
quake__$CL_ClientStatic.__name__ = true;
var quake_ClientCmd = function() {
	this.upmove = 0.0;
	this.sidemove = 0.0;
	this.forwardmove = 0.0;
};
quake_ClientCmd.__name__ = true;
var quake__$CL_Score = function() {
	this.colors = 0;
	this.frags = 0;
	this.name = "";
};
quake__$CL_Score.__name__ = true;
var quake__$CL_ClientState = function() {
	this.cdtrack = 0;
	this.viewent = new quake_Entity();
	this.viewentity = 0;
	this.last_received_message = 0.0;
	this.oldtime = 0.0;
	this.completed_time = 0.0;
	this.intermission = 0;
	this.laststop = 0.0;
	this.driftmove = 0.0;
	this.pitchvel = 0.0;
	this.idealpitch = 0.0;
	this.punchangle = new Float32Array(3);
	this.cshifts = [[0.0,0.0,0.0,0.0],[0.0,0.0,0.0,0.0],[0.0,0.0,0.0,0.0],[0.0,0.0,0.0,0.0]];
	this.faceanimtime = 0.0;
	this.item_gettime = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];
	this.items = 0;
	this.stats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
	this.movemessages = 0;
	this.cmd = new quake_ClientCmd();
	this.velocity = new Float32Array(3);
	this.mvelocity1 = new Float32Array(3);
	this.mvelocity0 = new Float32Array(3);
	this.mviewangles1 = new Float32Array(3);
	this.mviewangles0 = new Float32Array(3);
	this.viewangles = new Float32Array(3);
	this.time = 0.0;
	this.mtime1 = 0.0;
	this.mtime0 = 0.0;
};
quake__$CL_ClientState.__name__ = true;
var quake_MSG = function(capacity,size) {
	if(size == null) {
		size = 0;
	}
	this.overflowed = false;
	this.allowoverflow = false;
	this.data = new ArrayBuffer(capacity);
	this.cursize = size;
};
quake_MSG.__name__ = true;
quake_MSG.BeginReading = function() {
	quake_MSG.readcount = 0;
	quake_MSG.badread = false;
};
quake_MSG.ReadChar = function() {
	if(quake_MSG.readcount >= quake_NET.message.cursize) {
		quake_MSG.badread = true;
		return -1;
	}
	var c = new Int8Array(quake_NET.message.data,quake_MSG.readcount,1)[0];
	++quake_MSG.readcount;
	return c;
};
quake_MSG.ReadByte = function() {
	if(quake_MSG.readcount >= quake_NET.message.cursize) {
		quake_MSG.badread = true;
		return -1;
	}
	var c = new Uint8Array(quake_NET.message.data,quake_MSG.readcount,1)[0];
	++quake_MSG.readcount;
	return c;
};
quake_MSG.ReadShort = function() {
	if(quake_MSG.readcount + 2 > quake_NET.message.cursize) {
		quake_MSG.badread = true;
		return -1;
	}
	var c = new DataView(quake_NET.message.data).getInt16(quake_MSG.readcount,true);
	quake_MSG.readcount += 2;
	return c;
};
quake_MSG.ReadLong = function() {
	if(quake_MSG.readcount + 4 > quake_NET.message.cursize) {
		quake_MSG.badread = true;
		return -1;
	}
	var c = new DataView(quake_NET.message.data).getInt32(quake_MSG.readcount,true);
	quake_MSG.readcount += 4;
	return c;
};
quake_MSG.ReadFloat = function() {
	if(quake_MSG.readcount + 4 > quake_NET.message.cursize) {
		quake_MSG.badread = true;
		return -1;
	}
	var f = new DataView(quake_NET.message.data).getFloat32(quake_MSG.readcount,true);
	quake_MSG.readcount += 4;
	return f;
};
quake_MSG.ReadString = function() {
	var string_b = "";
	var _g = 0;
	while(_g < 2048) {
		_g++;
		var c = quake_MSG.ReadByte();
		if(c <= 0) {
			break;
		}
		string_b += String.fromCodePoint(c);
	}
	return string_b;
};
quake_MSG.prototype = {
	GetSpace: function(length) {
		if(this.cursize + length > this.data.byteLength) {
			if(!this.allowoverflow) {
				quake_Sys.Error("SZ.GetSpace: overflow without allowoverflow set");
			}
			if(length > this.data.byteLength) {
				quake_Sys.Error("SZ.GetSpace: " + length + " is > full buffer size");
			}
			this.overflowed = true;
			quake_Console.Print("SZ.GetSpace: overflow\n");
			this.cursize = 0;
		}
		var oldsize = this.cursize;
		this.cursize += length;
		return oldsize;
	}
	,Write: function(a,length) {
		new Uint8Array(this.data,this.GetSpace(length),length).set(a.subarray(0,length));
	}
	,WriteChar: function(c) {
		new DataView(this.data).setInt8(this.GetSpace(1),c);
	}
	,WriteByte: function(c) {
		new DataView(this.data).setUint8(this.GetSpace(1),c);
	}
	,WriteShort: function(c) {
		new DataView(this.data).setInt16(this.GetSpace(2),c,true);
	}
	,WriteLong: function(c) {
		new DataView(this.data).setInt32(this.GetSpace(4),c,true);
	}
	,WriteFloat: function(f) {
		new DataView(this.data).setFloat32(this.GetSpace(4),f,true);
	}
	,WriteString: function(s) {
		if(s != null) {
			this.Write(new Uint8Array(quake_Q.strmem(s)),s.length);
		}
		this.WriteChar(0);
	}
};
var quake_CL = function() { };
quake_CL.__name__ = true;
quake_CL.StopPlayback = function() {
	if(!quake_CL.cls.demoplayback) {
		return;
	}
	quake_CL.cls.demoplayback = false;
	quake_CL.cls.demofile = null;
	quake_CL.cls.state = 0;
	if(quake_CL.cls.timedemo) {
		quake_CL.FinishTimeDemo();
	}
};
quake_CL.WriteDemoMessage = function() {
	var len = quake_CL.cls.demoofs + 16 + quake_NET.message.cursize;
	if(quake_CL.cls.demofile.byteLength < len) {
		var src = new Uint8Array(quake_CL.cls.demofile,0,quake_CL.cls.demoofs);
		quake_CL.cls.demofile = new ArrayBuffer(quake_CL.cls.demofile.byteLength + 16384);
		new Uint8Array(quake_CL.cls.demofile).set(src);
	}
	var f = new DataView(quake_CL.cls.demofile,quake_CL.cls.demoofs,16);
	f.setInt32(0,quake_NET.message.cursize,true);
	f.setFloat32(4,quake_CL.state.viewangles[0],true);
	f.setFloat32(8,quake_CL.state.viewangles[1],true);
	f.setFloat32(12,quake_CL.state.viewangles[2],true);
	new Uint8Array(quake_CL.cls.demofile).set(new Uint8Array(quake_NET.message.data,0,quake_NET.message.cursize),quake_CL.cls.demoofs + 16);
	quake_CL.cls.demoofs = len;
};
quake_CL.GetMessage = function() {
	if(quake_CL.cls.demoplayback) {
		if(quake_CL.cls.signon == 4) {
			if(quake_CL.cls.timedemo) {
				if(quake_Host.framecount == quake_CL.cls.td_lastframe) {
					return 0;
				}
				quake_CL.cls.td_lastframe = quake_Host.framecount;
				if(quake_Host.framecount == quake_CL.cls.td_startframe + 1) {
					quake_CL.cls.td_starttime = quake_Host.realtime;
				}
			} else if(quake_CL.state.time <= quake_CL.state.mtime0) {
				return 0;
			}
		}
		if(quake_CL.cls.demoofs + 16 >= quake_CL.cls.demosize) {
			quake_CL.StopPlayback();
			return 0;
		}
		var view = new DataView(quake_CL.cls.demofile);
		quake_NET.message.cursize = view.getUint32(quake_CL.cls.demoofs,true);
		if(quake_NET.message.cursize > 8000) {
			quake_Sys.Error("Demo message > MAX_MSGLEN");
		}
		quake_CL.state.mviewangles1.set(quake_CL.state.mviewangles0);
		var this1 = quake_CL.state.mviewangles0;
		var y = view.getFloat32(quake_CL.cls.demoofs + 8,true);
		var z = view.getFloat32(quake_CL.cls.demoofs + 12,true);
		this1[0] = view.getFloat32(quake_CL.cls.demoofs + 4,true);
		this1[1] = y;
		this1[2] = z;
		quake_CL.cls.demoofs += 16;
		if(quake_CL.cls.demoofs + quake_NET.message.cursize > quake_CL.cls.demosize) {
			quake_CL.StopPlayback();
			return 0;
		}
		var src = new Uint8Array(quake_CL.cls.demofile,quake_CL.cls.demoofs,quake_NET.message.cursize);
		var dest = new Uint8Array(quake_NET.message.data,0,quake_NET.message.cursize);
		var _g = 0;
		var _g1 = quake_NET.message.cursize;
		while(_g < _g1) {
			var i = _g++;
			dest[i] = src[i];
		}
		quake_CL.cls.demoofs += quake_NET.message.cursize;
		return 1;
	}
	var r = null;
	while(true) {
		r = quake_NET.GetMessage(quake_CL.cls.netcon);
		if(r != 1 && r != 2) {
			return r;
		}
		if(quake_NET.message.cursize == 1 && new Uint8Array(quake_NET.message.data,0,1)[0] == 1) {
			quake_Console.Print("<-- server to client keepalive\n");
		} else {
			break;
		}
	}
	if(quake_CL.cls.demorecording) {
		quake_CL.WriteDemoMessage();
	}
	return r;
};
quake_CL.Stop_f = function() {
	if(quake_Cmd.client) {
		return;
	}
	if(!quake_CL.cls.demorecording) {
		quake_Console.Print("Not recording a demo.\n");
		return;
	}
	quake_NET.message.cursize = 0;
	quake_NET.message.WriteByte(2);
	quake_CL.WriteDemoMessage();
	if(!quake_COM.WriteFile(quake_CL.cls.demoname,new Uint8Array(quake_CL.cls.demofile),quake_CL.cls.demoofs)) {
		quake_Console.Print("ERROR: couldn't open.\n");
	}
	quake_CL.cls.demofile = null;
	quake_CL.cls.demorecording = false;
	quake_Console.Print("Completed demo\n");
};
quake_CL.Record_f = function() {
	var c = quake_Cmd.argv.length;
	if(c <= 1 || c >= 5) {
		quake_Console.Print("record <demoname> [<map> [cd track]]\n");
		return;
	}
	if(quake_Cmd.argv[1].indexOf("..") != -1) {
		quake_Console.Print("Relative pathnames are not allowed.\n");
		return;
	}
	if(c == 2 && quake_CL.cls.state == 2) {
		quake_Console.Print("Can not record - already connected to server\nClient demo recording must be started before connecting\n");
		return;
	}
	if(c == 4) {
		quake_CL.cls.forcetrack = quake_Q.atoi(quake_Cmd.argv[3]);
		quake_Console.Print("Forcing CD track to " + quake_CL.cls.forcetrack);
	} else {
		quake_CL.cls.forcetrack = -1;
	}
	quake_CL.cls.demoname = quake_COM.DefaultExtension(quake_Cmd.argv[1],".dem");
	if(c >= 3) {
		quake_Cmd.ExecuteString("map " + quake_Cmd.argv[2]);
	}
	quake_Console.Print("recording to " + quake_CL.cls.demoname + ".\n");
	quake_CL.cls.demofile = new ArrayBuffer(16384);
	var track = Std.string(quake_CL.cls.forcetrack) + "\n";
	var dest = new Uint8Array(quake_CL.cls.demofile,0,track.length);
	var _g = 0;
	var _g1 = track.length;
	while(_g < _g1) {
		var i = _g++;
		dest[i] = HxOverrides.cca(track,i);
	}
	quake_CL.cls.demoofs = track.length;
	quake_CL.cls.demorecording = true;
};
quake_CL.PlayDemo_f = function() {
	if(quake_Cmd.client) {
		return;
	}
	if(quake_Cmd.argv.length != 2) {
		quake_Console.Print("playdemo <demoname> : plays a demo\n");
		return;
	}
	quake_CL.Disconnect();
	var name = quake_COM.DefaultExtension(quake_Cmd.argv[1],".dem");
	quake_Console.Print("Playing demo from " + name + ".\n");
	var demofile = quake_COM.LoadFile(name);
	if(demofile == null) {
		quake_Console.Print("ERROR: couldn't open.\n");
		quake_CL.cls.demonum = -1;
		quake_SCR.disabled_for_loading = false;
		return;
	}
	quake_CL.cls.demofile = demofile;
	var demofile1 = new Uint8Array(demofile);
	quake_CL.cls.demosize = demofile1.length;
	quake_CL.cls.demoplayback = true;
	quake_CL.cls.state = 2;
	quake_CL.cls.forcetrack = 0;
	var i = 0;
	var neg = false;
	while(i < demofile1.length) {
		var c = demofile1[i];
		if(c == 10) {
			break;
		}
		if(c == 45) {
			neg = true;
		} else {
			quake_CL.cls.forcetrack = quake_CL.cls.forcetrack * 10 + c - 48;
		}
		++i;
	}
	if(neg) {
		quake_CL.cls.forcetrack = -quake_CL.cls.forcetrack;
	}
	quake_CL.cls.demoofs = i + 1;
};
quake_CL.FinishTimeDemo = function() {
	quake_CL.cls.timedemo = false;
	var frames = quake_Host.framecount - quake_CL.cls.td_startframe - 1;
	var time = quake_Host.realtime - quake_CL.cls.td_starttime;
	if(time == 0.0) {
		time = 1.0;
	}
	quake_Console.Print(frames + " frames " + time.toFixed(1) + " seconds " + (frames / time).toFixed(1) + " fps\n");
};
quake_CL.TimeDemo_f = function() {
	if(quake_Cmd.client) {
		return;
	}
	if(quake_Cmd.argv.length != 2) {
		quake_Console.Print("timedemo <demoname> : gets demo speeds\n");
		return;
	}
	quake_CL.PlayDemo_f();
	quake_CL.cls.timedemo = true;
	quake_CL.cls.td_startframe = quake_Host.framecount;
	quake_CL.cls.td_lastframe = -1;
};
quake_CL.KeyDown = function() {
	var b = Reflect.field(quake_CL.kbutton,quake_Cmd.argv[0].substring(1));
	if(b == null) {
		return;
	}
	var b1 = quake_CL.kbuttons[b];
	var k;
	if(quake_Cmd.argv[1] != null) {
		k = quake_Q.atoi(quake_Cmd.argv[1]);
	} else {
		k = -1;
	}
	if(k == b1.down[0] || k == b1.down[1]) {
		return;
	}
	if(b1.down[0] == 0) {
		b1.down[0] = k;
	} else if(b1.down[1] == 0) {
		b1.down[1] = k;
	} else {
		quake_Console.Print("Three keys down for a button!\n");
		return;
	}
	if((b1.state & 1) == 0) {
		b1.state |= 3;
	}
};
quake_CL.KeyUp = function() {
	var b = Reflect.field(quake_CL.kbutton,quake_Cmd.argv[0].substring(1));
	if(b == null) {
		return;
	}
	var b1 = quake_CL.kbuttons[b];
	var k;
	if(quake_Cmd.argv[1] != null) {
		k = quake_Q.atoi(quake_Cmd.argv[1]);
	} else {
		b1.down[1] = 0;
		b1.down[0] = 0;
		b1.state = 4;
		return;
	}
	if(b1.down[0] == k) {
		b1.down[0] = 0;
	} else if(b1.down[1] == k) {
		b1.down[1] = 0;
	} else {
		return;
	}
	if(b1.down[0] != 0 || b1.down[1] != 0) {
		return;
	}
	if((b1.state & 1) != 0) {
		b1.state = b1.state - 1 | 4;
	}
};
quake_CL.MLookUp = function() {
	quake_CL.KeyUp();
	if((quake_CL.kbuttons[quake_CL.kbutton.mlook].state & 1) == 0 && quake_CL.lookspring.value != 0) {
		quake_V.StartPitchDrift();
	}
};
quake_CL.Impulse = function() {
	quake_CL.impulse = quake_Q.atoi(quake_Cmd.argv[1]);
};
quake_CL.KeyState = function(key) {
	var key1 = quake_CL.kbuttons[key];
	var down = key1.state & 1;
	key1.state &= 1;
	if((key1.state & 2) != 0) {
		if((key1.state & 4) != 0) {
			if(down != 0) {
				return 0.75;
			} else {
				return 0.25;
			}
		}
		if(down != 0) {
			return 0.5;
		} else {
			return 0.0;
		}
	}
	if((key1.state & 4) != 0) {
		return 0.0;
	}
	if(down != 0) {
		return 1.0;
	} else {
		return 0.0;
	}
};
quake_CL.AdjustAngles = function() {
	var speed = quake_Host.frametime;
	if((quake_CL.kbuttons[quake_CL.kbutton.speed].state & 1) != 0) {
		speed *= quake_CL.anglespeedkey.value;
	}
	var angles = quake_CL.state.viewangles;
	if((quake_CL.kbuttons[quake_CL.kbutton.strafe].state & 1) == 0) {
		angles[1] += speed * quake_CL.yawspeed.value * (quake_CL.KeyState(quake_CL.kbutton.left) - quake_CL.KeyState(quake_CL.kbutton.right));
		angles[1] = quake__$Vec_Vec_$Impl_$.Anglemod(angles[1]);
	}
	if((quake_CL.kbuttons[quake_CL.kbutton.klook].state & 1) != 0) {
		quake_V.StopPitchDrift();
		angles[0] += speed * quake_CL.pitchspeed.value * (quake_CL.KeyState(quake_CL.kbutton.back) - quake_CL.KeyState(quake_CL.kbutton.forward));
	}
	var up = quake_CL.KeyState(quake_CL.kbutton.lookup);
	var down = quake_CL.KeyState(quake_CL.kbutton.lookdown);
	if(up != 0.0 || down != 0.0) {
		angles[0] += speed * quake_CL.pitchspeed.value * (down - up);
		quake_V.StopPitchDrift();
	}
	if(angles[0] > 80.0) {
		angles[0] = 80.0;
	} else if(angles[0] < -70.0) {
		angles[0] = -70.0;
	}
	if(angles[2] > 50.0) {
		angles[2] = 50.0;
	} else if(angles[2] < -50.0) {
		angles[2] = -50.0;
	}
};
quake_CL.BaseMove = function() {
	if(quake_CL.cls.signon != 4) {
		return;
	}
	quake_CL.AdjustAngles();
	var cmd = quake_CL.state.cmd;
	cmd.sidemove = quake_CL.sidespeed.value * (quake_CL.KeyState(quake_CL.kbutton.moveright) - quake_CL.KeyState(quake_CL.kbutton.moveleft));
	if((quake_CL.kbuttons[quake_CL.kbutton.strafe].state & 1) != 0) {
		cmd.sidemove += quake_CL.sidespeed.value * (quake_CL.KeyState(quake_CL.kbutton.right) - quake_CL.KeyState(quake_CL.kbutton.left));
	}
	cmd.upmove = quake_CL.upspeed.value * (quake_CL.KeyState(quake_CL.kbutton.moveup) - quake_CL.KeyState(quake_CL.kbutton.movedown));
	if((quake_CL.kbuttons[quake_CL.kbutton.klook].state & 1) == 0) {
		cmd.forwardmove = quake_CL.forwardspeed.value * quake_CL.KeyState(quake_CL.kbutton.forward) - quake_CL.backspeed.value * quake_CL.KeyState(quake_CL.kbutton.back);
	} else {
		cmd.forwardmove = 0.0;
	}
	if((quake_CL.kbuttons[quake_CL.kbutton.speed].state & 1) != 0) {
		cmd.forwardmove *= quake_CL.movespeedkey.value;
		cmd.sidemove *= quake_CL.movespeedkey.value;
		cmd.upmove *= quake_CL.movespeedkey.value;
	}
};
quake_CL.SendMove = function() {
	var buf = quake_CL.sendmovebuf;
	buf.cursize = 0;
	buf.WriteByte(3);
	buf.WriteFloat(quake_CL.state.mtime0);
	buf.WriteByte((quake_CL.state.viewangles[0] * 256 / 360 | 0) & 255);
	buf.WriteByte((quake_CL.state.viewangles[1] * 256 / 360 | 0) & 255);
	buf.WriteByte((quake_CL.state.viewangles[2] * 256 / 360 | 0) & 255);
	buf.WriteShort(quake_CL.state.cmd.forwardmove | 0);
	buf.WriteShort(quake_CL.state.cmd.sidemove | 0);
	buf.WriteShort(quake_CL.state.cmd.upmove | 0);
	var bits = 0;
	if((quake_CL.kbuttons[quake_CL.kbutton.attack].state & 3) != 0) {
		bits = 1;
	}
	quake_CL.kbuttons[quake_CL.kbutton.attack].state &= 5;
	if((quake_CL.kbuttons[quake_CL.kbutton.jump].state & 3) != 0) {
		bits += 2;
	}
	quake_CL.kbuttons[quake_CL.kbutton.jump].state &= 5;
	buf.WriteByte(bits);
	buf.WriteByte(quake_CL.impulse);
	quake_CL.impulse = 0;
	if(quake_CL.cls.demoplayback) {
		return;
	}
	if(++quake_CL.state.movemessages <= 2) {
		return;
	}
	if(quake_NET.SendUnreliableMessage(quake_CL.cls.netcon,buf) == -1) {
		quake_Console.Print("CL.SendMove: lost server connection\n");
		quake_CL.Disconnect();
	}
};
quake_CL.InitInput = function() {
	var commands = ["moveup","movedown","left","right","forward","back","lookup","lookdown","strafe","moveleft","moveright","speed","attack","use","jump","klook"];
	var _g = 0;
	while(_g < commands.length) {
		var cmd = commands[_g];
		++_g;
		quake_Cmd.AddCommand("+" + cmd,quake_CL.KeyDown);
		quake_Cmd.AddCommand("-" + cmd,quake_CL.KeyUp);
	}
	quake_Cmd.AddCommand("impulse",quake_CL.Impulse);
	quake_Cmd.AddCommand("+mlook",quake_CL.KeyDown);
	quake_Cmd.AddCommand("-mlook",quake_CL.MLookUp);
	var _g1 = 0;
	var _g2 = quake_CL.kbutton.num;
	while(_g1 < _g2) quake_CL.kbuttons[_g1++] = { down : [0,0], state : 0};
};
quake_CL.Rcon_f = function() {
	if(quake_CL.rcon_password.string.length == 0) {
		quake_Console.Print("You must set 'rcon_password' before\nissuing an rcon command.\n");
		return;
	}
	var to = null;
	if(quake_CL.cls.state == 2 && quake_CL.cls.netcon != null) {
		if(quake_NET.drivers[quake_CL.cls.netcon.driver] == quake_NET_$WEBS) {
			to = quake_CL.cls.netcon.address.substring(5);
		}
	}
	if(to == null) {
		if(quake_CL.rcon_address.string.length == 0) {
			quake_Console.Print("You must either be connected,\nor set the 'rcon_address' cvar\nto issue rcon commands\n");
			return;
		}
		to = quake_CL.rcon_address.string;
	}
	var pw;
	try {
		pw = quake_Q.btoa(new Uint8Array(quake_Q.strmem("quake:" + quake_CL.rcon_password.string)));
	} catch( e ) {
		return;
	}
	var message = "";
	var i;
	var _g = 1;
	var _g1 = quake_Cmd.argv.length;
	while(_g < _g1) message += quake_Cmd.argv[_g++] + " ";
	try {
		message = encodeURIComponent(message);
	} catch( e1 ) {
		return;
	}
	var xhr = new XMLHttpRequest();
	xhr.open("HEAD","http://" + to + "/rcon/" + message);
	xhr.setRequestHeader("Authorization","Basic " + pw);
	xhr.send();
};
quake_CL.ClearState = function() {
	if(!quake_SV.server.active) {
		quake_Console.DPrint("Clearing memory\n");
		quake_Mod.ClearAll();
		quake_CL.cls.signon = 0;
	}
	quake_CL.state = new quake__$CL_ClientState();
	quake_CL.static_entities = [];
	quake_CL.cls.message.cursize = 0;
	quake_CL.entities = [];
	quake_CL.dlights = [];
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.dlights.push(new quake_DLight());
	quake_CL.lightstyle = [];
	var _g = 0;
	while(_g < 64) {
		++_g;
		quake_CL.lightstyle.push("");
	}
	quake_CL.beams = [];
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
	quake_CL.beams.push(new quake__$CL_Beam());
};
quake_CL.Disconnect = function() {
	quake_S.StopAllSounds();
	if(quake_CL.cls.demoplayback) {
		quake_CL.StopPlayback();
	} else if(quake_CL.cls.state == 2) {
		if(quake_CL.cls.demorecording) {
			quake_CL.Stop_f();
		}
		quake_Console.DPrint("Sending clc_disconnect\n");
		quake_CL.cls.message.cursize = 0;
		quake_CL.cls.message.WriteByte(2);
		quake_NET.SendUnreliableMessage(quake_CL.cls.netcon,quake_CL.cls.message);
		quake_CL.cls.message.cursize = 0;
		quake_NET.Close(quake_CL.cls.netcon);
		quake_CL.cls.state = 0;
		if(quake_SV.server.active) {
			quake_Host.ShutdownServer(false);
		}
	}
	quake_CL.cls.demoplayback = quake_CL.cls.timedemo = false;
	quake_CL.cls.signon = 0;
};
quake_CL.Connect = function(sock) {
	quake_CL.cls.netcon = sock;
	quake_Console.DPrint("CL.Connect: connected to " + quake_CL.host + "\n");
	quake_CL.cls.demonum = -1;
	quake_CL.cls.state = 2;
	quake_CL.cls.signon = 0;
};
quake_CL.EstablishConnection = function(host) {
	if(quake_CL.cls.demoplayback) {
		return;
	}
	quake_CL.Disconnect();
	quake_CL.host = host;
	var sock = quake_NET.Connect(host);
	if(sock == null) {
		quake_Host.Error("CL.EstablishConnection: connect failed\n");
	}
	quake_CL.Connect(sock);
};
quake_CL.SignonReply = function() {
	quake_Console.DPrint("CL.SignonReply: " + quake_CL.cls.signon + "\n");
	switch(quake_CL.cls.signon) {
	case 1:
		quake_CL.cls.message.WriteByte(4);
		quake_CL.cls.message.WriteString("prespawn");
		break;
	case 2:
		quake_CL.cls.message.WriteByte(4);
		quake_CL.cls.message.WriteString("name \"" + quake_CL.$name.string + "\"\n");
		quake_CL.cls.message.WriteByte(4);
		var col = quake_CL.color.value | 0;
		quake_CL.cls.message.WriteString("color " + (col >> 4) + " " + (col & 15) + "\n");
		quake_CL.cls.message.WriteByte(4);
		quake_CL.cls.message.WriteString("spawn " + quake_CL.cls.spawnparms);
		break;
	case 3:
		quake_CL.cls.message.WriteByte(4);
		quake_CL.cls.message.WriteString("begin");
		break;
	case 4:
		quake_SCR.EndLoadingPlaque();
		break;
	}
};
quake_CL.NextDemo = function() {
	if(quake_CL.cls.demonum == -1) {
		return;
	}
	quake_SCR.BeginLoadingPlaque();
	if(quake_CL.cls.demonum >= quake_CL.cls.demos.length) {
		if(quake_CL.cls.demos.length == 0) {
			quake_Console.Print("No demos listed with startdemos\n");
			quake_CL.cls.demonum = -1;
			return;
		}
		quake_CL.cls.demonum = 0;
	}
	quake_Cmd.text = "playdemo " + quake_CL.cls.demos[quake_CL.cls.demonum++] + "\n" + quake_Cmd.text;
};
quake_CL.PrintEntities_f = function() {
	var _g = 0;
	var _g1 = quake_CL.entities.length;
	while(_g < _g1) {
		var i = _g++;
		var ent = quake_CL.entities[i];
		if(i <= 9) {
			quake_Console.Print("  " + i + ":");
		} else if(i <= 99) {
			quake_Console.Print(" " + i + ":");
		} else {
			quake_Console.Print(i + ":");
		}
		if(ent.model == null) {
			quake_Console.Print("EMPTY\n");
			continue;
		}
		quake_Console.Print(ent.model.name + (ent.frame <= 9 ? ": " : ":") + ent.frame + "  (" + ent.origin[0].toFixed(1) + "," + ent.origin[1].toFixed(1) + "," + ent.origin[2].toFixed(1) + ") [" + ent.angles[0].toFixed(1) + " " + ent.angles[1].toFixed(1) + " " + ent.angles[2].toFixed(1) + "]\n");
	}
};
quake_CL.AllocDlight = function(key) {
	var dl = null;
	if(key != 0) {
		var _g = 0;
		var _g1 = quake_CL.dlights;
		while(_g < _g1.length) {
			var light = _g1[_g];
			++_g;
			if(light.key == key) {
				dl = light;
				break;
			}
		}
	}
	if(dl == null) {
		var _g2 = 0;
		var _g11 = quake_CL.dlights;
		while(_g2 < _g11.length) {
			var light1 = _g11[_g2];
			++_g2;
			if(light1.die < quake_CL.state.time) {
				dl = light1;
				break;
			}
		}
		if(dl == null) {
			dl = quake_CL.dlights[0];
		}
	}
	dl.key = key;
	dl.origin.set(quake__$Vec_Vec_$Impl_$.origin);
	dl.radius = 0;
	dl.minlight = 0;
	dl.decay = 0;
	dl.die = 0;
	return dl;
};
quake_CL.DecayLights = function() {
	var time = quake_CL.state.time - quake_CL.state.oldtime;
	var _g = 0;
	var _g1 = quake_CL.dlights;
	while(_g < _g1.length) {
		var dl = _g1[_g];
		++_g;
		if(dl.die < quake_CL.state.time || dl.radius == 0.0) {
			continue;
		}
		dl.radius -= time * dl.decay;
		if(dl.radius < 0.0) {
			dl.radius = 0.0;
		}
	}
};
quake_CL.LerpPoint = function() {
	var f = quake_CL.state.mtime0 - quake_CL.state.mtime1;
	if(f == 0.0 || quake_CL.nolerp.value != 0 || quake_CL.cls.timedemo || quake_SV.server.active) {
		quake_CL.state.time = quake_CL.state.mtime0;
		return 1.0;
	}
	if(f > 0.1) {
		quake_CL.state.mtime1 = quake_CL.state.mtime0 - 0.1;
		f = 0.1;
	}
	var frac = (quake_CL.state.time - quake_CL.state.mtime1) / f;
	if(frac < 0.0) {
		if(frac < -0.01) {
			quake_CL.state.time = quake_CL.state.mtime1;
		}
		return 0.0;
	}
	if(frac > 1.0) {
		if(frac > 1.01) {
			quake_CL.state.time = quake_CL.state.mtime0;
		}
		return 1.0;
	}
	return frac;
};
quake_CL.RelinkEntities = function() {
	var frac = quake_CL.LerpPoint();
	quake_CL.numvisedicts = 0;
	quake_CL.state.velocity[0] = quake_CL.state.mvelocity1[0] + frac * (quake_CL.state.mvelocity0[0] - quake_CL.state.mvelocity1[0]);
	quake_CL.state.velocity[1] = quake_CL.state.mvelocity1[1] + frac * (quake_CL.state.mvelocity0[1] - quake_CL.state.mvelocity1[1]);
	quake_CL.state.velocity[2] = quake_CL.state.mvelocity1[2] + frac * (quake_CL.state.mvelocity0[2] - quake_CL.state.mvelocity1[2]);
	if(quake_CL.cls.demoplayback) {
		var d = quake_CL.state.mviewangles0[0] - quake_CL.state.mviewangles1[0];
		if(d > 180.0) {
			d -= 360.0;
		} else if(d < -180.0) {
			d += 360.0;
		}
		quake_CL.state.viewangles[0] = quake_CL.state.mviewangles1[0] + frac * d;
		var d1 = quake_CL.state.mviewangles0[1] - quake_CL.state.mviewangles1[1];
		if(d1 > 180.0) {
			d1 -= 360.0;
		} else if(d1 < -180.0) {
			d1 += 360.0;
		}
		quake_CL.state.viewangles[1] = quake_CL.state.mviewangles1[1] + frac * d1;
		var d2 = quake_CL.state.mviewangles0[2] - quake_CL.state.mviewangles1[2];
		if(d2 > 180.0) {
			d2 -= 360.0;
		} else if(d2 < -180.0) {
			d2 += 360.0;
		}
		quake_CL.state.viewangles[2] = quake_CL.state.mviewangles1[2] + frac * d2;
	}
	var bobjrotate = quake__$Vec_Vec_$Impl_$.Anglemod(100.0 * quake_CL.state.time);
	var delta = [];
	var oldorg = new Float32Array(3);
	var dl;
	var _g = 1;
	var _g1 = quake_CL.entities.length;
	while(_g < _g1) {
		var i = _g++;
		var ent = quake_CL.entities[i];
		if(ent.model == null) {
			continue;
		}
		if(ent.msgtime != quake_CL.state.mtime0) {
			ent.model = null;
			continue;
		}
		oldorg[0] = ent.origin[0];
		oldorg[1] = ent.origin[1];
		oldorg[2] = ent.origin[2];
		if(ent.forcelink) {
			ent.origin.set(ent.msg_origins0);
			ent.angles.set(ent.msg_angles0);
		} else {
			var f = frac;
			delta[0] = ent.msg_origins0[0] - ent.msg_origins1[0];
			if(delta[0] > 100.0 || delta[0] < -100.0) {
				f = 1.0;
			}
			delta[1] = ent.msg_origins0[1] - ent.msg_origins1[1];
			if(delta[1] > 100.0 || delta[1] < -100.0) {
				f = 1.0;
			}
			delta[2] = ent.msg_origins0[2] - ent.msg_origins1[2];
			if(delta[2] > 100.0 || delta[2] < -100.0) {
				f = 1.0;
			}
			ent.origin[0] = ent.msg_origins1[0] + f * delta[0];
			var d3 = ent.msg_angles0[0] - ent.msg_angles1[0];
			if(d3 > 180.0) {
				d3 -= 360.0;
			} else if(d3 < -180.0) {
				d3 += 360.0;
			}
			ent.angles[0] = ent.msg_angles1[0] + f * d3;
			ent.origin[1] = ent.msg_origins1[1] + f * delta[1];
			var d4 = ent.msg_angles0[1] - ent.msg_angles1[1];
			if(d4 > 180.0) {
				d4 -= 360.0;
			} else if(d4 < -180.0) {
				d4 += 360.0;
			}
			ent.angles[1] = ent.msg_angles1[1] + f * d4;
			ent.origin[2] = ent.msg_origins1[2] + f * delta[2];
			var d5 = ent.msg_angles0[2] - ent.msg_angles1[2];
			if(d5 > 180.0) {
				d5 -= 360.0;
			} else if(d5 < -180.0) {
				d5 += 360.0;
			}
			ent.angles[2] = ent.msg_angles1[2] + f * d5;
		}
		if((ent.model.flags & 8) != 0) {
			ent.angles[1] = bobjrotate;
		}
		if((ent.effects & 1) != 0) {
			quake_Render.EntityParticles(ent);
		}
		if((ent.effects & 2) != 0) {
			dl = quake_CL.AllocDlight(i);
			var fv = new Float32Array(3);
			quake__$Vec_Vec_$Impl_$.AngleVectors(ent.angles,fv);
			var this1 = dl.origin;
			this1[0] = ent.origin[0] + 18.0 * fv[0];
			this1[1] = ent.origin[1] + 18.0 * fv[1];
			this1[2] = ent.origin[2] + 16.0 + 18.0 * fv[2];
			dl.radius = 200.0 + Math.random() * 32.0;
			dl.minlight = 32.0;
			dl.die = quake_CL.state.time + 0.1;
		}
		if((ent.effects & 4) != 0) {
			dl = quake_CL.AllocDlight(i);
			var this2 = dl.origin;
			this2[0] = ent.origin[0];
			this2[1] = ent.origin[1];
			this2[2] = ent.origin[2] + 16.0;
			dl.radius = 400.0 + Math.random() * 32.0;
			dl.die = quake_CL.state.time + 0.001;
		}
		if((ent.effects & 8) != 0) {
			dl = quake_CL.AllocDlight(i);
			var this3 = dl.origin;
			this3[0] = ent.origin[0];
			this3[1] = ent.origin[1];
			this3[2] = ent.origin[2] + 16.0;
			dl.radius = 200.0 + Math.random() * 32.0;
			dl.die = quake_CL.state.time + 0.001;
		}
		if((ent.model.flags & 4) != 0) {
			quake_Render.RocketTrail(oldorg,ent.origin,2);
		} else if((ent.model.flags & 32) != 0) {
			quake_Render.RocketTrail(oldorg,ent.origin,4);
		} else if((ent.model.flags & 16) != 0) {
			quake_Render.RocketTrail(oldorg,ent.origin,3);
		} else if((ent.model.flags & 64) != 0) {
			quake_Render.RocketTrail(oldorg,ent.origin,5);
		} else if((ent.model.flags & 1) != 0) {
			quake_Render.RocketTrail(oldorg,ent.origin,0);
			dl = quake_CL.AllocDlight(i);
			dl.origin.set(ent.origin);
			dl.radius = 200.0;
			dl.die = quake_CL.state.time + 0.01;
		} else if((ent.model.flags & 2) != 0) {
			quake_Render.RocketTrail(oldorg,ent.origin,1);
		} else if((ent.model.flags & 128) != 0) {
			quake_Render.RocketTrail(oldorg,ent.origin,6);
		}
		ent.forcelink = false;
		if(i != quake_CL.state.viewentity || quake_Chase.active.value != 0) {
			quake_CL.visedicts[quake_CL.numvisedicts++] = ent;
		}
	}
};
quake_CL.ReadFromServer = function() {
	quake_CL.state.oldtime = quake_CL.state.time;
	quake_CL.state.time += quake_Host.frametime;
	while(true) {
		var ret = quake_CL.GetMessage();
		if(ret == -1) {
			quake_Host.Error("CL.ReadFromServer: lost server connection");
		}
		if(ret == 0) {
			break;
		}
		quake_CL.state.last_received_message = quake_Host.realtime;
		quake_CL.ParseServerMessage();
		if(quake_CL.cls.state != 2) {
			break;
		}
	}
	if(quake_CL.shownet.value != 0) {
		quake_Console.Print("\n");
	}
	quake_CL.RelinkEntities();
	quake_CL.UpdateTEnts();
};
quake_CL.SendCmd = function() {
	if(quake_CL.cls.state != 2) {
		return;
	}
	if(quake_CL.cls.signon == 4) {
		quake_CL.BaseMove();
		quake_IN.Move();
		quake_CL.SendMove();
	}
	if(quake_CL.cls.demoplayback) {
		quake_CL.cls.message.cursize = 0;
		return;
	}
	if(quake_CL.cls.message.cursize == 0) {
		return;
	}
	if(!quake_NET.CanSendMessage(quake_CL.cls.netcon)) {
		quake_Console.DPrint("CL.SendCmd: can't send\n");
		return;
	}
	if(quake_NET.SendMessage(quake_CL.cls.netcon,quake_CL.cls.message) == -1) {
		quake_Host.Error("CL.SendCmd: lost server connection");
	}
	quake_CL.cls.message.cursize = 0;
};
quake_CL.Init = function() {
	quake_CL.ClearState();
	quake_CL.InitInput();
	quake_CL.InitTEnts();
	quake_CL.$name = quake_Cvar.RegisterVariable("_cl_name","player",true);
	quake_CL.color = quake_Cvar.RegisterVariable("_cl_color","0",true);
	quake_CL.upspeed = quake_Cvar.RegisterVariable("cl_upspeed","200");
	quake_CL.forwardspeed = quake_Cvar.RegisterVariable("cl_forwardspeed","200",true);
	quake_CL.backspeed = quake_Cvar.RegisterVariable("cl_backspeed","200",true);
	quake_CL.sidespeed = quake_Cvar.RegisterVariable("cl_sidespeed","350");
	quake_CL.movespeedkey = quake_Cvar.RegisterVariable("cl_movespeedkey","2.0");
	quake_CL.yawspeed = quake_Cvar.RegisterVariable("cl_yawspeed","140");
	quake_CL.pitchspeed = quake_Cvar.RegisterVariable("cl_pitchspeed","150");
	quake_CL.anglespeedkey = quake_Cvar.RegisterVariable("cl_anglespeedkey","1.5");
	quake_CL.shownet = quake_Cvar.RegisterVariable("cl_shownet","0");
	quake_CL.nolerp = quake_Cvar.RegisterVariable("cl_nolerp","0");
	quake_CL.lookspring = quake_Cvar.RegisterVariable("lookspring","0",true);
	quake_CL.lookstrafe = quake_Cvar.RegisterVariable("lookstrafe","0",true);
	quake_CL.sensitivity = quake_Cvar.RegisterVariable("sensitivity","3",true);
	quake_CL.m_pitch = quake_Cvar.RegisterVariable("m_pitch","0.022",true);
	quake_CL.m_yaw = quake_Cvar.RegisterVariable("m_yaw","0.022",true);
	quake_CL.m_forward = quake_Cvar.RegisterVariable("m_forward","1",true);
	quake_CL.m_side = quake_Cvar.RegisterVariable("m_side","0.8",true);
	quake_CL.rcon_password = quake_Cvar.RegisterVariable("rcon_password","");
	quake_CL.rcon_address = quake_Cvar.RegisterVariable("rcon_address","");
	quake_Cmd.AddCommand("entities",quake_CL.PrintEntities_f);
	quake_Cmd.AddCommand("disconnect",quake_CL.Disconnect);
	quake_Cmd.AddCommand("record",quake_CL.Record_f);
	quake_Cmd.AddCommand("stop",quake_CL.Stop_f);
	quake_Cmd.AddCommand("playdemo",quake_CL.PlayDemo_f);
	quake_Cmd.AddCommand("timedemo",quake_CL.TimeDemo_f);
	quake_Cmd.AddCommand("rcon",quake_CL.Rcon_f);
};
quake_CL.EntityNum = function(num) {
	if(num < quake_CL.entities.length) {
		return quake_CL.entities[num];
	}
	while(quake_CL.entities.length <= num) quake_CL.entities.push(new quake_Entity(num));
	return quake_CL.entities[num];
};
quake_CL.ParseStartSoundPacket = function() {
	var field_mask = quake_MSG.ReadByte();
	var volume = (field_mask & 1) != 0 ? quake_MSG.ReadByte() : 255;
	var attenuation = (field_mask & 2) != 0 ? quake_MSG.ReadByte() * 0.015625 : 1.0;
	var channel = quake_MSG.ReadShort();
	var sound_num = quake_MSG.ReadByte();
	var ent = channel >> 3;
	channel &= 7;
	var x = quake_MSG.ReadShort() * 0.125;
	var y = quake_MSG.ReadShort() * 0.125;
	var z = quake_MSG.ReadShort() * 0.125;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	quake_S.StartSound(ent,channel,quake_CL.state.sound_precache[sound_num],v,volume / 255.0,attenuation);
};
quake_CL.KeepaliveMessage = function() {
	if(quake_SV.server.active || quake_CL.cls.demoplayback) {
		return;
	}
	var oldsize = quake_NET.message.cursize;
	var olddata = new Uint8Array(8192);
	olddata.set(new Uint8Array(quake_NET.message.data,0,oldsize));
	while(true) {
		var ret = quake_CL.GetMessage();
		switch(ret) {
		case 0:
			break;
		case 1:
			quake_Host.Error("CL.KeepaliveMessage: received a message");
			break;
		case 2:
			if(quake_MSG.ReadByte() != 1) {
				quake_Host.Error("CL.KeepaliveMessage: datagram wasn't a nop");
			}
			break;
		default:
			quake_Host.Error("CL.KeepaliveMessage: CL.GetMessage failed");
		}
		if(ret == 0) {
			break;
		}
	}
	quake_NET.message.cursize = oldsize;
	new Uint8Array(quake_NET.message.data,0,oldsize).set(olddata.subarray(0,oldsize));
	var time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	if(time - quake_CL.lastmsg < 5.0) {
		return;
	}
	quake_CL.lastmsg = time;
	quake_Console.Print("--> client to server keepalive\n");
	quake_CL.cls.message.WriteByte(1);
	quake_NET.SendMessage(quake_CL.cls.netcon,quake_CL.cls.message);
	quake_CL.cls.message.cursize = 0;
};
quake_CL.ParseServerInfo = function() {
	quake_Console.DPrint("Serverinfo packet received.\n");
	quake_CL.ClearState();
	var i = quake_MSG.ReadLong();
	if(i != 15) {
		quake_Console.Print("Server returned version " + i + ", not " + 15 + "\n");
		return;
	}
	quake_CL.state.maxclients = quake_MSG.ReadByte();
	if(quake_CL.state.maxclients <= 0 || quake_CL.state.maxclients > 16) {
		quake_Console.Print("Bad maxclients (" + quake_CL.state.maxclients + ") from server\n");
		return;
	}
	quake_CL.state.scores = [];
	var _g = 0;
	var _g1 = quake_CL.state.maxclients;
	while(_g < _g1) quake_CL.state.scores[_g++] = new quake__$CL_Score();
	quake_CL.state.gametype = quake_MSG.ReadByte();
	quake_CL.state.levelname = quake_MSG.ReadString();
	quake_Console.Print("\n\n\x1D\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1E\x1F\n\n");
	quake_Console.Print("\x02" + quake_CL.state.levelname + "\n");
	var str;
	var nummodels = 1;
	var model_precache = [];
	while(true) {
		str = quake_MSG.ReadString();
		if(str.length == 0) {
			break;
		}
		model_precache[nummodels++] = str;
	}
	var numsounds = 1;
	var sound_precache = [];
	while(true) {
		str = quake_MSG.ReadString();
		if(str.length == 0) {
			break;
		}
		sound_precache[numsounds++] = str;
	}
	quake_CL.state.model_precache = [];
	var _g2 = 1;
	var _g3 = nummodels;
	while(_g2 < _g3) {
		var i1 = _g2++;
		quake_CL.state.model_precache[i1] = quake_Mod.LoadModel(quake_Mod.FindName(model_precache[i1]),false);
		if(quake_CL.state.model_precache[i1] == null) {
			quake_Console.Print("Model " + model_precache[i1] + " not found\n");
			return;
		}
		quake_CL.KeepaliveMessage();
	}
	quake_CL.state.sound_precache = [];
	var _g4 = 1;
	var _g5 = numsounds;
	while(_g4 < _g5) {
		var i2 = _g4++;
		quake_CL.state.sound_precache[i2] = quake_S.PrecacheSound(sound_precache[i2]);
		quake_CL.KeepaliveMessage();
	}
	quake_CL.state.worldmodel = quake_CL.state.model_precache[1];
	quake_CL.EntityNum(0).model = quake_CL.state.worldmodel;
	quake_Render.NewMap();
	quake_Host.noclip_anglehack = false;
};
quake_CL.ParseUpdate = function(bits) {
	if(quake_CL.cls.signon == 3) {
		quake_CL.cls.signon = 4;
		quake_CL.SignonReply();
	}
	if((bits & 1) != 0) {
		bits += quake_MSG.ReadByte() << 8;
	}
	var ent = quake_CL.EntityNum((bits & 16384) != 0 ? quake_MSG.ReadShort() : quake_MSG.ReadByte());
	var forcelink = ent.msgtime != quake_CL.state.mtime1;
	ent.msgtime = quake_CL.state.mtime0;
	var model = quake_CL.state.model_precache[(bits & 1024) != 0 ? quake_MSG.ReadByte() : ent.baseline.modelindex];
	if(model != ent.model) {
		ent.model = model;
		if(model != null) {
			ent.syncbase = model.random ? Math.random() : 0.0;
		} else {
			forcelink = true;
		}
	}
	ent.frame = (bits & 64) != 0 ? quake_MSG.ReadByte() : ent.baseline.frame;
	ent.colormap = (bits & 2048) != 0 ? quake_MSG.ReadByte() : ent.baseline.colormap;
	if(ent.colormap > quake_CL.state.maxclients) {
		quake_Sys.Error("i >= cl.maxclients");
	}
	ent.skinnum = (bits & 4096) != 0 ? quake_MSG.ReadByte() : ent.baseline.skin;
	ent.effects = (bits & 8192) != 0 ? quake_MSG.ReadByte() : ent.baseline.effects;
	ent.msg_origins1.set(ent.msg_origins0);
	ent.msg_angles1.set(ent.msg_angles0);
	ent.msg_origins0[0] = (bits & 2) != 0 ? quake_MSG.ReadShort() * 0.125 : ent.baseline.origin[0];
	ent.msg_angles0[0] = (bits & 256) != 0 ? quake_MSG.ReadChar() * 1.40625 : ent.baseline.angles[0];
	ent.msg_origins0[1] = (bits & 4) != 0 ? quake_MSG.ReadShort() * 0.125 : ent.baseline.origin[1];
	ent.msg_angles0[1] = (bits & 16) != 0 ? quake_MSG.ReadChar() * 1.40625 : ent.baseline.angles[1];
	ent.msg_origins0[2] = (bits & 8) != 0 ? quake_MSG.ReadShort() * 0.125 : ent.baseline.origin[2];
	ent.msg_angles0[2] = (bits & 512) != 0 ? quake_MSG.ReadChar() * 1.40625 : ent.baseline.angles[2];
	if((bits & 32) != 0) {
		ent.forcelink = true;
	}
	if(forcelink) {
		ent.origin.set(ent.msg_origins0);
		ent.msg_origins1.set(ent.origin);
		ent.angles.set(ent.msg_angles0);
		ent.msg_angles1.set(ent.angles);
		ent.forcelink = true;
	}
};
quake_CL.ParseBaseline = function(ent) {
	ent.baseline.modelindex = quake_MSG.ReadByte();
	ent.baseline.frame = quake_MSG.ReadByte();
	ent.baseline.colormap = quake_MSG.ReadByte();
	ent.baseline.skin = quake_MSG.ReadByte();
	ent.baseline.origin[0] = quake_MSG.ReadShort() * 0.125;
	ent.baseline.angles[0] = quake_MSG.ReadChar() * 1.40625;
	ent.baseline.origin[1] = quake_MSG.ReadShort() * 0.125;
	ent.baseline.angles[1] = quake_MSG.ReadChar() * 1.40625;
	ent.baseline.origin[2] = quake_MSG.ReadShort() * 0.125;
	ent.baseline.angles[2] = quake_MSG.ReadChar() * 1.40625;
};
quake_CL.ParseClientdata = function(bits) {
	var tmp = (bits & 1) != 0 ? quake_MSG.ReadChar() : 22;
	quake_CL.state.viewheight = tmp;
	var tmp1 = (bits & 2) != 0 ? quake_MSG.ReadChar() : 0.0;
	quake_CL.state.idealpitch = tmp1;
	quake_CL.state.mvelocity1.set(quake_CL.state.mvelocity0);
	if((bits & 4) != 0) {
		quake_CL.state.punchangle[0] = quake_MSG.ReadChar();
	} else {
		quake_CL.state.punchangle[0] = 0.0;
	}
	if((bits & 32) != 0) {
		quake_CL.state.mvelocity0[0] = quake_MSG.ReadChar() * 16.0;
	} else {
		quake_CL.state.mvelocity0[0] = 0.0;
	}
	if((bits & 8) != 0) {
		quake_CL.state.punchangle[1] = quake_MSG.ReadChar();
	} else {
		quake_CL.state.punchangle[1] = 0.0;
	}
	if((bits & 64) != 0) {
		quake_CL.state.mvelocity0[1] = quake_MSG.ReadChar() * 16.0;
	} else {
		quake_CL.state.mvelocity0[1] = 0.0;
	}
	if((bits & 16) != 0) {
		quake_CL.state.punchangle[2] = quake_MSG.ReadChar();
	} else {
		quake_CL.state.punchangle[2] = 0.0;
	}
	if((bits & 128) != 0) {
		quake_CL.state.mvelocity0[2] = quake_MSG.ReadChar() * 16.0;
	} else {
		quake_CL.state.mvelocity0[2] = 0.0;
	}
	var i = quake_MSG.ReadLong();
	if(quake_CL.state.items != i) {
		var _g = 0;
		while(_g < 32) {
			var j = _g++;
			if((i >>> j & 1) != 0 && (quake_CL.state.items >>> j & 1) == 0) {
				quake_CL.state.item_gettime[j] = quake_CL.state.time;
			}
		}
		quake_CL.state.items = i;
	}
	quake_CL.state.onground = (bits & 1024) != 0;
	quake_CL.state.inwater = (bits & 2048) != 0;
	quake_CL.state.stats[5] = (bits & 4096) != 0 ? quake_MSG.ReadByte() : 0;
	quake_CL.state.stats[4] = (bits & 8192) != 0 ? quake_MSG.ReadByte() : 0;
	quake_CL.state.stats[2] = (bits & 16384) != 0 ? quake_MSG.ReadByte() : 0;
	quake_CL.state.stats[0] = quake_MSG.ReadShort();
	quake_CL.state.stats[3] = quake_MSG.ReadByte();
	quake_CL.state.stats[6] = quake_MSG.ReadByte();
	quake_CL.state.stats[7] = quake_MSG.ReadByte();
	quake_CL.state.stats[8] = quake_MSG.ReadByte();
	quake_CL.state.stats[9] = quake_MSG.ReadByte();
	if(quake_COM.standard_quake) {
		quake_CL.state.stats[10] = quake_MSG.ReadByte();
	} else {
		quake_CL.state.stats[10] = 1 << quake_MSG.ReadByte();
	}
};
quake_CL.ParseStatic = function() {
	var ent = new quake_Entity();
	quake_CL.static_entities.push(ent);
	quake_CL.ParseBaseline(ent);
	ent.model = quake_CL.state.model_precache[ent.baseline.modelindex];
	ent.frame = ent.baseline.frame;
	ent.skinnum = ent.baseline.skin;
	ent.effects = ent.baseline.effects;
	ent.origin.set(ent.baseline.origin);
	ent.angles.set(ent.baseline.angles);
	quake_Render.currententity = ent;
	var v1 = ent.origin;
	var v2 = ent.model.mins;
	var v = new Float32Array(3);
	v[0] = v1[0] + v2[0];
	v[1] = v1[1] + v2[1];
	v[2] = v1[2] + v2[2];
	var v11 = ent.origin;
	var v21 = ent.model.maxs;
	var v3 = new Float32Array(3);
	v3[0] = v11[0] + v21[0];
	v3[1] = v11[1] + v21[1];
	v3[2] = v11[2] + v21[2];
	quake_Render.SplitEntityOnNode(v,v3,quake_CL.state.worldmodel.nodes[0]);
};
quake_CL.ParseStaticSound = function() {
	var x = quake_MSG.ReadShort() * 0.125;
	var y = quake_MSG.ReadShort() * 0.125;
	var z = quake_MSG.ReadShort() * 0.125;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var sound_num = quake_MSG.ReadByte();
	var vol = quake_MSG.ReadByte();
	var atten = quake_MSG.ReadByte();
	quake_S.StaticSound(quake_CL.state.sound_precache[sound_num],v,vol / 255.0,atten);
};
quake_CL.Shownet = function(x) {
	if(quake_CL.shownet.value == 2) {
		quake_Console.Print((quake_MSG.readcount <= 99 ? quake_MSG.readcount <= 9 ? "  " : " " : "") + (quake_MSG.readcount - 1) + ":" + x + "\n");
	}
};
quake_CL.ParseServerMessage = function() {
	if(quake_CL.shownet.value == 1) {
		quake_Console.Print(quake_NET.message.cursize + " ");
	} else if(quake_CL.shownet.value == 2) {
		quake_Console.Print("------------------\n");
	}
	quake_CL.state.onground = false;
	quake_MSG.BeginReading();
	while(true) {
		if(quake_MSG.badread) {
			quake_Host.Error("CL.ParseServerMessage: Bad server message");
		}
		var cmd = quake_MSG.ReadByte();
		if(cmd == -1) {
			quake_CL.Shownet("END OF MESSAGE");
			return;
		}
		if((cmd & 128) != 0) {
			quake_CL.Shownet("fast update");
			quake_CL.ParseUpdate(cmd & 127);
			continue;
		}
		quake_CL.Shownet("svc_" + quake_CL.svc_strings[cmd]);
		switch(cmd) {
		case 1:
			continue;
		case 2:
			quake_Host.EndGame("Server disconnected\n");
			break;
		case 3:
			var i = quake_MSG.ReadByte();
			if(i >= 32) {
				quake_Sys.Error("svc_updatestat: " + i + " is invalid");
			}
			quake_CL.state.stats[i] = quake_MSG.ReadLong();
			continue;
		case 4:
			var i1 = quake_MSG.ReadLong();
			if(i1 != 15) {
				quake_Host.Error("CL.ParseServerMessage: Server is protocol " + i1 + " instead of " + 15 + "\n");
			}
			continue;
		case 5:
			quake_CL.state.viewentity = quake_MSG.ReadShort();
			continue;
		case 6:
			quake_CL.ParseStartSoundPacket();
			continue;
		case 7:
			quake_CL.state.mtime1 = quake_CL.state.mtime0;
			quake_CL.state.mtime0 = quake_MSG.ReadFloat();
			continue;
		case 8:
			quake_Console.Print(quake_MSG.ReadString());
			continue;
		case 9:
			quake_Cmd.text += quake_MSG.ReadString();
			continue;
		case 10:
			quake_CL.state.viewangles[0] = quake_MSG.ReadChar() * 1.40625;
			quake_CL.state.viewangles[1] = quake_MSG.ReadChar() * 1.40625;
			quake_CL.state.viewangles[2] = quake_MSG.ReadChar() * 1.40625;
			continue;
		case 11:
			quake_CL.ParseServerInfo();
			quake_SCR.recalc_refdef = true;
			continue;
		case 12:
			var i2 = quake_MSG.ReadByte();
			if(i2 >= 64) {
				quake_Sys.Error("svc_lightstyle > MAX_LIGHTSTYLES");
			}
			quake_CL.lightstyle[i2] = quake_MSG.ReadString();
			continue;
		case 13:
			var i3 = quake_MSG.ReadByte();
			if(i3 >= quake_CL.state.maxclients) {
				quake_Host.Error("CL.ParseServerMessage: svc_updatename > MAX_SCOREBOARD");
			}
			quake_CL.state.scores[i3].name = quake_MSG.ReadString();
			continue;
		case 14:
			var i4 = quake_MSG.ReadByte();
			if(i4 >= quake_CL.state.maxclients) {
				quake_Host.Error("CL.ParseServerMessage: svc_updatefrags > MAX_SCOREBOARD");
			}
			quake_CL.state.scores[i4].frags = quake_MSG.ReadShort();
			continue;
		case 15:
			quake_CL.ParseClientdata(quake_MSG.ReadShort());
			continue;
		case 16:
			var i5 = quake_MSG.ReadShort();
			quake_S.StopSound(i5 >> 3,i5 & 7);
			continue;
		case 17:
			var i6 = quake_MSG.ReadByte();
			if(i6 >= quake_CL.state.maxclients) {
				quake_Host.Error("CL.ParseServerMessage: svc_updatecolors > MAX_SCOREBOARD");
			}
			quake_CL.state.scores[i6].colors = quake_MSG.ReadByte();
			continue;
		case 18:
			quake_Render.ParseParticleEffect();
			continue;
		case 19:
			quake_V.ParseDamage();
			continue;
		case 20:
			quake_CL.ParseStatic();
			continue;
		case 22:
			quake_CL.ParseBaseline(quake_CL.EntityNum(quake_MSG.ReadShort()));
			continue;
		case 23:
			quake_CL.ParseTEnt();
			continue;
		case 24:
			var tmp = quake_MSG.ReadByte();
			quake_CL.state.paused = tmp != 0;
			if(quake_CL.state.paused) {
				quake_CDAudio.Pause();
			} else {
				quake_CDAudio.Resume();
			}
			continue;
		case 25:
			var i7 = quake_MSG.ReadByte();
			if(i7 <= quake_CL.cls.signon) {
				quake_Host.Error("Received signon " + i7 + " when at " + quake_CL.cls.signon);
			}
			quake_CL.cls.signon = i7;
			quake_CL.SignonReply();
			continue;
		case 26:
			quake_SCR.CenterPrint(quake_MSG.ReadString());
			continue;
		case 27:
			++quake_CL.state.stats[14];
			continue;
		case 28:
			++quake_CL.state.stats[13];
			continue;
		case 29:
			quake_CL.ParseStaticSound();
			continue;
		case 30:
			quake_CL.state.intermission = 1;
			quake_CL.state.completed_time = quake_CL.state.time;
			quake_SCR.recalc_refdef = true;
			continue;
		case 31:
			quake_CL.state.intermission = 2;
			quake_CL.state.completed_time = quake_CL.state.time;
			quake_SCR.recalc_refdef = true;
			quake_SCR.CenterPrint(quake_MSG.ReadString());
			continue;
		case 32:
			quake_CL.state.cdtrack = quake_MSG.ReadByte();
			quake_MSG.ReadByte();
			if((quake_CL.cls.demoplayback || quake_CL.cls.demorecording) && quake_CL.cls.forcetrack != -1) {
				quake_CDAudio.Play(quake_CL.cls.forcetrack,true);
			} else {
				quake_CDAudio.Play(quake_CL.state.cdtrack,true);
			}
			continue;
		case 33:
			quake_Cmd.ExecuteString("help");
			continue;
		case 34:
			quake_CL.state.intermission = 3;
			quake_CL.state.completed_time = quake_CL.state.time;
			quake_SCR.recalc_refdef = true;
			quake_SCR.CenterPrint(quake_MSG.ReadString());
			continue;
		}
		quake_Host.Error("CL.ParseServerMessage: Illegible server message\n");
	}
};
quake_CL.InitTEnts = function() {
	quake_CL.sfx_wizhit = quake_S.PrecacheSound("wizard/hit.wav");
	quake_CL.sfx_knighthit = quake_S.PrecacheSound("hknight/hit.wav");
	quake_CL.sfx_tink1 = quake_S.PrecacheSound("weapons/tink1.wav");
	quake_CL.sfx_ric1 = quake_S.PrecacheSound("weapons/ric1.wav");
	quake_CL.sfx_ric2 = quake_S.PrecacheSound("weapons/ric2.wav");
	quake_CL.sfx_ric3 = quake_S.PrecacheSound("weapons/ric3.wav");
	quake_CL.sfx_r_exp3 = quake_S.PrecacheSound("weapons/r_exp3.wav");
};
quake_CL.ParseBeam = function(m) {
	var ent = quake_MSG.ReadShort();
	var start_0 = quake_MSG.ReadShort() * 0.125;
	var start_1 = quake_MSG.ReadShort() * 0.125;
	var start_2 = quake_MSG.ReadShort() * 0.125;
	var end_0 = quake_MSG.ReadShort() * 0.125;
	var end_1 = quake_MSG.ReadShort() * 0.125;
	var end_2 = quake_MSG.ReadShort() * 0.125;
	var _g = 0;
	var _g1 = quake_CL.beams;
	while(_g < _g1.length) {
		var b = _g1[_g];
		++_g;
		if(b.entity == ent) {
			b.model = m;
			b.endtime = quake_CL.state.time + 0.2;
			var this1 = b.start;
			this1[0] = start_0;
			this1[1] = start_1;
			this1[2] = start_2;
			var this2 = b.end;
			this2[0] = end_0;
			this2[1] = end_1;
			this2[2] = end_2;
			return;
		}
	}
	var _g2 = 0;
	var _g3 = quake_CL.beams;
	while(_g2 < _g3.length) {
		var b1 = _g3[_g2];
		++_g2;
		if(b1.model == null || b1.endtime >= quake_CL.state.time) {
			b1.entity = ent;
			b1.model = m;
			b1.endtime = quake_CL.state.time + 0.2;
			var this3 = b1.start;
			this3[0] = start_0;
			this3[1] = start_1;
			this3[2] = start_2;
			var this4 = b1.end;
			this4[0] = end_0;
			this4[1] = end_1;
			this4[2] = end_2;
			return;
		}
	}
	quake_Console.Print("beam list overflow!\n");
};
quake_CL.ParseTEnt = function() {
	var type = quake_MSG.ReadByte();
	switch(type) {
	case 5:
		quake_CL.ParseBeam(quake_Mod.LoadModel(quake_Mod.FindName("progs/bolt.mdl"),true));
		return;
	case 6:
		quake_CL.ParseBeam(quake_Mod.LoadModel(quake_Mod.FindName("progs/bolt2.mdl"),true));
		return;
	case 9:
		quake_CL.ParseBeam(quake_Mod.LoadModel(quake_Mod.FindName("progs/bolt3.mdl"),true));
		return;
	case 13:
		quake_CL.ParseBeam(quake_Mod.LoadModel(quake_Mod.FindName("progs/beam.mdl"),true));
		return;
	default:
	}
	var x = quake_MSG.ReadShort() * 0.125;
	var y = quake_MSG.ReadShort() * 0.125;
	var z = quake_MSG.ReadShort() * 0.125;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	switch(type) {
	case 0:
		quake_Render.RunParticleEffect(v,quake__$Vec_Vec_$Impl_$.origin,0,10);
		break;
	case 1:
		quake_Render.RunParticleEffect(v,quake__$Vec_Vec_$Impl_$.origin,0,20);
		break;
	case 2:
		quake_Render.RunParticleEffect(v,quake__$Vec_Vec_$Impl_$.origin,0,20);
		break;
	case 3:
		quake_Render.ParticleExplosion(v);
		var dl = quake_CL.AllocDlight(0);
		dl.origin.set(v);
		dl.radius = 350.0;
		dl.die = quake_CL.state.time + 0.5;
		dl.decay = 300.0;
		quake_S.StartSound(-1,0,quake_CL.sfx_r_exp3,v,1.0,1.0);
		break;
	case 4:
		quake_Render.BlobExplosion(v);
		quake_S.StartSound(-1,0,quake_CL.sfx_r_exp3,v,1.0,1.0);
		break;
	case 7:
		quake_Render.RunParticleEffect(v,quake__$Vec_Vec_$Impl_$.origin,20,20);
		quake_S.StartSound(-1,0,quake_CL.sfx_wizhit,v,1.0,1.0);
		break;
	case 8:
		quake_Render.RunParticleEffect(v,quake__$Vec_Vec_$Impl_$.origin,226,20);
		quake_S.StartSound(-1,0,quake_CL.sfx_knighthit,v,1.0,1.0);
		break;
	case 10:
		quake_Render.LavaSplash(v);
		break;
	case 11:
		quake_Render.TeleportSplash(v);
		break;
	case 12:
		quake_Render.ParticleExplosion2(v,quake_MSG.ReadByte(),quake_MSG.ReadByte());
		var dl1 = quake_CL.AllocDlight(0);
		dl1.origin.set(v);
		dl1.radius = 350.0;
		dl1.die = quake_CL.state.time + 0.5;
		dl1.decay = 300.0;
		quake_S.StartSound(-1,0,quake_CL.sfx_r_exp3,v,1.0,1.0);
		break;
	default:
		quake_Sys.Error("CL.ParseTEnt: bad type");
	}
};
quake_CL.NewTempEntity = function() {
	var ent = new quake_Entity();
	quake_CL.temp_entities[quake_CL.num_temp_entities++] = ent;
	quake_CL.visedicts[quake_CL.numvisedicts++] = ent;
	return ent;
};
quake_CL.UpdateTEnts = function() {
	quake_CL.num_temp_entities = 0;
	var dist_0 = 0.0;
	var dist_1 = 0.0;
	var dist_2 = 0.0;
	var org_0 = 0.0;
	var org_1 = 0.0;
	var org_2 = 0.0;
	var _g = 0;
	var _g1 = quake_CL.beams;
	while(_g < _g1.length) {
		var b = _g1[_g];
		++_g;
		if(b.model == null || b.endtime < quake_CL.state.time) {
			continue;
		}
		if(b.entity == quake_CL.state.viewentity) {
			b.start.set(quake_CL.entities[quake_CL.state.viewentity].origin);
		}
		dist_0 = b.end[0] - b.start[0];
		dist_1 = b.end[1] - b.start[1];
		dist_2 = b.end[2] - b.start[2];
		var yaw;
		var pitch;
		if(dist_0 == 0.0 && dist_1 == 0.0) {
			yaw = 0;
			pitch = dist_2 > 0.0 ? 90 : 270;
		} else {
			yaw = Math.atan2(dist_1,dist_0) * 180.0 / Math.PI | 0;
			if(yaw < 0) {
				yaw += 360;
			}
			pitch = Math.atan2(dist_2,Math.sqrt(dist_0 * dist_0 + dist_1 * dist_1)) * 180.0 / Math.PI | 0;
			if(pitch < 0) {
				pitch += 360;
			}
		}
		org_0 = b.start[0];
		org_1 = b.start[1];
		org_2 = b.start[2];
		var d = Math.sqrt(dist_0 * dist_0 + dist_1 * dist_1 + dist_2 * dist_2);
		if(d != 0.0) {
			dist_0 /= d;
			dist_1 /= d;
			dist_2 /= d;
		}
		while(d > 0.0) {
			var ent = quake_CL.NewTempEntity();
			var this1 = ent.origin;
			this1[0] = org_0;
			this1[1] = org_1;
			this1[2] = org_2;
			ent.model = b.model;
			var this2 = ent.angles;
			var z = Math.random() * 360.0;
			this2[0] = pitch;
			this2[1] = yaw;
			this2[2] = z;
			org_0 += dist_0 * 30.0;
			org_1 += dist_1 * 30.0;
			org_2 += dist_2 * 30.0;
			d -= 30.0;
		}
	}
};
quake_CL.RunParticles = function() {
	var frametime = quake_CL.state.time - quake_CL.state.oldtime;
	var grav = frametime * quake_SV.gravity.value * 0.05;
	var dvel = frametime * 4.0;
	var _g = 0;
	var _g1 = quake_Render.particles;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if(p.die < quake_CL.state.time) {
			continue;
		}
		p.org[0] += p.vel[0] * frametime;
		p.org[1] += p.vel[1] * frametime;
		p.org[2] += p.vel[2] * frametime;
		switch(p.type) {
		case 1:case 2:
			p.vel[2] -= grav;
			break;
		case 3:
			p.ramp += frametime * 5.0;
			if(p.ramp >= 6.0) {
				p.die = -1.0;
			} else {
				p.color = quake_Render.ramp3[Math.floor(p.ramp)];
			}
			p.vel[2] += grav;
			break;
		case 4:
			p.ramp += frametime * 10.0;
			if(p.ramp >= 8.0) {
				p.die = -1.0;
			} else {
				p.color = quake_Render.ramp1[Math.floor(p.ramp)];
			}
			p.vel[0] += p.vel[0] * dvel;
			p.vel[1] += p.vel[1] * dvel;
			p.vel[2] += p.vel[2] * dvel - grav;
			break;
		case 5:
			p.ramp += frametime * 15.0;
			if(p.ramp >= 8.0) {
				p.die = -1.0;
			} else {
				p.color = quake_Render.ramp2[Math.floor(p.ramp)];
			}
			p.vel[0] -= p.vel[0] * frametime;
			p.vel[1] -= p.vel[1] * frametime;
			p.vel[2] -= p.vel[2] * frametime + grav;
			break;
		case 6:
			p.vel[0] += p.vel[0] * dvel;
			p.vel[1] += p.vel[1] * dvel;
			p.vel[2] += p.vel[2] * dvel - grav;
			break;
		case 7:
			p.vel[0] += p.vel[0] * dvel;
			p.vel[1] += p.vel[1] * dvel;
			p.vel[2] -= grav;
			break;
		default:
		}
	}
};
var quake__$COM_SearchPath = function(f) {
	this.filename = f;
	this.pack = [];
};
quake__$COM_SearchPath.__name__ = true;
var quake__$COM_File = function(info,i) {
	this.name = quake_Q.memstr(new Uint8Array(info,i << 6,56)).toLowerCase();
	this.filepos = new DataView(info).getUint32((i << 6) + 56,true);
	this.filelen = new DataView(info).getUint32((i << 6) + 60,true);
};
quake__$COM_File.__name__ = true;
var quake_COM = function() { };
quake_COM.__name__ = true;
quake_COM.DefaultExtension = function(path,extension) {
	var i = path.length - 1;
	while(i >= 0) {
		var src = HxOverrides.cca(path,i);
		if(src == 47) {
			break;
		}
		if(src == 46) {
			return path;
		}
		--i;
	}
	return path + extension;
};
quake_COM.Parse = function(data) {
	quake_COM.token = "";
	if(data.length == 0) {
		return null;
	}
	var i = 0;
	var c = null;
	var skipwhite = true;
	while(skipwhite) {
		skipwhite = false;
		while(true) {
			if(i >= data.length) {
				return null;
			}
			c = HxOverrides.cca(data,i);
			if(c > 32) {
				break;
			}
			++i;
		}
		if(c == 47 && HxOverrides.cca(data,i + 1) == 47) {
			while(!(i >= data.length || HxOverrides.cca(data,i) == 10)) ++i;
			skipwhite = true;
		}
	}
	if(c == 34) {
		++i;
		while(true) {
			c = HxOverrides.cca(data,i);
			++i;
			if(i >= data.length || c == 34) {
				return data.substring(i);
			}
			quake_COM.token += String.fromCodePoint(c);
		}
	}
	while(!(i >= data.length || c <= 32)) {
		quake_COM.token += String.fromCodePoint(c);
		++i;
		c = HxOverrides.cca(data,i);
	}
	return data.substring(i);
};
quake_COM.CheckParm = function(parm) {
	var _g = 1;
	var _g1 = quake_COM.argv.length;
	while(_g < _g1) {
		var i = _g++;
		if(quake_COM.argv[i] == parm) {
			return i;
		}
	}
	return null;
};
quake_COM.CheckRegistered = function() {
	var h = quake_COM.LoadFile("gfx/pop.lmp");
	if(h == null) {
		quake_Console.Print("Playing shareware version.\n");
		if(quake_COM.modified) {
			quake_Sys.Error("You must have the registered version to use modified games");
		}
		return;
	}
	var check = new Uint8Array(h);
	var pop = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,102,0,0,0,0,0,0,0,102,0,0,0,0,0,0,102,0,0,0,0,0,0,0,0,0,103,0,0,0,0,102,101,0,0,0,0,0,0,0,0,0,101,102,0,0,99,101,97,0,0,0,0,0,0,0,0,0,97,101,99,0,100,101,97,0,0,0,0,0,0,0,0,0,97,101,100,0,100,101,100,0,0,100,105,105,105,100,0,0,100,101,100,0,99,101,104,98,0,0,100,104,100,0,0,98,104,101,99,0,0,101,103,105,99,0,100,103,100,0,99,105,103,101,0,0,0,98,102,103,105,106,104,103,104,106,105,103,102,98,0,0,0,0,98,101,102,102,102,102,102,102,102,101,98,0,0,0,0,0,0,0,98,99,100,102,100,99,98,0,0,0,0,0,0,0,0,0,0,0,98,102,98,0,0,0,0,0,0,0,0,0,0,0,0,0,97,102,97,0,0,0,0,0,0,0,0,0,0,0,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0];
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		if(check[i] != pop[i]) {
			quake_Sys.Error("Corrupted data file.");
		}
	}
	quake_COM.registered.set("1");
	quake_Console.Print("Playing registered version.\n");
};
quake_COM.InitArgv = function(pargv) {
	quake_COM.cmdline = (pargv.join(" ") + " ").substring(0,256);
	quake_COM.argv = pargv.slice();
	if(quake_COM.CheckParm("-safe") != null) {
		quake_COM.argv = quake_COM.argv.concat(["-nosound","-nocdaudio","-nomouse"]);
	}
	if(quake_COM.CheckParm("-rogue") != null) {
		quake_COM.rogue = true;
		quake_COM.standard_quake = false;
	} else if(quake_COM.CheckParm("-hipnotic") != null) {
		quake_COM.hipnotic = true;
		quake_COM.standard_quake = false;
	}
};
quake_COM.Init = function() {
	if(window.document.location.protocol != "http:" && window.document.location.protocol != "https:") {
		quake_Sys.Error("Protocol is " + window.document.location.protocol + ", not http: or https:");
	}
	var swaptest = new ArrayBuffer(2);
	var swaptestview = new Uint8Array(swaptest);
	swaptestview[0] = 1;
	swaptestview[1] = 0;
	if(new Uint16Array(swaptest)[0] == 1) {
		quake_COM.LittleLong = function(l) {
			return l;
		};
	} else {
		quake_COM.LittleLong = function(l1) {
			return (l1 >>> 24) + ((l1 & 16711680) >>> 8) + ((l1 & 65280) << 8 >>> 0) + (l1 << 24 >>> 0);
		};
	}
	quake_COM.registered = quake_Cvar.RegisterVariable("registered","0");
	quake_Cvar.RegisterVariable("cmdline",quake_COM.cmdline,false,true);
	quake_Cmd.AddCommand("path",quake_COM.Path_f);
	quake_COM.InitFilesystem();
	quake_COM.CheckRegistered();
};
quake_COM.Path_f = function() {
	quake_Console.Print("Current search path:\n");
	var i = quake_COM.searchpaths.length - 1;
	while(i >= 0) {
		var s = quake_COM.searchpaths[i--];
		var j = s.pack.length - 1;
		while(j >= 0) {
			quake_Console.Print(s.filename + "/" + "pak" + j + ".pak (" + s.pack[j].length + " files)\n");
			--j;
		}
		quake_Console.Print(s.filename + "\n");
	}
};
quake_COM.WriteFile = function(filename,data,len) {
	filename = filename.toLowerCase();
	var dest = [];
	var _g = 0;
	var _g1 = len;
	while(_g < _g1) {
		var i = _g++;
		dest.push(String.fromCodePoint(data[i]));
	}
	try {
		quake_COM.localStorage.setItem("Quake." + quake_COM.searchpaths[quake_COM.searchpaths.length - 1].filename + "/" + filename,dest.join(""));
	} catch( e ) {
		console.log("src/quake/Sys.hx:45:","COM.WriteFile: failed on " + filename + "\n");
		return false;
	}
	console.log("src/quake/Sys.hx:45:","COM.WriteFile: " + filename + "\n");
	return true;
};
quake_COM.WriteTextFile = function(filename,data) {
	filename = filename.toLowerCase();
	try {
		quake_COM.localStorage.setItem("Quake." + quake_COM.searchpaths[quake_COM.searchpaths.length - 1].filename + "/" + filename,data);
	} catch( e ) {
		console.log("src/quake/Sys.hx:45:","COM.WriteTextFile: failed on " + filename + "\n");
		return false;
	}
	console.log("src/quake/Sys.hx:45:","COM.WriteTextFile: " + filename + "\n");
	return true;
};
quake_COM.LoadFile = function(filename) {
	filename = filename.toLowerCase();
	var xhr = new XMLHttpRequest();
	xhr.overrideMimeType("text/plain; charset=x-user-defined");
	quake_Draw.BeginDisc();
	var i = quake_COM.searchpaths.length - 1;
	while(i >= 0) {
		var search = quake_COM.searchpaths[i--];
		var netpath = search.filename + "/" + filename;
		var data = quake_COM.localStorage.getItem("Quake." + netpath);
		if(data != null) {
			console.log("src/quake/Sys.hx:45:","FindFile: " + netpath + "\n");
			quake_Draw.EndDisc();
			return quake_Q.strmem(data);
		}
		var j = search.pack.length - 1;
		while(j >= 0) {
			var pak = search.pack[j];
			var _g = 0;
			while(_g < pak.length) {
				var file = pak[_g];
				++_g;
				if(file.name != filename) {
					continue;
				}
				if(file.filelen == 0) {
					quake_Draw.EndDisc();
					return new ArrayBuffer(0);
				}
				xhr.open("GET",search.filename + "/pak" + j + ".pak",false);
				xhr.setRequestHeader("Range","bytes=" + file.filepos + "-" + (file.filepos + file.filelen - 1));
				xhr.send();
				if(xhr.status >= 200 && xhr.status <= 299 && xhr.responseText.length == file.filelen) {
					console.log("src/quake/Sys.hx:45:","PackFile: " + search.filename + "/pak" + j + ".pak : " + filename + "\n");
					quake_Draw.EndDisc();
					return quake_Q.strmem(xhr.responseText);
				}
				break;
			}
			--j;
		}
		xhr.open("GET",netpath,false);
		xhr.send();
		if(xhr.status >= 200 && xhr.status <= 299) {
			console.log("src/quake/Sys.hx:45:","FindFile: " + netpath + "\n");
			quake_Draw.EndDisc();
			return quake_Q.strmem(xhr.responseText);
		}
	}
	console.log("src/quake/Sys.hx:45:","FindFile: can't find " + filename + "\n");
	quake_Draw.EndDisc();
	return null;
};
quake_COM.LoadTextFile = function(filename) {
	var buf = quake_COM.LoadFile(filename);
	if(buf == null) {
		return null;
	}
	var bufview = new Uint8Array(buf);
	var f_b = "";
	var _g = 0;
	var _g1 = bufview.length;
	while(_g < _g1) {
		var i = _g++;
		if(bufview[i] != 13) {
			f_b += String.fromCodePoint(bufview[i]);
		}
	}
	return f_b;
};
quake_COM.LoadPackFile = function(packfile) {
	var xhr = new XMLHttpRequest();
	xhr.overrideMimeType("text/plain; charset=x-user-defined");
	xhr.open("GET",packfile,false);
	xhr.setRequestHeader("Range","bytes=0-11");
	xhr.send();
	if(xhr.status <= 199 || xhr.status >= 300 || xhr.responseText.length != 12) {
		return null;
	}
	var header = new DataView(quake_Q.strmem(xhr.responseText));
	if(header.getUint32(0,true) != 1262698832) {
		quake_Sys.Error(packfile + " is not a packfile");
	}
	var dirofs = header.getUint32(4,true);
	var dirlen = header.getUint32(8,true);
	var numpackfiles = dirlen >> 6;
	if(numpackfiles != 339) {
		quake_COM.modified = true;
	}
	var pack = [];
	if(numpackfiles != 0) {
		xhr.open("GET",packfile,false);
		xhr.setRequestHeader("Range","bytes=" + dirofs + "-" + (dirofs + dirlen - 1));
		xhr.send();
		if(xhr.status <= 199 || xhr.status >= 300 || xhr.responseText.length != dirlen) {
			return null;
		}
		var info = quake_Q.strmem(xhr.responseText);
		if(quake_CRC.Block(new Uint8Array(info)) != 32981) {
			quake_COM.modified = true;
		}
		var _g = 0;
		while(_g < numpackfiles) pack.push(new quake__$COM_File(info,_g++));
	}
	quake_Console.Print("Added packfile " + packfile + " (" + numpackfiles + " files)\n");
	return pack;
};
quake_COM.AddGameDirectory = function(dir) {
	var search = new quake__$COM_SearchPath(dir);
	var i = 0;
	while(true) {
		var pak = quake_COM.LoadPackFile(dir + "/" + "pak" + i + ".pak");
		if(pak == null) {
			break;
		}
		search.pack.push(pak);
		++i;
	}
	quake_COM.searchpaths.push(search);
};
quake_COM.InitFilesystem = function() {
	var i = quake_COM.CheckParm("-basedir");
	var search = null;
	if(i != null) {
		search = quake_COM.argv[i + 1];
	}
	if(search != null) {
		quake_COM.AddGameDirectory(search);
	} else {
		quake_COM.AddGameDirectory("id1");
	}
	if(quake_COM.rogue) {
		quake_COM.AddGameDirectory("rogue");
	} else if(quake_COM.hipnotic) {
		quake_COM.AddGameDirectory("hipnotic");
	}
	i = quake_COM.CheckParm("-game");
	if(i != null) {
		search = quake_COM.argv[i + 1];
		if(search != null) {
			quake_COM.modified = true;
			quake_COM.AddGameDirectory(search);
		}
	}
	quake_COM.gamedir = [quake_COM.searchpaths[quake_COM.searchpaths.length - 1]];
};
var quake_CRC = function() { };
quake_CRC.__name__ = true;
quake_CRC.Block = function(start) {
	var crcvalue = 65535;
	var _g = 0;
	var _g1 = start.length;
	while(_g < _g1) crcvalue = crcvalue << 8 & 65535 ^ quake_CRC.table[crcvalue >> 8 ^ start[_g++]];
	return crcvalue;
};
var quake_Chase = function() { };
quake_Chase.__name__ = true;
quake_Chase.Init = function() {
	quake_Chase.back = quake_Cvar.RegisterVariable("chase_back","100");
	quake_Chase.up = quake_Cvar.RegisterVariable("chase_up","16");
	quake_Chase.right = quake_Cvar.RegisterVariable("chase_right","0");
	quake_Chase.active = quake_Cvar.RegisterVariable("chase_active","0");
};
quake_Chase.Update = function() {
	var forward = new Float32Array(3);
	var r = new Float32Array(3);
	quake__$Vec_Vec_$Impl_$.AngleVectors(quake_CL.state.viewangles,forward,r);
	var tr = new quake_Trace();
	var org = quake_Render.refdef.vieworg;
	var tmp = quake_CL.state.worldmodel.hulls[0];
	var v = new Float32Array(3);
	v[0] = org[0] + 4096.0 * forward[0];
	v[1] = org[1] + 4096.0 * forward[1];
	v[2] = org[2] + 4096.0 * forward[2];
	quake_SV.RecursiveHullCheck(tmp,0,0.0,1.0,org,v,tr);
	var stop = tr.endpos;
	stop[2] -= org[2];
	var dist = (stop[0] - org[0]) * forward[0] + (stop[1] - org[1]) * forward[1] + stop[2] * forward[2];
	if(dist < 1.0) {
		dist = 1.0;
	}
	quake_Render.refdef.viewangles[0] = Math.atan(stop[2] / dist) / Math.PI * -180.0;
	org[0] -= forward[0] * quake_Chase.back.value + r[0] * quake_Chase.right.value;
	org[1] -= forward[1] * quake_Chase.back.value + r[1] * quake_Chase.right.value;
	org[2] += quake_Chase.up.value;
};
var quake_Cmd = function() { };
quake_Cmd.__name__ = true;
quake_Cmd.Init = function() {
	quake_Cmd.AddCommand("stuffcmds",quake_Cmd.StuffCmds_f);
	quake_Cmd.AddCommand("exec",quake_Cmd.Exec_f);
	quake_Cmd.AddCommand("echo",quake_Cmd.Echo_f);
	quake_Cmd.AddCommand("alias",quake_Cmd.Alias_f);
	quake_Cmd.AddCommand("cmd",quake_Cmd.ForwardToServer);
	quake_Cmd.AddCommand("wait",quake_Cmd.Wait_f);
};
quake_Cmd.AddCommand = function(name,command) {
	var _this = quake_Cvar.vars;
	if(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name)) {
		quake_Console.Print("Cmd.AddCommand: " + name + " already defined as a var\n");
		return;
	}
	var _this1 = quake_Cmd.functions;
	if(__map_reserved[name] != null ? _this1.existsReserved(name) : _this1.h.hasOwnProperty(name)) {
		quake_Console.Print("Cmd.AddCommand: " + name + " already defined\n");
	} else {
		var _this2 = quake_Cmd.functions;
		if(__map_reserved[name] != null) {
			_this2.setReserved(name,command);
		} else {
			_this2.h[name] = command;
		}
	}
};
quake_Cmd.CompleteCommand = function(partial) {
	if(partial.length == 0) {
		return null;
	}
	var name = quake_Cmd.functions.keys();
	while(name.hasNext()) {
		var name1 = name.next();
		if(name1.substring(0,partial.length) == partial) {
			return name1;
		}
	}
	return null;
};
quake_Cmd.Execute = function() {
	var line = "";
	var quotes = false;
	while(quake_Cmd.text.length != 0) {
		var c = HxOverrides.cca(quake_Cmd.text,0);
		quake_Cmd.text = quake_Cmd.text.substring(1);
		if(c == 34) {
			quotes = !quotes;
			line += "\"";
			continue;
		}
		if(!quotes && c == 59 || c == 10) {
			if(line.length == 0) {
				continue;
			}
			quake_Cmd.ExecuteString(line);
			if(quake_Cmd.wait) {
				quake_Cmd.wait = false;
				return;
			}
			line = "";
			continue;
		}
		line += String.fromCodePoint(c);
	}
	quake_Cmd.text = "";
};
quake_Cmd.ExecuteString = function(text,client) {
	if(client == null) {
		client = false;
	}
	quake_Cmd.client = client;
	quake_Cmd.TokenizeString(text);
	if(quake_Cmd.argv.length == 0) {
		return;
	}
	var name = quake_Cmd.argv[0].toLowerCase();
	var _this = quake_Cmd.functions;
	var f = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
	if(f != null) {
		f();
		return;
	}
	var _this1 = quake_Cmd.alias;
	var a = __map_reserved[name] != null ? _this1.getReserved(name) : _this1.h[name];
	if(a != null) {
		quake_Cmd.text = a + quake_Cmd.text;
		return;
	}
	if(!quake_Cvar.Command()) {
		quake_Console.Print("Unknown command \"" + name + "\"\n");
	}
};
quake_Cmd.ForwardToServer = function() {
	if(quake_CL.cls.state != 2) {
		quake_Console.Print("Can't \"" + quake_Cmd.argv[0] + "\", not connected\n");
		return;
	}
	if(quake_CL.cls.demoplayback == true) {
		return;
	}
	var args = String.fromCodePoint(4);
	if(quake_Cmd.argv[0].toLowerCase() != "cmd") {
		args += quake_Cmd.argv[0] + " ";
	}
	if(quake_Cmd.argv.length >= 2) {
		args += quake_Cmd.args;
	} else {
		args += "\n";
	}
	quake_CL.cls.message.WriteString(args);
};
quake_Cmd.StuffCmds_f = function() {
	var s = false;
	var build = "";
	var _g = 0;
	var _g1 = quake_COM.argv;
	while(_g < _g1.length) {
		var arg = _g1[_g];
		++_g;
		var c = HxOverrides.cca(arg,0);
		if(s == true) {
			if(c == 43) {
				build += "\n" + arg.substring(1) + " ";
				continue;
			}
			if(c == 45) {
				s = false;
				build += "\n";
				continue;
			}
			build += arg + " ";
			continue;
		}
		if(c == 43) {
			s = true;
			build += arg.substring(1) + " ";
		}
	}
	if(build.length != 0) {
		quake_Cmd.text = build + "\n" + quake_Cmd.text;
	}
};
quake_Cmd.Exec_f = function() {
	if(quake_Cmd.argv.length != 2) {
		quake_Console.Print("exec <filename> : execute a script file\n");
		return;
	}
	var filename = quake_Cmd.argv[1];
	var f = quake_COM.LoadTextFile(filename);
	if(f == null) {
		quake_Console.Print("couldn't exec " + filename + "\n");
		return;
	}
	quake_Console.Print("execing " + filename + "\n");
	quake_Cmd.text = f + quake_Cmd.text;
};
quake_Cmd.Echo_f = function() {
	var _g = 1;
	var _g1 = quake_Cmd.argv.length;
	while(_g < _g1) quake_Console.Print(quake_Cmd.argv[_g++] + " ");
	quake_Console.Print("\n");
};
quake_Cmd.Alias_f = function() {
	if(quake_Cmd.argv.length <= 1) {
		quake_Console.Print("Current alias commands:\n");
		var name = quake_Cmd.alias.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this = quake_Cmd.alias;
			quake_Console.Print(name1 + " : " + (__map_reserved[name1] != null ? _this.getReserved(name1) : _this.h[name1]) + "\n");
		}
	}
	var name2 = quake_Cmd.argv[1];
	var value = "";
	var _g = 2;
	var _g1 = quake_Cmd.argv.length;
	while(_g < _g1) {
		var j = _g++;
		value += quake_Cmd.argv[j];
		if(j != quake_Cmd.argv.length - 1) {
			value += " ";
		}
	}
	var v = value + "\n";
	var _this1 = quake_Cmd.alias;
	if(__map_reserved[name2] != null) {
		_this1.setReserved(name2,v);
	} else {
		_this1.h[name2] = v;
	}
};
quake_Cmd.Wait_f = function() {
	quake_Cmd.wait = true;
};
quake_Cmd.TokenizeString = function(text) {
	quake_Cmd.argv = [];
	while(true) {
		var i = 0;
		while(i < text.length) {
			var c = HxOverrides.cca(text,i);
			if(c > 32 || c == 10) {
				break;
			}
			++i;
		}
		if(quake_Cmd.argv.length == 1) {
			quake_Cmd.args = text.substring(i);
		}
		if(HxOverrides.cca(text,i) == 10 || i >= text.length) {
			return;
		}
		text = quake_COM.Parse(text);
		if(text == null) {
			return;
		}
		quake_Cmd.argv.push(quake_COM.token);
	}
};
var quake__$Console_ConsoleEntry = function(s,t) {
	this.text = s;
	this.time = t;
};
quake__$Console_ConsoleEntry.__name__ = true;
var quake_Console = function() { };
quake_Console.__name__ = true;
quake_Console.Init = function() {
	quake_Console.debuglog = quake_COM.CheckParm("-condebug") != null;
	if(quake_Console.debuglog) {
		quake_COM.WriteTextFile("qconsole.log","");
	}
	quake_Console.Print("Console initialized.\n");
	quake_Console.notifytime = quake_Cvar.RegisterVariable("con_notifytime","3");
	quake_Cmd.AddCommand("toggleconsole",quake_Console.ToggleConsole_f);
	quake_Cmd.AddCommand("messagemode",quake_Console.MessageMode_f);
	quake_Cmd.AddCommand("messagemode2",quake_Console.MessageMode2_f);
	quake_Cmd.AddCommand("clear",quake_Console.Clear_f);
};
quake_Console.ToggleConsole_f = function() {
	quake_SCR.EndLoadingPlaque();
	if(quake_Key.dest == 1) {
		if(quake_CL.cls.state != 2) {
			quake_Menu.Menu_Main_f();
			return;
		}
		quake_Key.dest = 0;
		quake_Key.edit_line = "";
		quake_Key.history_line = quake_Key.lines.length;
		return;
	}
	quake_Key.dest = 1;
};
quake_Console.MessageMode_f = function() {
	quake_Key.dest = 2;
	quake_Key.team_message = false;
};
quake_Console.MessageMode2_f = function() {
	quake_Key.dest = 2;
	quake_Key.team_message = true;
};
quake_Console.Clear_f = function() {
	quake_Console.backscroll = 0;
	quake_Console.current = 0;
	quake_Console.text = [];
};
quake_Console.Print = function(msg) {
	if(quake_Console.debuglog) {
		var data = quake_COM.LoadTextFile("qconsole.log");
		if(data != null) {
			data += msg;
			if(data.length >= 32768) {
				data = data.substring(data.length - 16384);
			}
			quake_COM.WriteTextFile("qconsole.log",data);
		}
	}
	quake_Console.backscroll = 0;
	var mask = 0;
	if(HxOverrides.cca(msg,0) <= 2) {
		mask = 128;
		if(HxOverrides.cca(msg,0) == 1) {
			quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Console.sfx_talk,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		}
		msg = msg.substring(1);
	}
	var _g = 0;
	var _g1 = msg.length;
	while(_g < _g1) {
		var i = _g++;
		if(quake_Console.text[quake_Console.current] == null) {
			quake_Console.text[quake_Console.current] = new quake__$Console_ConsoleEntry("",quake_Host.realtime);
		}
		if(HxOverrides.cca(msg,i) == 10) {
			if(quake_Console.text.length >= 1024) {
				quake_Console.text = quake_Console.text.slice(-512);
				quake_Console.current = quake_Console.text.length;
			} else {
				quake_Console.current++;
			}
			continue;
		}
		var code = HxOverrides.cca(msg,i) + mask;
		quake_Console.text[quake_Console.current].text += String.fromCodePoint(code);
	}
};
quake_Console.DPrint = function(msg) {
	if(quake_Host.developer.value != 0) {
		quake_Console.Print(msg);
	}
};
quake_Console.DrawNotify = function() {
	var width = (quake_VID.width >> 3) - 2;
	var i = quake_Console.text.length - 4;
	var v = 0;
	var _g = i < 0 ? 0 : i;
	var _g1 = quake_Console.text.length;
	while(_g < _g1) {
		var i1 = _g++;
		if(quake_Host.realtime - quake_Console.text[i1].time > quake_Console.notifytime.value) {
			continue;
		}
		quake_Draw.String(8,v,quake_Console.text[i1].text.substring(0,width));
		v += 8;
	}
	if(quake_Key.dest == 2) {
		var code = 10 + ((quake_Host.realtime * 4.0 | 0) & 1);
		quake_Draw.String(8,v,"say: " + quake_Key.chat_buffer + String.fromCodePoint(code));
	}
};
quake_Console.ClearNotify = function() {
	var i = quake_Console.text.length - 4;
	var _g = i < 0 ? 0 : i;
	var _g1 = quake_Console.text.length;
	while(_g < _g1) quake_Console.text[_g++].time = 0.0;
};
quake_Console.DrawConsole = function(lines) {
	if(lines <= 0) {
		return;
	}
	lines = Math.floor(lines * quake_VID.height * 0.005);
	quake_Draw.ConsoleBackground(lines);
	var width = (quake_VID.width >> 3) - 2;
	var y = lines - 16;
	var i = quake_Console.text.length - 1 - quake_Console.backscroll;
	while(i >= 0) {
		if(quake_Console.text[i].text.length == 0) {
			y -= 8;
		} else {
			y -= Math.ceil(quake_Console.text[i].text.length / width) << 3;
		}
		--i;
		if(y <= 0) {
			break;
		}
	}
	var _g = i + 1;
	var _g1 = quake_Console.text.length - quake_Console.backscroll;
	while(_g < _g1) {
		var txt = quake_Console.text[_g++].text;
		var rows = Math.ceil(txt.length / width);
		if(rows == 0) {
			y += 8;
			continue;
		}
		var _g2 = 0;
		while(_g2 < rows) {
			quake_Draw.String(8,y,HxOverrides.substr(txt,_g2++ * width,width));
			y += 8;
		}
	}
	quake_Console.DrawInput(lines);
};
quake_Console.DrawInput = function(vislines) {
	if(quake_Key.dest != 1 && !quake_Console.forcedup) {
		return;
	}
	var code = 10 + ((quake_Host.realtime * 4.0 | 0) & 1);
	var text = "]" + quake_Key.edit_line + String.fromCodePoint(code);
	var width = (quake_VID.width >> 3) - 2;
	if(text.length >= width) {
		text = text.substring(1 + text.length - width);
	}
	quake_Draw.String(8,vislines - 16,text);
};
var quake_Cvar = function(name,value,archive,server) {
	this.name = name;
	this.string = value;
	this.archive = archive;
	this.server = server;
	this.value = quake_Q.atof(value);
};
quake_Cvar.__name__ = true;
quake_Cvar.CompleteVariable = function(partial) {
	if(partial.length == 0) {
		return null;
	}
	var name = quake_Cvar.vars.keys();
	while(name.hasNext()) {
		var name1 = name.next();
		if(name1.substring(0,partial.length) == partial) {
			return name1;
		}
	}
	return null;
};
quake_Cvar.Set = function(name,value) {
	var _this = quake_Cvar.vars;
	var v = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
	if(v == null) {
		quake_Console.Print("Cvar.Set: variable " + name + " not found\n");
	} else {
		v.set(value);
	}
};
quake_Cvar.RegisterVariable = function(name,value,archive,server) {
	if(server == null) {
		server = false;
	}
	if(archive == null) {
		archive = false;
	}
	var _this = quake_Cvar.vars;
	if(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name)) {
		quake_Console.Print("Can't register variable " + name + ", already defined\n");
		return null;
	}
	var this1 = quake_Cvar.vars;
	var v = new quake_Cvar(name,value,archive,server);
	var _this1 = this1;
	if(__map_reserved[name] != null) {
		_this1.setReserved(name,v);
	} else {
		_this1.h[name] = v;
	}
	return v;
};
quake_Cvar.Command = function() {
	var name = quake_Cmd.argv[0];
	var _this = quake_Cvar.vars;
	var v = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
	if(v == null) {
		return false;
	}
	if(quake_Cmd.argv.length <= 1) {
		quake_Console.Print("\"" + v.name + "\" is \"" + v.string + "\"\n");
		return true;
	}
	quake_Cvar.Set(v.name,quake_Cmd.argv[1]);
	return true;
};
quake_Cvar.WriteVariables = function() {
	var f = [];
	var _this = quake_Cvar.vars;
	var v = new haxe_ds__$StringMap_StringMapIterator(_this,_this.arrayKeys());
	while(v.hasNext()) {
		var v1 = v.next();
		if(v1.archive) {
			f.push(v1.name + " \"" + v1.string + "\"\n");
		}
	}
	return f.join("");
};
quake_Cvar.prototype = {
	set: function(s) {
		var changed = this.string != s;
		this.string = s;
		this.value = quake_Q.atof(s);
		if(this.server && changed && quake_SV.server.active) {
			quake_Host.BroadcastPrint("\"" + this.name + "\" changed to \"" + this.string + "\"\n");
		}
	}
	,setValue: function(value) {
		this.set(value.toFixed(6));
	}
};
var quake_DLight = function() {
	this.key = 0;
	this.origin = new Float32Array(3);
	this.radius = 0;
	this.minlight = 0;
	this.decay = 0;
	this.die = 0;
};
quake_DLight.__name__ = true;
var quake_Def = function() { };
quake_Def.__name__ = true;
var quake_DrawPic = function(buf) {
	if(buf != null) {
		var view = new DataView(buf,0,8);
		this.width = view.getUint32(0,true);
		this.height = view.getUint32(4,true);
		this.data = new Uint8Array(buf,8,this.width * this.height);
		this.texnum = quake_GL.LoadPicTexture(this);
	}
};
quake_DrawPic.__name__ = true;
var quake_Draw = function() { };
quake_Draw.__name__ = true;
quake_Draw.CharToConback = function(num,dest) {
	var source = (num >> 4 << 10) + ((num & 15) << 3);
	var _g = 0;
	while(_g < 8) {
		++_g;
		if(quake_Draw.chars[source] != 0) {
			quake_Draw.conback.data[dest] = 96 + quake_Draw.chars[source];
		}
		if(quake_Draw.chars[source + 1] != 0) {
			quake_Draw.conback.data[dest + 1] = 96 + quake_Draw.chars[source + 1];
		}
		if(quake_Draw.chars[source + 2] != 0) {
			quake_Draw.conback.data[dest + 2] = 96 + quake_Draw.chars[source + 2];
		}
		if(quake_Draw.chars[source + 3] != 0) {
			quake_Draw.conback.data[dest + 3] = 96 + quake_Draw.chars[source + 3];
		}
		if(quake_Draw.chars[source + 4] != 0) {
			quake_Draw.conback.data[dest + 4] = 96 + quake_Draw.chars[source + 4];
		}
		if(quake_Draw.chars[source + 5] != 0) {
			quake_Draw.conback.data[dest + 5] = 96 + quake_Draw.chars[source + 5];
		}
		if(quake_Draw.chars[source + 6] != 0) {
			quake_Draw.conback.data[dest + 6] = 96 + quake_Draw.chars[source + 6];
		}
		if(quake_Draw.chars[source + 7] != 0) {
			quake_Draw.conback.data[dest + 7] = 96 + quake_Draw.chars[source + 7];
		}
		source += 128;
		dest += 320;
	}
};
quake_Draw.Init = function() {
	quake_Draw.chars = new Uint8Array(quake_W.GetLumpName("CONCHARS"));
	var trans = new ArrayBuffer(65536);
	var trans32 = new Uint32Array(trans);
	var _g = 0;
	while(_g < 16384) {
		var i = _g++;
		if(quake_Draw.chars[i] != 0) {
			trans32[i] = quake_COM.LittleLong(quake_VID.d_8to24table[quake_Draw.chars[i]] + (-16777216));
		}
	}
	quake_Draw.char_texture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Draw.char_texture);
	quake_GL.gl.texImage2D(3553,0,6408,128,128,0,6408,5121,new Uint8Array(trans));
	quake_GL.gl.texParameterf(3553,10241,9729);
	quake_GL.gl.texParameterf(3553,10240,9729);
	quake_Draw.conback = new quake_DrawPic(null);
	var cb = quake_COM.LoadFile("gfx/conback.lmp");
	if(cb == null) {
		quake_Sys.Error("Couldn't load gfx/conback.lmp");
	}
	quake_Draw.conback.width = 320;
	quake_Draw.conback.height = 200;
	quake_Draw.conback.data = new Uint8Array(cb,8,64000);
	var ver = "(HaxeQuake " + "0.0.1" + ") 1.09";
	var _g1 = 0;
	var _g2 = ver.length;
	while(_g1 < _g2) {
		var i1 = _g1++;
		quake_Draw.CharToConback(HxOverrides.cca(ver,i1),59829 - (ver.length - i1 << 3));
	}
	quake_Draw.conback.texnum = quake_GL.LoadPicTexture(quake_Draw.conback);
	quake_Draw.loading = quake_Draw.CachePic("loading");
	quake_Draw.loadingElem = window.document.getElementById("loading");
	quake_Draw.loadingElem.src = quake_Draw.PicToDataURL(quake_Draw.loading);
	var tmp = "url(\"" + quake_Draw.PicToDataURL(new quake_DrawPic(quake_W.GetLumpName("BACKTILE")));
	window.document.body.style.backgroundImage = tmp + "\")";
};
quake_Draw.Character = function(x,y,num) {
	var program = quake_GL.UseProgram(quake_GLPrograms.character);
	quake_GL.Bind(program.tTexture,quake_Draw.char_texture);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.uniform2f(program.uCharacter,num & 15,num >> 4);
	quake_GL.gl.uniform2f(program.uDest,x,y);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Draw.String = function(x,y,str) {
	var program = quake_GL.UseProgram(quake_GLPrograms.character);
	quake_GL.Bind(program.tTexture,quake_Draw.char_texture);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	var _g = 0;
	var _g1 = str.length;
	while(_g < _g1) {
		var num = HxOverrides.cca(str,_g++);
		quake_GL.gl.uniform2f(program.uCharacter,num & 15,num >> 4);
		quake_GL.gl.uniform2f(program.uDest,x,y);
		quake_GL.gl.drawArrays(5,0,4);
		x += 8;
	}
};
quake_Draw.StringWhite = function(x,y,str) {
	var program = quake_GL.UseProgram(quake_GLPrograms.character);
	quake_GL.Bind(program.tTexture,quake_Draw.char_texture);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	var _g = 0;
	var _g1 = str.length;
	while(_g < _g1) {
		var num = HxOverrides.cca(str,_g++) + 128;
		quake_GL.gl.uniform2f(program.uCharacter,num & 15,num >> 4);
		quake_GL.gl.uniform2f(program.uDest,x,y);
		quake_GL.gl.drawArrays(5,0,4);
		x += 8;
	}
};
quake_Draw.CachePic = function(path) {
	path = "gfx/" + path + ".lmp";
	var buf = quake_COM.LoadFile(path);
	if(buf == null) {
		quake_Sys.Error("CachePic: failed to load " + path);
	}
	return new quake_DrawPic(buf);
};
quake_Draw.Pic = function(x,y,pic) {
	var program = quake_GL.UseProgram(quake_GLPrograms.pic);
	quake_GL.Bind(program.tTexture,pic.texnum);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.uniform4f(program.uRect,x,y,pic.width,pic.height);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Draw.PicTranslate = function(x,y,pic,top,bottom) {
	var program = quake_GL.UseProgram(quake_GLPrograms.picTranslate);
	quake_GL.Bind(program.tTexture,pic.texnum);
	quake_GL.Bind(program.tTrans,pic.translate);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.uniform4f(program.uRect,x,y,pic.width,pic.height);
	var p = quake_VID.d_8to24table[top];
	quake_GL.gl.uniform3f(program.uTop,p & 255,p >> 8 & 255,p >> 16);
	p = quake_VID.d_8to24table[bottom];
	quake_GL.gl.uniform3f(program.uBottom,p & 255,p >> 8 & 255,p >> 16);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Draw.ConsoleBackground = function(lines) {
	var program = quake_GL.UseProgram(quake_GLPrograms.pic);
	quake_GL.Bind(program.tTexture,quake_Draw.conback.texnum);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.uniform4f(program.uRect,0,lines - quake_VID.height,quake_VID.width,quake_VID.height);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Draw.Fill = function(x,y,w,h,c) {
	var program = quake_GL.UseProgram(quake_GLPrograms.fill);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.uniform4f(program.uRect,x,y,w,h);
	var color = quake_VID.d_8to24table[c];
	quake_GL.gl.uniform4f(program.uColor,color & 255,color >> 8 & 255,color >> 16,1.0);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Draw.FadeScreen = function() {
	var program = quake_GL.UseProgram(quake_GLPrograms.fill);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.uniform4f(program.uRect,0,0,quake_VID.width,quake_VID.height);
	quake_GL.gl.uniform4f(program.uColor,0.0,0.0,0.0,0.8);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Draw.BeginDisc = function() {
	if(quake_Draw.loadingElem == null) {
		return;
	}
	quake_Draw.loadingElem.style.left = (quake_VID.width - quake_Draw.loading.width >> 1) + "px";
	quake_Draw.loadingElem.style.top = (quake_VID.height - quake_Draw.loading.height >> 1) + "px";
	quake_Draw.loadingElem.style.display = "inline-block";
};
quake_Draw.EndDisc = function() {
	if(quake_Draw.loadingElem != null) {
		quake_Draw.loadingElem.style.display = "none";
	}
};
quake_Draw.PicToDataURL = function(pic) {
	var canvas = window.document.createElement("canvas");
	canvas.width = pic.width;
	canvas.height = pic.height;
	var ctx = canvas.getContext("2d");
	var data = ctx.createImageData(pic.width,pic.height);
	var trans = new ArrayBuffer(data.data.length);
	var trans32 = new Uint32Array(trans);
	var _g = 0;
	var _g1 = pic.data.length;
	while(_g < _g1) {
		var i = _g++;
		trans32[i] = quake_COM.LittleLong(quake_VID.d_8to24table[pic.data[i]] + (-16777216));
	}
	data.data.set(new Uint8Array(trans));
	ctx.putImageData(data,0,0);
	return canvas.toDataURL();
};
var quake_ED = function() { };
quake_ED.__name__ = true;
quake_ED.Alloc = function() {
	var i = quake_SV.svs.maxclients + 1;
	while(i < quake_SV.server.num_edicts) {
		var e = quake_SV.server.edicts[i++];
		if(e.free && (e.freetime < 2.0 || quake_SV.server.time - e.freetime > 0.5)) {
			e.Clear();
			return e;
		}
	}
	if(i == 2048) {
		quake_Sys.Error("ED.Alloc: no free edicts (max_edicts is " + 2048 + ")");
	}
	var e1 = quake_SV.server.edicts[quake_SV.server.num_edicts++];
	e1.Clear();
	return e1;
};
quake_ED.Free = function(ed) {
	quake_SV.UnlinkEdict(ed);
	ed.free = true;
	ed.v.ints[29] = 0;
	ed.v.floats[59] = 0.0;
	ed.v.floats[0] = 0.0;
	ed.v.floats[77] = 0.0;
	ed.v.floats[31] = 0.0;
	ed.v.floats[30] = 0.0;
	ed.v.origin.set(quake__$Vec_Vec_$Impl_$.origin);
	ed.v.angles.set(quake__$Vec_Vec_$Impl_$.origin);
	ed.v.floats[46] = -1.0;
	ed.v.floats[9] = 0.0;
	ed.freetime = quake_SV.server.time;
};
quake_ED.GlobalAtOfs = function(ofs) {
	var _g = 0;
	var _g1 = quake_PR.globaldefs;
	while(_g < _g1.length) {
		var def = _g1[_g];
		++_g;
		if(def.ofs == ofs) {
			return def;
		}
	}
	return null;
};
quake_ED.FieldAtOfs = function(ofs) {
	var _g = 0;
	var _g1 = quake_PR.fielddefs;
	while(_g < _g1.length) {
		var def = _g1[_g];
		++_g;
		if(def.ofs == ofs) {
			return def;
		}
	}
	return null;
};
quake_ED.FindField = function(name) {
	var _g = 0;
	var _g1 = quake_PR.fielddefs;
	while(_g < _g1.length) {
		var def = _g1[_g];
		++_g;
		if(quake_PR.GetString(def.name) == name) {
			return def;
		}
	}
	return null;
};
quake_ED.FindGlobal = function(name) {
	var _g = 0;
	var _g1 = quake_PR.globaldefs;
	while(_g < _g1.length) {
		var def = _g1[_g];
		++_g;
		if(quake_PR.GetString(def.name) == name) {
			return def;
		}
	}
	return null;
};
quake_ED.FindFunction = function(name) {
	var _g = 0;
	var _g1 = quake_PR.functions.length;
	while(_g < _g1) {
		var i = _g++;
		if(quake_PR.GetString(quake_PR.functions[i].name) == name) {
			return i;
		}
	}
	return null;
};
quake_ED.Print = function(ed) {
	if(ed.free) {
		quake_Console.Print("FREE\n");
		return;
	}
	quake_Console.Print("\nEDICT " + ed.num + ":\n");
	var _g = 1;
	var _g1 = quake_PR.fielddefs.length;
	while(_g < _g1) {
		var d = quake_PR.fielddefs[_g++];
		var name = quake_PR.GetString(d.name);
		if(HxOverrides.cca(name,name.length - 2) == 95) {
			continue;
		}
		var v = d.ofs;
		if(ed.v.ints[v] == 0) {
			if((d.type & 32767) == 3) {
				if(ed.v.ints[v + 1] == 0 && ed.v.ints[v + 2] == 0) {
					continue;
				}
			} else {
				continue;
			}
		}
		while(name.length <= 14) name += " ";
		quake_Console.Print(name + quake_PR.ValueString(d.type,ed.v.buffer,v) + "\n");
	}
};
quake_ED.PrintEdicts = function() {
	if(!quake_SV.server.active) {
		return;
	}
	quake_Console.Print(quake_SV.server.num_edicts + " entities\n");
	var _g = 0;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) quake_ED.Print(quake_SV.server.edicts[_g++]);
};
quake_ED.PrintEdict_f = function() {
	if(!quake_SV.server.active) {
		return;
	}
	var i = quake_Q.atoi(quake_Cmd.argv[1]);
	if(i >= 0 && i < quake_SV.server.num_edicts) {
		quake_ED.Print(quake_SV.server.edicts[i]);
	}
};
quake_ED.Count = function() {
	if(!quake_SV.server.active) {
		return;
	}
	var active = 0;
	var models = 0;
	var solid = 0;
	var step = 0;
	var _g = 0;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var ent = quake_SV.server.edicts[_g++];
		if(ent.free) {
			continue;
		}
		++active;
		if(ent.v.floats[9] != 0.0) {
			++solid;
		}
		if(ent.v.ints[29] != 0) {
			++models;
		}
		if(ent.v.floats[8] == 4) {
			++step;
		}
	}
	var num_edicts = quake_SV.server.num_edicts;
	quake_Console.Print("num_edicts:" + (num_edicts <= 9 ? "  " : num_edicts <= 99 ? " " : "") + num_edicts + "\n");
	quake_Console.Print("active    :" + (active <= 9 ? "  " : active <= 99 ? " " : "") + active + "\n");
	quake_Console.Print("view      :" + (models <= 9 ? "  " : models <= 99 ? " " : "") + models + "\n");
	quake_Console.Print("touch     :" + (solid <= 9 ? "  " : solid <= 99 ? " " : "") + solid + "\n");
	quake_Console.Print("step      :" + (step <= 9 ? "  " : step <= 99 ? " " : "") + step + "\n");
};
quake_ED.NewString = function(string) {
	var newstring_b = "";
	var i = 0;
	while(i < string.length) {
		var c = HxOverrides.cca(string,i);
		if(c == 92 && i < string.length - 1) {
			++i;
			var c1 = HxOverrides.cca(string,i) == 110 ? 10 : 92;
			newstring_b += String.fromCodePoint(c1);
		} else {
			newstring_b += String.fromCodePoint(c);
		}
		++i;
	}
	return quake_PR.NewString(newstring_b,string.length + 1);
};
quake_ED.ParseEpair = function(base,key,s) {
	var d_float = new Float32Array(base);
	var d_int = new Int32Array(base);
	switch(key.type & 32767) {
	case 1:
		d_int[key.ofs] = quake_ED.NewString(s);
		return true;
	case 2:
		d_float[key.ofs] = quake_Q.atof(s);
		return true;
	case 3:
		var v = s.split(" ");
		d_float[key.ofs] = quake_Q.atof(v[0]);
		d_float[key.ofs + 1] = quake_Q.atof(v[1]);
		d_float[key.ofs + 2] = quake_Q.atof(v[2]);
		return true;
	case 4:
		d_int[key.ofs] = quake_Q.atoi(s);
		return true;
	case 5:
		var d = quake_ED.FindField(s);
		if(d == null) {
			quake_Console.Print("Can't find field " + s + "\n");
			return false;
		}
		d_int[key.ofs] = d.ofs;
		return true;
	case 6:
		var d1 = quake_ED.FindFunction(s);
		if(d1 == null) {
			quake_Console.Print("Can't find function " + s + "\n");
			return false;
		}
		d_int[key.ofs] = d1;
		break;
	default:
	}
	return true;
};
quake_ED.ParseEdict = function(data,ent) {
	if(ent != quake_SV.server.edicts[0]) {
		var _g = 0;
		var _g1 = quake_PR.entityfields;
		while(_g < _g1) ent.v.ints[_g++] = 0;
	}
	var init = false;
	while(true) {
		data = quake_COM.Parse(data);
		if(HxOverrides.cca(quake_COM.token,0) == 125) {
			break;
		}
		if(data == null) {
			quake_Sys.Error("ED.ParseEdict: EOF without closing brace");
		}
		var anglehack;
		if(quake_COM.token == "angle") {
			quake_COM.token = "angles";
			anglehack = true;
		} else {
			anglehack = false;
			if(quake_COM.token == "light") {
				quake_COM.token = "light_lev";
			}
		}
		var n = quake_COM.token.length;
		while(n > 0) {
			if(HxOverrides.cca(quake_COM.token,n - 1) != 32) {
				break;
			}
			--n;
		}
		var keyname = quake_COM.token.substring(0,n);
		data = quake_COM.Parse(data);
		if(data == null) {
			quake_Sys.Error("ED.ParseEdict: EOF without closing brace");
		}
		if(HxOverrides.cca(quake_COM.token,0) == 125) {
			quake_Sys.Error("ED.ParseEdict: closing brace without data");
		}
		init = true;
		if(HxOverrides.cca(keyname,0) == 95) {
			continue;
		}
		var key = quake_ED.FindField(keyname);
		if(key == null) {
			quake_Console.Print("'" + keyname + "' is not a field\n");
			continue;
		}
		if(anglehack) {
			quake_COM.token = "0 " + quake_COM.token + " 0";
		}
		if(!quake_ED.ParseEpair(ent.v.buffer,key,quake_COM.token)) {
			quake_Host.Error("ED.ParseEdict: parse error");
		}
	}
	if(!init) {
		ent.free = true;
	}
	return data;
};
quake_ED.LoadFromFile = function(data) {
	var ent = null;
	var inhibit = 0;
	quake_PR.globals.floats[31] = quake_SV.server.time;
	while(true) {
		data = quake_COM.Parse(data);
		if(data == null) {
			break;
		}
		if(HxOverrides.cca(quake_COM.token,0) != 123) {
			quake_Sys.Error("ED.LoadFromFile: found " + quake_COM.token + " when expecting {");
		}
		if(ent == null) {
			ent = quake_SV.server.edicts[0];
		} else {
			ent = quake_ED.Alloc();
		}
		data = quake_ED.ParseEdict(data,ent);
		var spawnflags = ent.v.floats[89] | 0;
		if(quake_Host.deathmatch.value != 0) {
			if((spawnflags & 2048) != 0) {
				quake_ED.Free(ent);
				++inhibit;
				continue;
			}
		} else if(quake_Host.current_skill == 0 && (spawnflags & 256) != 0 || quake_Host.current_skill == 1 && (spawnflags & 512) != 0 || quake_Host.current_skill >= 2 && (spawnflags & 1024) != 0) {
			quake_ED.Free(ent);
			++inhibit;
			continue;
		}
		if(ent.v.ints[28] == 0) {
			quake_Console.Print("No classname for:\n");
			quake_ED.Print(ent);
			quake_ED.Free(ent);
			continue;
		}
		var func = quake_ED.FindFunction(quake_PR.GetString(ent.v.ints[28]));
		if(func == null) {
			quake_Console.Print("No spawn function for:\n");
			quake_ED.Print(ent);
			quake_ED.Free(ent);
			continue;
		}
		quake_PR.globals.ints[28] = ent.num;
		quake_PR.ExecuteProgram(func);
	}
	quake_Console.DPrint(inhibit + " entities inhibited\n");
};
var quake_Edict = function(num) {
	this.num = num;
	this.free = false;
	this.area = new quake_EdictLink();
	this.area.ent = this;
	this.leafnums = [];
	this.baseline = new quake_EntityState();
	this.freetime = 0.0;
	this.v = new quake_EdictVars(new ArrayBuffer(quake_PR.entityfields << 2));
};
quake_Edict.__name__ = true;
quake_Edict.prototype = {
	Clear: function() {
		var _g = 0;
		var _g1 = quake_PR.entityfields;
		while(_g < _g1) this.v.ints[_g++] = 0;
		this.free = false;
	}
};
var quake_EdictLink = function() {
};
quake_EdictLink.__name__ = true;
var quake_EdictVars = function(buf) {
	this.buffer = buf;
	this.floats = new Float32Array(buf);
	this.ints = new Int32Array(buf);
	this.absmin = new Float32Array(this.buffer,4,3);
	this.absmax = new Float32Array(this.buffer,16,3);
	this.origin = new Float32Array(this.buffer,40,3);
	this.oldorigin = new Float32Array(this.buffer,52,3);
	this.velocity = new Float32Array(this.buffer,64,3);
	this.angles = new Float32Array(this.buffer,76,3);
	this.avelocity = new Float32Array(this.buffer,88,3);
	this.punchangle = new Float32Array(this.buffer,100,3);
	this.mins = new Float32Array(this.buffer,132,3);
	this.maxs = new Float32Array(this.buffer,144,3);
	this.size = new Float32Array(this.buffer,156,3);
	this.view_ofs = new Float32Array(this.buffer,248,3);
	this.v_angle = new Float32Array(this.buffer,280,3);
	this.movedir = new Float32Array(this.buffer,384,3);
};
quake_EdictVars.__name__ = true;
var quake_Entity = function(n) {
	if(n == null) {
		n = -1;
	}
	this.baseline = new quake_EntityState();
	this.effects = 0;
	this.msgtime = 0.0;
	this.skinnum = 0;
	this.syncbase = 0.0;
	this.frame = 0;
	this.msg_origins1 = new Float32Array(3);
	this.msg_origins0 = new Float32Array(3);
	this.origin = new Float32Array(3);
	this.msg_angles1 = new Float32Array(3);
	this.msg_angles0 = new Float32Array(3);
	this.angles = new Float32Array(3);
	this.leafs = [];
	this.num = n;
};
quake_Entity.__name__ = true;
var quake_EntityState = function() {
	this.effects = 0;
	this.skin = 0;
	this.colormap = 0;
	this.frame = 0;
	this.modelindex = 0;
	this.angles = new Float32Array(3);
	this.origin = new Float32Array(3);
};
quake_EntityState.__name__ = true;
var quake__$GL_GLModeSetting = function(min,max) {
	this.min = min;
	this.max = max;
};
quake__$GL_GLModeSetting.__name__ = true;
var quake_GLTexture = function(id,w,h) {
	this.texnum = quake_GL.gl.createTexture();
	this.identifier = id;
	this.width = w;
	this.height = h;
};
quake_GLTexture.__name__ = true;
var quake_GL = function() { };
quake_GL.__name__ = true;
quake_GL.Bind = function(target,texnum) {
	if(quake_GL.currenttextures.h[target] != texnum) {
		if(quake_GL.activetexture != target) {
			quake_GL.activetexture = target;
			quake_GL.gl.activeTexture(33984 + target);
		}
		quake_GL.currenttextures.h[target] = texnum;
		quake_GL.gl.bindTexture(3553,texnum);
	}
};
quake_GL.TextureMode_f = function() {
	if(quake_Cmd.argv.length <= 1) {
		var name = quake_GL.modes.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this = quake_GL.modes;
			if(quake_GL.filter_min == (__map_reserved[name1] != null ? _this.getReserved(name1) : _this.h[name1]).min) {
				quake_Console.Print(name1 + "\n");
				return;
			}
		}
		quake_Console.Print("current filter is unknown???\n");
		return;
	}
	var name2 = quake_Cmd.argv[1].toUpperCase();
	var _this1 = quake_GL.modes;
	var mode = __map_reserved[name2] != null ? _this1.getReserved(name2) : _this1.h[name2];
	if(mode == null) {
		quake_Console.Print("bad filter name\n");
		return;
	}
	quake_GL.filter_min = mode.min;
	quake_GL.filter_max = mode.max;
	var _g = 0;
	var _g1 = quake_GL.textures;
	while(_g < _g1.length) {
		quake_GL.Bind(0,_g1[_g++].texnum);
		quake_GL.gl.texParameterf(3553,10241,quake_GL.filter_min);
		quake_GL.gl.texParameterf(3553,10240,quake_GL.filter_max);
	}
};
quake_GL.Set2D = function() {
	quake_GL.gl.viewport(0,0,quake_VID.width * quake_SCR.devicePixelRatio | 0,quake_VID.height * quake_SCR.devicePixelRatio | 0);
	quake_GL.UnbindProgram();
	var _g = 0;
	var _g1 = quake_GL.programs;
	while(_g < _g1.length) {
		var program = _g1[_g];
		++_g;
		program.gl.useProgram(program.program);
		program.setOrtho(quake_GL.ortho);
	}
	quake_GL.gl.disable(2929);
	quake_GL.gl.enable(3042);
};
quake_GL.ResampleTexture = function(data,inwidth,inheight,outwidth,outheight) {
	var out = new Uint8Array(new ArrayBuffer(outwidth * outheight));
	var xstep = inwidth / outwidth;
	var ystep = inheight / outheight;
	var src;
	var dest = 0;
	var _g = 0;
	while(_g < outheight) {
		src = Math.floor(_g++ * ystep) * inwidth;
		var _g1 = 0;
		while(_g1 < outwidth) {
			var j = _g1++;
			out[dest + j] = data[src + Math.floor(j * xstep)];
		}
		dest += outwidth;
	}
	return out;
};
quake_GL.Upload = function(data,width,height) {
	var scaled_width = width;
	var scaled_height = height;
	if((width & width - 1) != 0 || (height & height - 1) != 0) {
		scaled_width = width - 1;
		scaled_width |= scaled_width >> 1;
		scaled_width |= scaled_width >> 2;
		scaled_width |= scaled_width >> 4;
		scaled_width |= scaled_width >> 8;
		scaled_width |= scaled_width >> 16;
		++scaled_width;
		scaled_height = height - 1;
		scaled_height |= scaled_height >> 1;
		scaled_height |= scaled_height >> 2;
		scaled_height |= scaled_height >> 4;
		scaled_height |= scaled_height >> 8;
		scaled_height |= scaled_height >> 16;
		++scaled_height;
	}
	if(scaled_width > quake_GL.maxtexturesize) {
		scaled_width = quake_GL.maxtexturesize;
	}
	if(scaled_height > quake_GL.maxtexturesize) {
		scaled_height = quake_GL.maxtexturesize;
	}
	if(scaled_width != width || scaled_height != height) {
		data = quake_GL.ResampleTexture(data,width,height,scaled_width,scaled_height);
	}
	var trans = new ArrayBuffer(scaled_width * scaled_height << 2);
	var trans32 = new Uint32Array(trans);
	var i = scaled_width * scaled_height - 1;
	while(i >= 0) {
		trans32[i] = quake_COM.LittleLong(quake_VID.d_8to24table[data[i]] + (-16777216));
		if(data[i] >= 224) {
			trans32[i] &= 16777215;
		}
		--i;
	}
	quake_GL.gl.texImage2D(3553,0,6408,scaled_width,scaled_height,0,6408,5121,new Uint8Array(trans));
	quake_GL.gl.generateMipmap(3553);
	quake_GL.gl.texParameterf(3553,10241,quake_GL.filter_min);
	quake_GL.gl.texParameterf(3553,10240,quake_GL.filter_max);
};
quake_GL.LoadTexture = function(identifier,width,height,data) {
	if(identifier.length != 0) {
		var _g = 0;
		var _g1 = quake_GL.textures;
		while(_g < _g1.length) {
			var glt = _g1[_g];
			++_g;
			if(glt.identifier == identifier) {
				if(width != glt.width || height != glt.height) {
					quake_Sys.Error("GL.LoadTexture: cache mismatch");
				}
				return glt;
			}
		}
	}
	var scaled_width = width;
	var scaled_height = height;
	if((width & width - 1) != 0 || (height & height - 1) != 0) {
		scaled_width = width - 1;
		scaled_width |= scaled_width >> 1;
		scaled_width |= scaled_width >> 2;
		scaled_width |= scaled_width >> 4;
		scaled_width |= scaled_width >> 8;
		scaled_width |= scaled_width >> 16;
		++scaled_width;
		scaled_height = height - 1;
		scaled_height |= scaled_height >> 1;
		scaled_height |= scaled_height >> 2;
		scaled_height |= scaled_height >> 4;
		scaled_height |= scaled_height >> 8;
		scaled_height |= scaled_height >> 16;
		++scaled_height;
	}
	if(scaled_width > quake_GL.maxtexturesize) {
		scaled_width = quake_GL.maxtexturesize;
	}
	if(scaled_height > quake_GL.maxtexturesize) {
		scaled_height = quake_GL.maxtexturesize;
	}
	scaled_width >>= quake_GL.picmip.value | 0;
	if(scaled_width == 0) {
		scaled_width = 1;
	}
	scaled_height >>= quake_GL.picmip.value | 0;
	if(scaled_height == 0) {
		scaled_height = 1;
	}
	if(scaled_width != width || scaled_height != height) {
		data = quake_GL.ResampleTexture(data,width,height,scaled_width,scaled_height);
	}
	var glt1 = new quake_GLTexture(identifier,width,height);
	quake_GL.Bind(0,glt1.texnum);
	quake_GL.Upload(data,scaled_width,scaled_height);
	quake_GL.textures.push(glt1);
	return glt1;
};
quake_GL.LoadPicTexture = function(pic) {
	var data = pic.data;
	var scaled_width = pic.width;
	var scaled_height = pic.height;
	if((pic.width & pic.width - 1) != 0 || (pic.height & pic.height - 1) != 0) {
		--scaled_width;
		scaled_width |= scaled_width >> 1;
		scaled_width |= scaled_width >> 2;
		scaled_width |= scaled_width >> 4;
		scaled_width |= scaled_width >> 8;
		scaled_width |= scaled_width >> 16;
		++scaled_width;
		--scaled_height;
		scaled_height |= scaled_height >> 1;
		scaled_height |= scaled_height >> 2;
		scaled_height |= scaled_height >> 4;
		scaled_height |= scaled_height >> 8;
		scaled_height |= scaled_height >> 16;
		++scaled_height;
	}
	if(scaled_width > quake_GL.maxtexturesize) {
		scaled_width = quake_GL.maxtexturesize;
	}
	if(scaled_height > quake_GL.maxtexturesize) {
		scaled_height = quake_GL.maxtexturesize;
	}
	if(scaled_width != pic.width || scaled_height != pic.height) {
		data = quake_GL.ResampleTexture(data,pic.width,pic.height,scaled_width,scaled_height);
	}
	var texnum = quake_GL.gl.createTexture();
	quake_GL.Bind(0,texnum);
	var trans = new ArrayBuffer(scaled_width * scaled_height << 2);
	var trans32 = new Uint32Array(trans);
	var i = scaled_width * scaled_height - 1;
	while(i >= 0) {
		if(data[i] != 255) {
			trans32[i] = quake_COM.LittleLong(quake_VID.d_8to24table[data[i]] + (-16777216));
		}
		--i;
	}
	quake_GL.gl.texImage2D(3553,0,6408,scaled_width,scaled_height,0,6408,5121,new Uint8Array(trans));
	quake_GL.gl.texParameterf(3553,10241,9729);
	quake_GL.gl.texParameterf(3553,10240,9729);
	return texnum;
};
quake_GL.UseProgram = function(program) {
	if(quake_GL.currentProgram == program) {
		return program;
	}
	if(quake_GL.currentProgram != null) {
		quake_GL.currentProgram.unbind();
	}
	quake_GL.currentProgram = program;
	program.gl.useProgram(program.program);
	program.bind();
	return program;
};
quake_GL.UnbindProgram = function() {
	if(quake_GL.currentProgram == null) {
		return;
	}
	quake_GL.currentProgram.unbind();
	quake_GL.currentProgram = null;
};
quake_GL.RotationMatrix = function(pitch,yaw,roll) {
	pitch *= Math.PI / -180.0;
	yaw *= Math.PI / 180.0;
	roll *= Math.PI / 180.0;
	var sp = Math.sin(pitch);
	var cp = Math.cos(pitch);
	var sy = Math.sin(yaw);
	var cy = Math.cos(yaw);
	var sr = Math.sin(roll);
	var cr = Math.cos(roll);
	return [cy * cp,sy * cp,-sp,-sy * cr + cy * sp * sr,cy * cr + sy * sp * sr,cp * sr,-sy * -sr + cy * sp * cr,cy * -sr + sy * sp * cr,cp * cr];
};
quake_GL.Init = function() {
	quake_VID.mainwindow = window.document.getElementById("mainwindow");
	try {
		quake_GL.gl = quake_VID.mainwindow.getContext("webgl");
		if(quake_GL.gl == null) {
			quake_VID.mainwindow.getContext("experimental-webgl");
		}
	} catch( e ) {
	}
	if(quake_GL.gl == null) {
		quake_Sys.Error("Unable to initialize WebGL. Your browser may not support it.");
	}
	quake_GL.maxtexturesize = quake_GL.gl.getParameter(3379);
	quake_GL.gl.clearColor(0.0,0.0,0.0,0.0);
	quake_GL.gl.cullFace(1028);
	quake_GL.gl.blendFuncSeparate(770,771,1,1);
	var _g = new haxe_ds_StringMap();
	var value = new quake__$GL_GLModeSetting(9728,9728);
	if(__map_reserved["GL_NEAREST"] != null) {
		_g.setReserved("GL_NEAREST",value);
	} else {
		_g.h["GL_NEAREST"] = value;
	}
	var value1 = new quake__$GL_GLModeSetting(9729,9729);
	if(__map_reserved["GL_LINEAR"] != null) {
		_g.setReserved("GL_LINEAR",value1);
	} else {
		_g.h["GL_LINEAR"] = value1;
	}
	var value2 = new quake__$GL_GLModeSetting(9984,9728);
	if(__map_reserved["GL_NEAREST_MIPMAP_NEAREST"] != null) {
		_g.setReserved("GL_NEAREST_MIPMAP_NEAREST",value2);
	} else {
		_g.h["GL_NEAREST_MIPMAP_NEAREST"] = value2;
	}
	var value3 = new quake__$GL_GLModeSetting(9985,9729);
	if(__map_reserved["GL_LINEAR_MIPMAP_NEAREST"] != null) {
		_g.setReserved("GL_LINEAR_MIPMAP_NEAREST",value3);
	} else {
		_g.h["GL_LINEAR_MIPMAP_NEAREST"] = value3;
	}
	var value4 = new quake__$GL_GLModeSetting(9986,9728);
	if(__map_reserved["GL_NEAREST_MIPMAP_LINEAR"] != null) {
		_g.setReserved("GL_NEAREST_MIPMAP_LINEAR",value4);
	} else {
		_g.h["GL_NEAREST_MIPMAP_LINEAR"] = value4;
	}
	var value5 = new quake__$GL_GLModeSetting(9987,9729);
	if(__map_reserved["GL_LINEAR_MIPMAP_LINEAR"] != null) {
		_g.setReserved("GL_LINEAR_MIPMAP_LINEAR",value5);
	} else {
		_g.h["GL_LINEAR_MIPMAP_LINEAR"] = value5;
	}
	quake_GL.modes = _g;
	var _this = quake_GL.modes;
	var defaultMode = __map_reserved["GL_LINEAR_MIPMAP_NEAREST"] != null ? _this.getReserved("GL_LINEAR_MIPMAP_NEAREST") : _this.h["GL_LINEAR_MIPMAP_NEAREST"];
	quake_GL.filter_min = defaultMode.min;
	quake_GL.filter_max = defaultMode.max;
	quake_GL.picmip = quake_Cvar.RegisterVariable("gl_picmip","0");
	quake_Cmd.AddCommand("gl_texturemode",quake_GL.TextureMode_f);
	quake_GL.rect = quake_GL.gl.createBuffer();
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.bufferData(34962,new Float32Array([0,0,0,1,1,0,1,1]),35044);
	quake_VID.mainwindow.style.display = "inline-block";
	quake_GLPrograms.init(quake_GL.gl);
};
var quake_GLProgram = function(gl,srcVert,srcFrag) {
	this.gl = gl;
	this.program = gl.createProgram();
	var vsh = gl.createShader(35633);
	gl.shaderSource(vsh,srcVert);
	gl.compileShader(vsh);
	if(!gl.getShaderParameter(vsh,35713)) {
		quake_Sys.Error("Error compiling shader: " + gl.getShaderInfoLog(vsh));
	}
	var fsh = gl.createShader(35632);
	gl.shaderSource(fsh,srcFrag);
	gl.compileShader(fsh);
	if(!gl.getShaderParameter(fsh,35713)) {
		quake_Sys.Error("Error compiling shader: " + gl.getShaderInfoLog(fsh));
	}
	gl.attachShader(this.program,vsh);
	gl.attachShader(this.program,fsh);
	gl.linkProgram(this.program);
	if(!gl.getProgramParameter(this.program,35714)) {
		quake_Sys.Error("Error linking program: " + gl.getProgramInfoLog(this.program));
	}
	gl.useProgram(this.program);
};
quake_GLProgram.__name__ = true;
quake_GLProgram.prototype = {
	bind: function() {
	}
	,unbind: function() {
	}
	,setOrtho: function(ortho) {
	}
	,setGamma: function(gamma) {
	}
	,setViewOrigin: function(v) {
	}
	,setViewAngles: function(v) {
	}
	,setPerspective: function(v) {
	}
};
var quake_PCharacter = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec2 uCharacter;\nuniform vec2 uDest;\nuniform mat4 uOrtho;\nattribute vec2 aPoint;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_Position = uOrtho * vec4(aPoint * 8.0 + uDest, 0.0, 1.0);\n    vTexCoord = (aPoint + uCharacter) * 0.0625;\n}\n","precision mediump float;\nuniform sampler2D tTexture;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_FragColor = texture2D(tTexture, vTexCoord);\n}\n");
	this.uCharacter = this.gl.getUniformLocation(this.program,"uCharacter");
	this.uDest = this.gl.getUniformLocation(this.program,"uDest");
	this.uOrtho = this.gl.getUniformLocation(this.program,"uOrtho");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
};
quake_PCharacter.__name__ = true;
quake_PCharacter.__super__ = quake_GLProgram;
quake_PCharacter.prototype = $extend(quake_GLProgram.prototype,{
	setOrtho: function(ortho) {
		this.gl.uniformMatrix4fv(this.uOrtho,false,ortho);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PFill = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec4 uRect;\nuniform mat4 uOrtho;\nattribute vec2 aPoint;\nvoid main(void)\n{\n    gl_Position = uOrtho * vec4(uRect.xy + uRect.zw * aPoint, 0.0, 1.0);\n}\n","precision mediump float;\nuniform vec4 uColor;\nvoid main(void)\n{\n    gl_FragColor = vec4(uColor.rgb * (1.0 / 255.0), uColor.a);\n}\n");
	this.uRect = this.gl.getUniformLocation(this.program,"uRect");
	this.uOrtho = this.gl.getUniformLocation(this.program,"uOrtho");
	this.uColor = this.gl.getUniformLocation(this.program,"uColor");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
};
quake_PFill.__name__ = true;
quake_PFill.__super__ = quake_GLProgram;
quake_PFill.prototype = $extend(quake_GLProgram.prototype,{
	setOrtho: function(ortho) {
		this.gl.uniformMatrix4fv(this.uOrtho,false,ortho);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PPic = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec4 uRect;\nuniform mat4 uOrtho;\nattribute vec2 aPoint;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_Position = uOrtho * vec4(uRect.xy + uRect.zw * aPoint.xy, 0.0, 1.0);\n    vTexCoord = aPoint;\n}\n","precision mediump float;\nuniform sampler2D tTexture;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_FragColor = texture2D(tTexture, vTexCoord);\n}\n");
	this.uRect = this.gl.getUniformLocation(this.program,"uRect");
	this.uOrtho = this.gl.getUniformLocation(this.program,"uOrtho");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
};
quake_PPic.__name__ = true;
quake_PPic.__super__ = quake_GLProgram;
quake_PPic.prototype = $extend(quake_GLProgram.prototype,{
	setOrtho: function(ortho) {
		this.gl.uniformMatrix4fv(this.uOrtho,false,ortho);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PPicTranslate = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec4 uRect;\nuniform mat4 uOrtho;\nattribute vec2 aPoint;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_Position = uOrtho * vec4(uRect.xy + uRect.zw * aPoint.xy, 0.0, 1.0);\n    vTexCoord = aPoint;\n}\n","precision mediump float;\nuniform vec3 uTop;\nuniform vec3 uBottom;\nuniform sampler2D tTexture;\nuniform sampler2D tTrans;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    vec4 texture = texture2D(tTexture, vTexCoord);\n    vec4 trans = texture2D(tTrans, vTexCoord);\n    gl_FragColor = vec4(mix(mix(texture.rgb, uTop * (1.0 / 191.25) * trans.x, trans.y), uBottom * (1.0 / 191.25) * trans.z, trans.w), texture.a);\n}\n");
	this.uRect = this.gl.getUniformLocation(this.program,"uRect");
	this.uOrtho = this.gl.getUniformLocation(this.program,"uOrtho");
	this.uTop = this.gl.getUniformLocation(this.program,"uTop");
	this.uBottom = this.gl.getUniformLocation(this.program,"uBottom");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
	this.tTrans = 1;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTrans"),1);
};
quake_PPicTranslate.__name__ = true;
quake_PPicTranslate.__super__ = quake_GLProgram;
quake_PPicTranslate.prototype = $extend(quake_GLProgram.prototype,{
	setOrtho: function(ortho) {
		this.gl.uniformMatrix4fv(this.uOrtho,false,ortho);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PParticle = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec3 uOrigin;\nuniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nuniform float uScale;\nattribute vec2 aPoint;\nvarying vec2 vCoord;\nvoid main(void)\n{\n    vec2 point = (aPoint - 0.5) * uScale;\n    vec3 position = vec3(point.x, 0.0, point.y) + uViewAngles * (uOrigin - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vCoord = vec2(aPoint.x - 0.5, 0.5 - aPoint.y) * 2.0;\n}\n","precision mediump float;\nuniform float uGamma;\nuniform vec3 uColor;\nvarying vec2 vCoord;\nvoid main(void)\n{\n    gl_FragColor = vec4(uColor * (1.0 / 255.0), 1.0 - smoothstep(0.75, 1.0, length(vCoord)));\n    gl_FragColor.r = pow(gl_FragColor.r, uGamma);\n    gl_FragColor.g = pow(gl_FragColor.g, uGamma);\n    gl_FragColor.b = pow(gl_FragColor.b, uGamma);\n}\n");
	this.uOrigin = this.gl.getUniformLocation(this.program,"uOrigin");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uScale = this.gl.getUniformLocation(this.program,"uScale");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.uColor = this.gl.getUniformLocation(this.program,"uColor");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
};
quake_PParticle.__name__ = true;
quake_PParticle.__super__ = quake_GLProgram;
quake_PParticle.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PAlias = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec3 uOrigin;\nuniform mat3 uAngles;\nuniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nuniform vec3 uLightVec;\nattribute vec3 aPoint;\nattribute vec3 aLightNormal;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvarying float vLightDot;\nvoid main(void)\n{\n    vec3 position = uViewAngles * (uAngles * aPoint.xyz + uOrigin - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vTexCoord = aTexCoord;\n    vLightDot = dot(aLightNormal, uLightVec);\n}\n","precision mediump float;\nuniform float uGamma;\nuniform float uAmbientLight;\nuniform float uShadeLight;\nuniform sampler2D tTexture;\nvarying vec2 vTexCoord;\nvarying float vLightDot;\nvoid main(void)\n{\n    vec4 texture = texture2D(tTexture, vTexCoord);\n    gl_FragColor = vec4(texture.rgb * mix(1.0, vLightDot * uShadeLight + uAmbientLight, texture.a), 1.0);\n    gl_FragColor.r = pow(gl_FragColor.r, uGamma);\n    gl_FragColor.g = pow(gl_FragColor.g, uGamma);\n    gl_FragColor.b = pow(gl_FragColor.b, uGamma);\n}\n");
	this.uOrigin = this.gl.getUniformLocation(this.program,"uOrigin");
	this.uAngles = this.gl.getUniformLocation(this.program,"uAngles");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uLightVec = this.gl.getUniformLocation(this.program,"uLightVec");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.uAmbientLight = this.gl.getUniformLocation(this.program,"uAmbientLight");
	this.uShadeLight = this.gl.getUniformLocation(this.program,"uShadeLight");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.aLightNormal = this.gl.getAttribLocation(this.program,"aLightNormal");
	this.aTexCoord = this.gl.getAttribLocation(this.program,"aTexCoord");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
};
quake_PAlias.__name__ = true;
quake_PAlias.__super__ = quake_GLProgram;
quake_PAlias.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
		this.gl.enableVertexAttribArray(this.aLightNormal);
		this.gl.enableVertexAttribArray(this.aTexCoord);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
		this.gl.disableVertexAttribArray(this.aLightNormal);
		this.gl.disableVertexAttribArray(this.aTexCoord);
	}
});
var quake_PBrush = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec3 uOrigin;\nuniform mat3 uAngles;\nuniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nattribute vec3 aPoint;\nattribute vec4 aTexCoord;\nattribute vec4 aLightStyle;\nvarying vec4 vTexCoord;\nvarying vec4 vLightStyle;\nvoid main(void)\n{\n    vec3 position = uViewAngles * (uAngles * aPoint + uOrigin - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vTexCoord = aTexCoord;\n    vLightStyle = aLightStyle;\n}\n","precision mediump float;\nuniform float uGamma;\nuniform sampler2D tTexture;\nuniform sampler2D tLightmap;\nuniform sampler2D tDlight;\nuniform sampler2D tLightStyle;\nvarying vec4 vTexCoord;\nvarying vec4 vLightStyle;\nvoid main(void)\n{\n    vec4 texture = texture2D(tTexture, vTexCoord.xy);\n    gl_FragColor = vec4(texture.rgb *\n        mix(1.0, dot(texture2D(tLightmap, vTexCoord.zw), vec4(\n            texture2D(tLightStyle, vec2(vLightStyle.x, 0.0)).a,\n            texture2D(tLightStyle, vec2(vLightStyle.y, 0.0)).a,\n            texture2D(tLightStyle, vec2(vLightStyle.z, 0.0)).a,\n            texture2D(tLightStyle, vec2(vLightStyle.w, 0.0)).a)\n        * 43.828125) + texture2D(tDlight, vTexCoord.zw).a, texture.a), 1.0);\n    gl_FragColor.r = pow(gl_FragColor.r, uGamma);\n    gl_FragColor.g = pow(gl_FragColor.g, uGamma);\n    gl_FragColor.b = pow(gl_FragColor.b, uGamma);\n}");
	this.uOrigin = this.gl.getUniformLocation(this.program,"uOrigin");
	this.uAngles = this.gl.getUniformLocation(this.program,"uAngles");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.aTexCoord = this.gl.getAttribLocation(this.program,"aTexCoord");
	this.aLightStyle = this.gl.getAttribLocation(this.program,"aLightStyle");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
	this.tLightmap = 1;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tLightmap"),1);
	this.tDlight = 2;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tDlight"),2);
	this.tLightStyle = 3;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tLightStyle"),3);
};
quake_PBrush.__name__ = true;
quake_PBrush.__super__ = quake_GLProgram;
quake_PBrush.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
		this.gl.enableVertexAttribArray(this.aTexCoord);
		this.gl.enableVertexAttribArray(this.aLightStyle);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
		this.gl.disableVertexAttribArray(this.aTexCoord);
		this.gl.disableVertexAttribArray(this.aLightStyle);
	}
});
var quake_PDlight = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec3 uOrigin;\nuniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nuniform float uRadius;\nattribute vec3 aPoint;\nvarying float vAlpha;\nvoid main(void)\n{\n    vec3 position = aPoint * 0.35 * uRadius + uViewAngles * (uOrigin - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vAlpha = aPoint.y * -0.2;\n}\n","precision mediump float;\nuniform float uGamma;\nvarying float vAlpha;\nvoid main(void)\n{\n    gl_FragColor = vec4(pow(1.0, uGamma), pow(0.5, uGamma), 0.0, vAlpha);\n}\n");
	this.uOrigin = this.gl.getUniformLocation(this.program,"uOrigin");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uRadius = this.gl.getUniformLocation(this.program,"uRadius");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
};
quake_PDlight.__name__ = true;
quake_PDlight.__super__ = quake_GLProgram;
quake_PDlight.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PPlayer = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec3 uOrigin;\nuniform mat3 uAngles;\nuniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nuniform vec3 uLightVec;\nattribute vec3 aPoint;\nattribute vec3 aLightNormal;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvarying float vLightDot;\nvoid main(void)\n{\n    vec3 position = uViewAngles * (uAngles * aPoint.xyz + uOrigin - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vTexCoord = aTexCoord;\n    vLightDot = dot(aLightNormal, uLightVec);\n}\n","precision mediump float;\nuniform float uGamma;\nuniform float uAmbientLight;\nuniform float uShadeLight;\nuniform vec3 uTop;\nuniform vec3 uBottom;\nuniform sampler2D tTexture;\nuniform sampler2D tPlayer;\nvarying vec2 vTexCoord;\nvarying float vLightDot;\nvoid main(void)\n{\n    vec4 texture = texture2D(tTexture, vTexCoord);\n    vec4 player = texture2D(tPlayer, vTexCoord);\n    gl_FragColor = vec4(\n        mix(mix(texture.rgb, uTop * (1.0 / 191.25) * player.x, player.y), uBottom * (1.0 / 191.25) * player.z, player.w)\n        * mix(1.0, vLightDot * uShadeLight + uAmbientLight, texture.a), 1.0);\n    gl_FragColor.r = pow(gl_FragColor.r, uGamma);\n    gl_FragColor.g = pow(gl_FragColor.g, uGamma);\n    gl_FragColor.b = pow(gl_FragColor.b, uGamma);\n}\n");
	this.uOrigin = this.gl.getUniformLocation(this.program,"uOrigin");
	this.uAngles = this.gl.getUniformLocation(this.program,"uAngles");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uLightVec = this.gl.getUniformLocation(this.program,"uLightVec");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.uAmbientLight = this.gl.getUniformLocation(this.program,"uAmbientLight");
	this.uShadeLight = this.gl.getUniformLocation(this.program,"uShadeLight");
	this.uTop = this.gl.getUniformLocation(this.program,"uTop");
	this.uBottom = this.gl.getUniformLocation(this.program,"uBottom");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.aLightNormal = this.gl.getAttribLocation(this.program,"aLightNormal");
	this.aTexCoord = this.gl.getAttribLocation(this.program,"aTexCoord");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
	this.tPlayer = 1;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tPlayer"),1);
};
quake_PPlayer.__name__ = true;
quake_PPlayer.__super__ = quake_GLProgram;
quake_PPlayer.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
		this.gl.enableVertexAttribArray(this.aLightNormal);
		this.gl.enableVertexAttribArray(this.aTexCoord);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
		this.gl.disableVertexAttribArray(this.aLightNormal);
		this.gl.disableVertexAttribArray(this.aTexCoord);
	}
});
var quake_PSprite = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec4 uRect;\nuniform vec3 uOrigin;\nuniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nattribute vec2 aPoint;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    vec2 point = uRect.xy + uRect.zw * aPoint;\n    vec3 position = vec3(point.x, 0.0, point.y) + uViewAngles * (uOrigin - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vTexCoord = vec2(aPoint.x, -aPoint.y);\n}\n","precision mediump float;\nuniform float uGamma;\nuniform sampler2D tTexture;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_FragColor = texture2D(tTexture, vTexCoord);\n    gl_FragColor.r = pow(gl_FragColor.r, uGamma);\n    gl_FragColor.g = pow(gl_FragColor.g, uGamma);\n    gl_FragColor.b = pow(gl_FragColor.b, uGamma);\n}\n");
	this.uRect = this.gl.getUniformLocation(this.program,"uRect");
	this.uOrigin = this.gl.getUniformLocation(this.program,"uOrigin");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
};
quake_PSprite.__name__ = true;
quake_PSprite.__super__ = quake_GLProgram;
quake_PSprite.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PSpriteOriented = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec4 uRect;\nuniform vec3 uOrigin;\nuniform mat3 uAngles;\nuniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nattribute vec2 aPoint;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    vec2 point = uRect.xy + uRect.zw * aPoint;\n    vec3 position = uViewAngles * (uAngles * vec3(point.x, 0.0, point.y) + uOrigin - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vTexCoord = vec2(aPoint.x, -aPoint.y);\n}\n","precision mediump float;\nuniform float uGamma;\nuniform sampler2D tTexture;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_FragColor = texture2D(tTexture, vTexCoord);\n    gl_FragColor.r = pow(gl_FragColor.r, uGamma);\n    gl_FragColor.g = pow(gl_FragColor.g, uGamma);\n    gl_FragColor.b = pow(gl_FragColor.b, uGamma);\n}\n");
	this.uRect = this.gl.getUniformLocation(this.program,"uRect");
	this.uOrigin = this.gl.getUniformLocation(this.program,"uOrigin");
	this.uAngles = this.gl.getUniformLocation(this.program,"uAngles");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
};
quake_PSpriteOriented.__name__ = true;
quake_PSpriteOriented.__super__ = quake_GLProgram;
quake_PSpriteOriented.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PTurbulent = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec3 uOrigin;\nuniform mat3 uAngles;\nuniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nattribute vec3 aPoint;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    vec3 position = uViewAngles * (uAngles * aPoint + uOrigin - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vTexCoord = aTexCoord;\n}\n","precision mediump float;\nuniform float uGamma;\nuniform float uTime;\nuniform sampler2D tTexture;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_FragColor = vec4(texture2D(tTexture, vTexCoord + vec2(sin(vTexCoord.t * 3.141593 + uTime), sin(vTexCoord.s * 3.141593 + uTime)) * 0.125).rgb, 1.0);\n    gl_FragColor.r = pow(gl_FragColor.r, uGamma);\n    gl_FragColor.g = pow(gl_FragColor.g, uGamma);\n    gl_FragColor.b = pow(gl_FragColor.b, uGamma);\n}\n");
	this.uOrigin = this.gl.getUniformLocation(this.program,"uOrigin");
	this.uAngles = this.gl.getUniformLocation(this.program,"uAngles");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.uTime = this.gl.getUniformLocation(this.program,"uTime");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.aTexCoord = this.gl.getAttribLocation(this.program,"aTexCoord");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
};
quake_PTurbulent.__name__ = true;
quake_PTurbulent.__super__ = quake_GLProgram;
quake_PTurbulent.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
		this.gl.enableVertexAttribArray(this.aTexCoord);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
		this.gl.disableVertexAttribArray(this.aTexCoord);
	}
});
var quake_PWarp = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec4 uRect;\nuniform mat4 uOrtho;\nattribute vec2 aPoint;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_Position = uOrtho * vec4(uRect.x + uRect.z * aPoint.x, uRect.y + uRect.w * aPoint.y, 0.0, 1.0);\n    vTexCoord = vec2(aPoint.x, 1.0 - aPoint.y);\n}\n","precision mediump float;\nuniform float uTime;\nuniform sampler2D tTexture;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    gl_FragColor = texture2D(tTexture, vTexCoord + vec2(sin(vTexCoord.t * 15.70796 + uTime) * 0.003125, sin(vTexCoord.s * 9.817477 + uTime) * 0.005));\n}\n");
	this.uRect = this.gl.getUniformLocation(this.program,"uRect");
	this.uOrtho = this.gl.getUniformLocation(this.program,"uOrtho");
	this.uTime = this.gl.getUniformLocation(this.program,"uTime");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.tTexture = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tTexture"),0);
};
quake_PWarp.__name__ = true;
quake_PWarp.__super__ = quake_GLProgram;
quake_PWarp.prototype = $extend(quake_GLProgram.prototype,{
	setOrtho: function(ortho) {
		this.gl.uniformMatrix4fv(this.uOrtho,false,ortho);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PSky = function(gl) {
	quake_GLProgram.call(this,gl,"uniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nuniform vec3 uScale;\nattribute vec3 aPoint;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    vec3 position = uViewAngles * (aPoint * uScale * 18918.0);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n    vTexCoord = aPoint.xy * uScale.xy * 1.5;\n}\n","precision mediump float;\nuniform float uGamma;\nuniform vec2 uTime;\nuniform sampler2D tSolid;\nuniform sampler2D tAlpha;\nvarying vec2 vTexCoord;\nvoid main(void)\n{\n    vec4 alpha = texture2D(tAlpha, vTexCoord + uTime.x);\n    gl_FragColor = vec4(mix(texture2D(tSolid, vTexCoord + uTime.y).rgb, alpha.rgb, alpha.a), 1.0);\n    gl_FragColor.r = pow(gl_FragColor.r, uGamma);\n    gl_FragColor.g = pow(gl_FragColor.g, uGamma);\n    gl_FragColor.b = pow(gl_FragColor.b, uGamma);\n}\n");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.uScale = this.gl.getUniformLocation(this.program,"uScale");
	this.uGamma = this.gl.getUniformLocation(this.program,"uGamma");
	this.uTime = this.gl.getUniformLocation(this.program,"uTime");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
	this.tSolid = 0;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tSolid"),0);
	this.tAlpha = 1;
	this.gl.uniform1i(this.gl.getUniformLocation(this.program,"tAlpha"),1);
};
quake_PSky.__name__ = true;
quake_PSky.__super__ = quake_GLProgram;
quake_PSky.prototype = $extend(quake_GLProgram.prototype,{
	setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,setGamma: function(gamma) {
		this.gl.uniform1f(this.uGamma,gamma);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_PSkyChain = function(gl) {
	quake_GLProgram.call(this,gl,"uniform vec3 uViewOrigin;\nuniform mat3 uViewAngles;\nuniform mat4 uPerspective;\nattribute vec3 aPoint;\nvoid main(void)\n{\n    vec3 position = uViewAngles * (aPoint - uViewOrigin);\n    gl_Position = uPerspective * vec4(position.xz, -position.y, 1.0);\n}\n","precision mediump float;\nvoid main(void)\n{\n}\n");
	this.uViewOrigin = this.gl.getUniformLocation(this.program,"uViewOrigin");
	this.uViewAngles = this.gl.getUniformLocation(this.program,"uViewAngles");
	this.uPerspective = this.gl.getUniformLocation(this.program,"uPerspective");
	this.aPoint = this.gl.getAttribLocation(this.program,"aPoint");
};
quake_PSkyChain.__name__ = true;
quake_PSkyChain.__super__ = quake_GLProgram;
quake_PSkyChain.prototype = $extend(quake_GLProgram.prototype,{
	setViewOrigin: function(v) {
		this.gl.uniform3fv(this.uViewOrigin,v);
	}
	,setViewAngles: function(v) {
		this.gl.uniformMatrix3fv(this.uViewAngles,false,v);
	}
	,setPerspective: function(v) {
		this.gl.uniformMatrix4fv(this.uPerspective,false,v);
	}
	,bind: function() {
		this.gl.enableVertexAttribArray(this.aPoint);
	}
	,unbind: function() {
		this.gl.disableVertexAttribArray(this.aPoint);
	}
});
var quake_GLPrograms = function() { };
quake_GLPrograms.__name__ = true;
quake_GLPrograms.init = function(gl) {
	var p = new quake_PCharacter(gl);
	quake_GL.programs.push(p);
	quake_GLPrograms.character = p;
	var p1 = new quake_PFill(gl);
	quake_GL.programs.push(p1);
	quake_GLPrograms.fill = p1;
	var p2 = new quake_PPic(gl);
	quake_GL.programs.push(p2);
	quake_GLPrograms.pic = p2;
	var p3 = new quake_PPicTranslate(gl);
	quake_GL.programs.push(p3);
	quake_GLPrograms.picTranslate = p3;
	var p4 = new quake_PParticle(gl);
	quake_GL.programs.push(p4);
	quake_GLPrograms.particle = p4;
	var p5 = new quake_PAlias(gl);
	quake_GL.programs.push(p5);
	quake_GLPrograms.alias = p5;
	var p6 = new quake_PBrush(gl);
	quake_GL.programs.push(p6);
	quake_GLPrograms.brush = p6;
	var p7 = new quake_PDlight(gl);
	quake_GL.programs.push(p7);
	quake_GLPrograms.dlight = p7;
	var p8 = new quake_PPlayer(gl);
	quake_GL.programs.push(p8);
	quake_GLPrograms.player = p8;
	var p9 = new quake_PSprite(gl);
	quake_GL.programs.push(p9);
	quake_GLPrograms.sprite = p9;
	var p10 = new quake_PSpriteOriented(gl);
	quake_GL.programs.push(p10);
	quake_GLPrograms.spriteOriented = p10;
	var p11 = new quake_PTurbulent(gl);
	quake_GL.programs.push(p11);
	quake_GLPrograms.turbulent = p11;
	var p12 = new quake_PWarp(gl);
	quake_GL.programs.push(p12);
	quake_GLPrograms.warp = p12;
	var p13 = new quake_PSky(gl);
	quake_GL.programs.push(p13);
	quake_GLPrograms.sky = p13;
	var p14 = new quake_PSkyChain(gl);
	quake_GL.programs.push(p14);
	quake_GLPrograms.skyChain = p14;
};
var quake_GlobalVars = function(buf) {
	this.buffer = buf;
	this.floats = new Float32Array(buf);
	this.ints = new Int32Array(buf);
	this.v_forward = new Float32Array(this.buffer,236,3);
	this.v_up = new Float32Array(this.buffer,248,3);
	this.v_right = new Float32Array(this.buffer,260,3);
	this.trace_endpos = new Float32Array(this.buffer,284,3);
	this.trace_plane_normal = new Float32Array(this.buffer,296,3);
};
quake_GlobalVars.__name__ = true;
var quake_HClient = function() {
	this.num = 0;
	this.message = new quake_MSG(8000);
	this.message.allowoverflow = true;
	this.colors = 0;
	this.old_frags = 0;
};
quake_HClient.__name__ = true;
var quake_Host = function() { };
quake_Host.__name__ = true;
quake_Host.EndGame = function(message) {
	quake_Console.DPrint("Host.EndGame: " + message + "\n");
	if(quake_CL.cls.demonum != -1) {
		quake_CL.NextDemo();
	} else {
		quake_CL.Disconnect();
	}
	throw new js__$Boot_HaxeError("Host.abortserver");
};
quake_Host.Error = function(error) {
	if(quake_Host.inerror) {
		quake_Sys.Error("Host.Error: recursively entered");
	}
	quake_Host.inerror = true;
	quake_SCR.EndLoadingPlaque();
	quake_Console.Print("Host.Error: " + error + "\n");
	if(quake_SV.server.active) {
		quake_Host.ShutdownServer(false);
	}
	quake_CL.Disconnect();
	quake_CL.cls.demonum = -1;
	quake_Host.inerror = false;
	throw new Error("Host.abortserver");
};
quake_Host.FindMaxClients = function() {
	quake_SV.svs.maxclients = quake_SV.svs.maxclientslimit = 1;
	quake_CL.cls.state = 0;
	quake_SV.svs.clients = [new quake_HClient()];
	quake_Host.deathmatch.setValue(0);
};
quake_Host.InitLocal = function() {
	quake_Host.InitCommands();
	quake_Host.framerate = quake_Cvar.RegisterVariable("host_framerate","0");
	quake_Host.speeds = quake_Cvar.RegisterVariable("host_speeds","0");
	quake_Host.ticrate = quake_Cvar.RegisterVariable("sys_ticrate","0.05");
	quake_Host.serverprofile = quake_Cvar.RegisterVariable("serverprofile","0");
	quake_Host.fraglimit = quake_Cvar.RegisterVariable("fraglimit","0",false,true);
	quake_Host.timelimit = quake_Cvar.RegisterVariable("timelimit","0",false,true);
	quake_Host.teamplay = quake_Cvar.RegisterVariable("teamplay","0",false,true);
	quake_Host.samelevel = quake_Cvar.RegisterVariable("samelevel","0");
	quake_Host.noexit = quake_Cvar.RegisterVariable("noexit","0",false,true);
	quake_Host.skill = quake_Cvar.RegisterVariable("skill","1");
	quake_Host.developer = quake_Cvar.RegisterVariable("developer","0");
	quake_Host.deathmatch = quake_Cvar.RegisterVariable("deathmatch","0");
	quake_Host.coop = quake_Cvar.RegisterVariable("coop","0");
	quake_Host.pausable = quake_Cvar.RegisterVariable("pausable","1");
	quake_Host.temp1 = quake_Cvar.RegisterVariable("temp1","0");
	quake_Host.FindMaxClients();
};
quake_Host.ClientPrint = function(string) {
	quake_Host.client.message.WriteByte(8);
	quake_Host.client.message.WriteString(string);
};
quake_Host.BroadcastPrint = function(string) {
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var client = quake_SV.svs.clients[_g++];
		if(!client.active || !client.spawned) {
			continue;
		}
		client.message.WriteByte(8);
		client.message.WriteString(string);
	}
};
quake_Host.DropClient = function(crash) {
	var client = quake_Host.client;
	if(!crash) {
		if(quake_NET.CanSendMessage(client.netconnection)) {
			client.message.WriteByte(2);
			quake_NET.SendMessage(client.netconnection,client.message);
		}
		if(client.edict != null && client.spawned) {
			var saveSelf = quake_PR.globals.ints[28];
			quake_PR.globals.ints[28] = client.edict.num;
			quake_PR.ExecuteProgram(quake_PR.globals.ints[89]);
			quake_PR.globals.ints[28] = saveSelf;
		}
		console.log("src/quake/Sys.hx:45:","Client " + quake_PR.GetString(quake_PR.netnames + (client.num << 5)) + " removed\n");
	}
	quake_NET.Close(client.netconnection);
	client.netconnection = null;
	client.active = false;
	quake_SV.SetClientName(client,"");
	client.old_frags = -999999;
	--quake_NET.activeconnections;
	var num = client.num;
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var client1 = quake_SV.svs.clients[_g++];
		if(!client1.active) {
			continue;
		}
		client1.message.WriteByte(13);
		client1.message.WriteByte(num);
		client1.message.WriteByte(0);
		client1.message.WriteByte(14);
		client1.message.WriteByte(num);
		client1.message.WriteShort(0);
		client1.message.WriteByte(17);
		client1.message.WriteByte(num);
		client1.message.WriteByte(0);
	}
};
quake_Host.ShutdownServer = function(crash) {
	if(!quake_SV.server.active) {
		return;
	}
	quake_SV.server.active = false;
	if(quake_CL.cls.state == 2) {
		quake_CL.Disconnect();
	}
	var start = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	var count = 0;
	while(true) {
		var _g = 0;
		var _g1 = quake_SV.svs.maxclients;
		while(_g < _g1) {
			quake_Host.client = quake_SV.svs.clients[_g++];
			if(!quake_Host.client.active || quake_Host.client.message.cursize == 0) {
				continue;
			}
			if(quake_NET.CanSendMessage(quake_Host.client.netconnection)) {
				quake_NET.SendMessage(quake_Host.client.netconnection,quake_Host.client.message);
				quake_Host.client.message.cursize = 0;
				continue;
			}
			quake_NET.GetMessage(quake_Host.client.netconnection);
			++count;
		}
		if(new Date().getTime() * 0.001 - quake_Sys.oldtime - start > 3.0) {
			break;
		}
		if(!(count != 0)) {
			break;
		}
	}
	var buf = new quake_MSG(4,1);
	new Uint8Array(buf.data)[0] = 2;
	count = quake_NET.SendToAll(buf);
	if(count != 0) {
		quake_Console.Print("Host.ShutdownServer: NET.SendToAll failed for " + count + " clients\n");
	}
	var _g2 = 0;
	var _g11 = quake_SV.svs.maxclients;
	while(_g2 < _g11) {
		quake_Host.client = quake_SV.svs.clients[_g2++];
		if(quake_Host.client.active) {
			quake_Host.DropClient(crash);
		}
	}
};
quake_Host.ServerFrame = function() {
	quake_PR.globals.floats[32] = quake_Host.frametime;
	quake_SV.server.datagram.cursize = 0;
	quake_SV.CheckForNewClients();
	quake_SV.RunClients();
	if(!quake_SV.server.paused && (quake_SV.svs.maxclients >= 2 || quake_Key.dest == 0)) {
		quake_SV.Physics();
	}
	quake_SV.SendClientMessages();
};
quake_Host._Frame = function() {
	Math.random();
	quake_Host.realtime = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	quake_Host.frametime = quake_Host.realtime - quake_Host.oldrealtime;
	quake_Host.oldrealtime = quake_Host.realtime;
	if(quake_Host.framerate.value > 0) {
		quake_Host.frametime = quake_Host.framerate.value;
	} else if(quake_Host.frametime > 0.1) {
		quake_Host.frametime = 0.1;
	} else if(quake_Host.frametime < 0.001) {
		quake_Host.frametime = 0.001;
	}
	if(quake_CL.cls.state == 1) {
		quake_NET.CheckForResend();
		quake_SCR.UpdateScreen();
		return;
	}
	var time1 = null;
	var time2 = null;
	var pass1;
	var pass2;
	var pass3;
	var tot;
	quake_Cmd.Execute();
	quake_CL.SendCmd();
	if(quake_SV.server.active) {
		quake_Host.ServerFrame();
	}
	if(quake_CL.cls.state == 2) {
		quake_CL.ReadFromServer();
	}
	if(quake_Host.speeds.value != 0) {
		time1 = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	}
	quake_SCR.UpdateScreen();
	quake_CL.RunParticles();
	if(quake_Host.speeds.value != 0) {
		time2 = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	}
	if(quake_CL.cls.signon == 4) {
		quake_S.Update(quake_Render.refdef.vieworg,quake_Render.vpn,quake_Render.vright,quake_Render.vup);
		quake_CL.DecayLights();
	} else {
		quake_S.Update(quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin);
	}
	quake_CDAudio.Update();
	if(quake_Host.speeds.value != 0) {
		pass1 = (time1 - quake_Host.time3) * 1000.0;
		quake_Host.time3 = new Date().getTime() * 0.001 - quake_Sys.oldtime;
		pass2 = (time2 - time1) * 1000.0;
		pass3 = (quake_Host.time3 - time2) * 1000.0;
		tot = Math.floor(pass1 + pass2 + pass3);
		quake_Console.Print((tot <= 99 ? tot <= 9 ? "  " : " " : "") + tot + " tot " + (pass1 < 100.0 ? pass1 < 10.0 ? "  " : " " : "") + Math.floor(pass1) + " server " + (pass2 < 100.0 ? pass2 < 10.0 ? "  " : " " : "") + Math.floor(pass2) + " gfx " + (pass3 < 100.0 ? pass3 < 10.0 ? "  " : " " : "") + Math.floor(pass3) + " snd\n");
	}
	if(quake_Host.startdemos) {
		quake_CL.NextDemo();
		quake_Host.startdemos = false;
	}
	++quake_Host.framecount;
};
quake_Host.Frame = function() {
	if(quake_Host.serverprofile.value == 0) {
		quake_Host._Frame();
		return;
	}
	var time1 = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	quake_Host._Frame();
	quake_Host.timetotal += new Date().getTime() * 0.001 - quake_Sys.oldtime - time1;
	if(++quake_Host.timecount <= 999) {
		return;
	}
	var m = quake_Host.timetotal * 1000.0 / quake_Host.timecount | 0;
	quake_Host.timecount = 0;
	quake_Host.timetotal = 0.0;
	var c = 0;
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) if(quake_SV.svs.clients[_g++].active) {
		++c;
	}
	quake_Console.Print("serverprofile: " + (c <= 9 ? " " : "") + c + " clients " + (m <= 9 ? " " : "") + m + " msec\n");
};
quake_Host.Init = function() {
	quake_Host.oldrealtime = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	quake_Cmd.Init();
	quake_V.Init();
	quake_Chase.Init();
	quake_COM.Init();
	quake_Host.InitLocal();
	quake_W.LoadWadFile("gfx.wad");
	quake_Key.Init();
	quake_Console.Init();
	quake_PR.Init();
	quake_Mod.Init();
	quake_NET.Init();
	quake_SV.Init();
	quake_Console.Print("Exe: 12:39:20 Aug  7 2014\n");
	quake_VID.Init();
	quake_Draw.Init();
	quake_SCR.Init();
	quake_Render.Init();
	quake_S.Init();
	quake_Menu.Init();
	quake_CDAudio.Init();
	quake_Sbar.Init();
	quake_CL.Init();
	quake_IN.Init();
	quake_Cmd.text = "exec quake.rc\n" + quake_Cmd.text;
	quake_Host.initialized = true;
	console.log("src/quake/Sys.hx:45:","======Quake Initialized======\n");
};
quake_Host.Shutdown = function() {
	if(quake_Host.isdown) {
		console.log("src/quake/Sys.hx:45:","recursive shutdown\n");
		return;
	}
	quake_Host.isdown = true;
	quake_COM.WriteTextFile("config.cfg",quake_Key.WriteBindings() + quake_Cvar.WriteVariables());
	quake_CDAudio.Stop();
	quake_NET.Shutdown();
	quake_S.StopAllSounds();
	quake_IN.Shutdown();
};
quake_Host.Quit_f = function() {
	if(quake_Key.dest != 1) {
		quake_Menu.Menu_Quit_f();
		return;
	}
	quake_Sys.Quit();
};
quake_Host.Status_f = function() {
	var print;
	if(!quake_Cmd.client) {
		if(!quake_SV.server.active) {
			quake_Cmd.ForwardToServer();
			return;
		}
		print = quake_Console.Print;
	} else {
		print = quake_Host.ClientPrint;
	}
	print("host:    " + quake_NET.hostname.string + "\n");
	print("version: 1.09\n");
	print("map:     " + quake_PR.GetString(quake_PR.globals.ints[34]) + "\n");
	print("players: " + quake_NET.activeconnections + " active (" + quake_SV.svs.maxclients + " max)\n\n");
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var i = _g++;
		var client = quake_SV.svs.clients[i];
		if(!client.active) {
			continue;
		}
		var frags = client.edict.v.floats[49].toFixed(0);
		if(frags.length == 1) {
			frags = "  " + frags;
		} else if(frags.length == 2) {
			frags = " " + frags;
		}
		var seconds = quake_NET.time - client.netconnection.connecttime | 0;
		var minutes = seconds / 60 | 0;
		var hours;
		if(minutes != 0) {
			seconds -= minutes * 60;
			hours = minutes / 60 | 0;
			if(hours != 0) {
				minutes -= hours * 60;
			}
		} else {
			hours = 0;
		}
		var str = "#" + (i + 1) + " ";
		if(i <= 8) {
			str += " ";
		}
		str += quake_PR.GetString(quake_PR.netnames + (client.num << 5));
		while(str.length <= 21) str += " ";
		str += frags + "  ";
		if(hours <= 9) {
			str += " ";
		}
		str += hours + ":";
		if(minutes <= 9) {
			str += "0";
		}
		str += minutes + ":";
		if(seconds <= 9) {
			str += "0";
		}
		print(str + seconds + "\n");
		print("   " + client.netconnection.address + "\n");
	}
};
quake_Host.God_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_PR.globals.floats[35] != 0) {
		return;
	}
	quake_SV.player.v.floats[76] = (quake_SV.player.v.floats[76] | 0) ^ 64;
	if(((quake_SV.player.v.floats[76] | 0) & 64) == 0) {
		quake_Host.ClientPrint("godmode OFF\n");
	} else {
		quake_Host.ClientPrint("godmode ON\n");
	}
};
quake_Host.Notarget_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_PR.globals.floats[35] != 0) {
		return;
	}
	quake_SV.player.v.floats[76] = (quake_SV.player.v.floats[76] | 0) ^ 128;
	if(((quake_SV.player.v.floats[76] | 0) & 128) == 0) {
		quake_Host.ClientPrint("notarget OFF\n");
	} else {
		quake_Host.ClientPrint("notarget ON\n");
	}
};
quake_Host.Noclip_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_PR.globals.floats[35] != 0) {
		return;
	}
	if(quake_SV.player.v.floats[8] != 8) {
		quake_Host.noclip_anglehack = true;
		quake_SV.player.v.floats[8] = 8;
		quake_Host.ClientPrint("noclip ON\n");
		return;
	}
	quake_Host.noclip_anglehack = false;
	quake_SV.player.v.floats[8] = 3;
	quake_Host.ClientPrint("noclip OFF\n");
};
quake_Host.Fly_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_PR.globals.floats[35] != 0) {
		return;
	}
	if(quake_SV.player.v.floats[8] != 5) {
		quake_SV.player.v.floats[8] = 5;
		quake_Host.ClientPrint("flymode ON\n");
		return;
	}
	quake_SV.player.v.floats[8] = 3;
	quake_Host.ClientPrint("flymode OFF\n");
};
quake_Host.Ping_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	quake_Host.ClientPrint("Client ping times:\n");
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var client = quake_SV.svs.clients[_g++];
		if(!client.active) {
			continue;
		}
		var total = 0.0;
		total = client.ping_times[0];
		total += client.ping_times[1];
		total += client.ping_times[2];
		total += client.ping_times[3];
		total += client.ping_times[4];
		total += client.ping_times[5];
		total += client.ping_times[6];
		total += client.ping_times[7];
		total += client.ping_times[8];
		total += client.ping_times[9];
		total += client.ping_times[10];
		total += client.ping_times[11];
		total += client.ping_times[12];
		total += client.ping_times[13];
		total += client.ping_times[14];
		total += client.ping_times[15];
		var total1 = (total * 62.5).toFixed(0);
		if(total1.length == 1) {
			total1 = "   " + total1;
		} else if(total1.length == 2) {
			total1 = "  " + total1;
		} else if(total1.length == 3) {
			total1 = " " + total1;
		}
		quake_Host.ClientPrint(total1 + " " + quake_PR.GetString(quake_PR.netnames + (client.num << 5)) + "\n");
	}
};
quake_Host.Map_f = function() {
	if(quake_Cmd.argv.length <= 1) {
		quake_Console.Print("USAGE: map <map>\n");
		return;
	}
	if(quake_Cmd.client) {
		return;
	}
	quake_CL.cls.demonum = -1;
	quake_CL.Disconnect();
	quake_Host.ShutdownServer(false);
	quake_Key.dest = 0;
	quake_SCR.BeginLoadingPlaque();
	quake_SV.svs.serverflags = 0;
	quake_SV.SpawnServer(quake_Cmd.argv[1]);
	if(!quake_SV.server.active) {
		return;
	}
	quake_CL.cls.spawnparms = "";
	var _g = 2;
	var _g1 = quake_Cmd.argv.length;
	while(_g < _g1) quake_CL.cls.spawnparms += quake_Cmd.argv[_g++] + " ";
	quake_Cmd.ExecuteString("connect local");
};
quake_Host.Changelevel_f = function() {
	if(quake_Cmd.argv.length != 2) {
		quake_Console.Print("changelevel <levelname> : continue game on a new level\n");
		return;
	}
	if(!quake_SV.server.active || quake_CL.cls.demoplayback) {
		quake_Console.Print("Only the server may changelevel\n");
		return;
	}
	quake_SV.SaveSpawnparms();
	quake_SV.SpawnServer(quake_Cmd.argv[1]);
};
quake_Host.Restart_f = function() {
	if(!quake_CL.cls.demoplayback && quake_SV.server.active && !quake_Cmd.client) {
		quake_SV.SpawnServer(quake_PR.GetString(quake_PR.globals.ints[34]));
	}
};
quake_Host.Reconnect_f = function() {
	quake_SCR.BeginLoadingPlaque();
	quake_CL.cls.signon = 0;
};
quake_Host.Connect_f = function() {
	quake_CL.cls.demonum = -1;
	if(quake_CL.cls.demoplayback) {
		quake_CL.StopPlayback();
		quake_CL.Disconnect();
	}
	quake_CL.EstablishConnection(quake_Cmd.argv[1]);
	quake_CL.cls.signon = 0;
};
quake_Host.SavegameComment = function() {
	var _this_r = new RegExp("\\s","gm".split("u").join(""));
	var text = quake_CL.state.levelname.replace(_this_r,"_");
	var _g = quake_CL.state.levelname.length;
	while(_g < 22) {
		++_g;
		text += "_";
	}
	text += "kills:";
	var kills = Std.string(quake_CL.state.stats[14]);
	if(kills.length == 2) {
		text += "_";
	} else if(kills.length == 1) {
		text += "__";
	}
	text += kills + "/";
	kills = Std.string(quake_CL.state.stats[12]);
	if(kills.length == 2) {
		text += "_";
	} else if(kills.length == 1) {
		text += "__";
	}
	text += kills;
	return text + "____";
};
quake_Host.Savegame_f = function() {
	if(quake_Cmd.client) {
		return;
	}
	if(!quake_SV.server.active) {
		quake_Console.Print("Not playing a local game.\n");
		return;
	}
	if(quake_CL.state.intermission != 0) {
		quake_Console.Print("Can't save in intermission.\n");
		return;
	}
	if(quake_SV.svs.maxclients != 1) {
		quake_Console.Print("Can't save multiplayer games.\n");
		return;
	}
	if(quake_Cmd.argv.length != 2) {
		quake_Console.Print("save <savename> : save a game\n");
		return;
	}
	if(quake_Cmd.argv[1].indexOf("..") != -1) {
		quake_Console.Print("Relative pathnames are not allowed.\n");
		return;
	}
	var client = quake_SV.svs.clients[0];
	if(client.active) {
		if(client.edict.v.floats[48] <= 0.0) {
			quake_Console.Print("Can't savegame with a dead player\n");
			return;
		}
	}
	var f = ["5\n" + quake_Host.SavegameComment() + "\n"];
	f.push(client.spawn_parms[0].toFixed(6) + "\n");
	f.push(client.spawn_parms[1].toFixed(6) + "\n");
	f.push(client.spawn_parms[2].toFixed(6) + "\n");
	f.push(client.spawn_parms[3].toFixed(6) + "\n");
	f.push(client.spawn_parms[4].toFixed(6) + "\n");
	f.push(client.spawn_parms[5].toFixed(6) + "\n");
	f.push(client.spawn_parms[6].toFixed(6) + "\n");
	f.push(client.spawn_parms[7].toFixed(6) + "\n");
	f.push(client.spawn_parms[8].toFixed(6) + "\n");
	f.push(client.spawn_parms[9].toFixed(6) + "\n");
	f.push(client.spawn_parms[10].toFixed(6) + "\n");
	f.push(client.spawn_parms[11].toFixed(6) + "\n");
	f.push(client.spawn_parms[12].toFixed(6) + "\n");
	f.push(client.spawn_parms[13].toFixed(6) + "\n");
	f.push(client.spawn_parms[14].toFixed(6) + "\n");
	f.push(client.spawn_parms[15].toFixed(6) + "\n");
	f.push(quake_Host.current_skill + "\n" + quake_PR.GetString(quake_PR.globals.ints[34]) + "\n" + quake_SV.server.time.toFixed(6) + "\n");
	var _g = 0;
	var _g1 = quake_SV.server.lightstyles;
	while(_g < _g1.length) {
		var ls = _g1[_g];
		++_g;
		if(ls.length != 0) {
			f.push(ls + "\n");
		} else {
			f.push("m\n");
		}
	}
	f.push("{\n");
	var _g2 = 0;
	var _g3 = quake_PR.globaldefs;
	while(_g2 < _g3.length) {
		var def = _g3[_g2];
		++_g2;
		var type = def.type;
		if((type & 32768) == 0) {
			continue;
		}
		var type1 = type & 32767;
		if(type1 != 1 && type1 != 2 && type1 != 4) {
			continue;
		}
		f.push("\"" + quake_PR.GetString(def.name) + "\" \"" + quake_PR.UglyValueString(type1,quake_PR.globals.buffer,def.ofs) + "\"\n");
	}
	f.push("}\n");
	var _g4 = 0;
	var _g5 = quake_SV.server.num_edicts;
	while(_g4 < _g5) {
		var ed = quake_SV.server.edicts[_g4++];
		if(ed.free) {
			f.push("{\n}\n");
			continue;
		}
		f.push("{\n");
		var _g41 = 0;
		var _g51 = quake_PR.fielddefs;
		while(_g41 < _g51.length) {
			var def1 = _g51[_g41];
			++_g41;
			var name = quake_PR.GetString(def1.name);
			if(HxOverrides.cca(name,name.length - 2) == 95) {
				continue;
			}
			var type2 = def1.type & 32767;
			var v = def1.ofs;
			if(ed.v.ints[v] == 0) {
				if(type2 == 3) {
					if(ed.v.ints[v + 1] == 0 && ed.v.ints[v + 2] == 0) {
						continue;
					}
				} else {
					continue;
				}
			}
			f.push("\"" + name + "\" \"" + quake_PR.UglyValueString(type2,ed.v.buffer,def1.ofs) + "\"\n");
		}
		f.push("}\n");
	}
	var name1 = quake_COM.DefaultExtension(quake_Cmd.argv[1],".sav");
	quake_Console.Print("Saving game to " + name1 + "...\n");
	if(quake_COM.WriteTextFile(name1,f.join(""))) {
		quake_Console.Print("done.\n");
	} else {
		quake_Console.Print("ERROR: couldn't open.\n");
	}
};
quake_Host.Loadgame_f = function() {
	if(quake_Cmd.client) {
		return;
	}
	if(quake_Cmd.argv.length != 2) {
		quake_Console.Print("load <savename> : load a game\n");
		return;
	}
	quake_CL.cls.demonum = -1;
	var name = quake_COM.DefaultExtension(quake_Cmd.argv[1],".sav");
	quake_Console.Print("Loading game from " + name + "...\n");
	var f = quake_COM.LoadTextFile(name);
	if(f == null) {
		quake_Console.Print("ERROR: couldn't open.\n");
		return;
	}
	var f1 = f.split("\n");
	var tfloat = parseFloat(f1[0]);
	if(tfloat != 5) {
		quake_Console.Print("Savegame is version " + tfloat + ", not 5\n");
		return;
	}
	var spawn_parms = [];
	spawn_parms[0] = parseFloat(f1[2]);
	spawn_parms[1] = parseFloat(f1[3]);
	spawn_parms[2] = parseFloat(f1[4]);
	spawn_parms[3] = parseFloat(f1[5]);
	spawn_parms[4] = parseFloat(f1[6]);
	spawn_parms[5] = parseFloat(f1[7]);
	spawn_parms[6] = parseFloat(f1[8]);
	spawn_parms[7] = parseFloat(f1[9]);
	spawn_parms[8] = parseFloat(f1[10]);
	spawn_parms[9] = parseFloat(f1[11]);
	spawn_parms[10] = parseFloat(f1[12]);
	spawn_parms[11] = parseFloat(f1[13]);
	spawn_parms[12] = parseFloat(f1[14]);
	spawn_parms[13] = parseFloat(f1[15]);
	spawn_parms[14] = parseFloat(f1[16]);
	spawn_parms[15] = parseFloat(f1[17]);
	quake_Host.current_skill = parseFloat(f1[18]) + 0.1 | 0;
	quake_Host.skill.setValue(quake_Host.current_skill);
	var time = parseFloat(f1[20]);
	quake_CL.Disconnect();
	quake_SV.SpawnServer(f1[19]);
	if(!quake_SV.server.active) {
		quake_Console.Print("Couldn't load map\n");
		return;
	}
	quake_SV.server.paused = true;
	quake_SV.server.loadgame = true;
	var _g = 0;
	while(_g < 64) {
		var i = _g++;
		quake_SV.server.lightstyles[i] = f1[21 + i];
	}
	if(f1[85] != "{") {
		quake_Sys.Error("First token isn't a brace");
	}
	var i1 = 86;
	while(i1 < f1.length) {
		if(f1[i1] == "}") {
			++i1;
			break;
		}
		var token = f1[i1].split("\"");
		var keyname = token[1];
		var key = quake_ED.FindGlobal(keyname);
		++i1;
		if(key == null) {
			quake_Console.Print("'" + keyname + "' is not a global\n");
			continue;
		}
		if(!quake_ED.ParseEpair(quake_PR.globals.buffer,key,token[3])) {
			quake_Host.Error("Host.Loadgame_f: parse error");
		}
	}
	f1.push("");
	var entnum = 0;
	var data = f1.slice(i1).join("\n");
	while(true) {
		data = quake_COM.Parse(data);
		if(data == null) {
			break;
		}
		if(HxOverrides.cca(quake_COM.token,0) != 123) {
			quake_Sys.Error("Host.Loadgame_f: found " + quake_COM.token + " when expecting {");
		}
		var ent = quake_SV.server.edicts[entnum++];
		var _g1 = 0;
		var _g2 = quake_PR.entityfields;
		while(_g1 < _g2) ent.v.ints[_g1++] = 0;
		ent.free = false;
		data = quake_ED.ParseEdict(data,ent);
		if(!ent.free) {
			quake_SV.LinkEdict(ent,false);
		}
	}
	quake_SV.server.num_edicts = entnum;
	quake_SV.server.time = time;
	var client = quake_SV.svs.clients[0];
	client.spawn_parms = [];
	client.spawn_parms[0] = spawn_parms[0];
	client.spawn_parms[1] = spawn_parms[1];
	client.spawn_parms[2] = spawn_parms[2];
	client.spawn_parms[3] = spawn_parms[3];
	client.spawn_parms[4] = spawn_parms[4];
	client.spawn_parms[5] = spawn_parms[5];
	client.spawn_parms[6] = spawn_parms[6];
	client.spawn_parms[7] = spawn_parms[7];
	client.spawn_parms[8] = spawn_parms[8];
	client.spawn_parms[9] = spawn_parms[9];
	client.spawn_parms[10] = spawn_parms[10];
	client.spawn_parms[11] = spawn_parms[11];
	client.spawn_parms[12] = spawn_parms[12];
	client.spawn_parms[13] = spawn_parms[13];
	client.spawn_parms[14] = spawn_parms[14];
	client.spawn_parms[15] = spawn_parms[15];
	quake_CL.EstablishConnection("local");
	quake_Host.Reconnect_f();
};
quake_Host.Name_f = function() {
	if(quake_Cmd.argv.length <= 1) {
		quake_Console.Print("\"name\" is \"" + quake_CL.$name.string + "\"\n");
		return;
	}
	var newName;
	if(quake_Cmd.argv.length == 2) {
		newName = quake_Cmd.argv[1].substring(0,15);
	} else {
		newName = quake_Cmd.args.substring(0,15);
	}
	if(!quake_Cmd.client) {
		quake_CL.$name.set(newName);
		if(quake_CL.cls.state == 2) {
			quake_Cmd.ForwardToServer();
		}
		return;
	}
	var name = quake_PR.GetString(quake_PR.netnames + (quake_Host.client.num << 5));
	if(name.length != 0 && name != "unconnected" && name != newName) {
		quake_Console.Print(name + " renamed to " + newName + "\n");
	}
	quake_SV.SetClientName(quake_Host.client,newName);
	var msg = quake_SV.server.reliable_datagram;
	msg.WriteByte(13);
	msg.WriteByte(quake_Host.client.num);
	msg.WriteString(newName);
};
quake_Host.Version_f = function() {
	quake_Console.Print("Version 1.09\n");
	quake_Console.Print("Exe: 12:39:20 Aug  7 2014\n");
};
quake_Host.Say = function(teamonly) {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_Cmd.argv.length <= 1) {
		return;
	}
	var save = quake_Host.client;
	var p = quake_Cmd.args;
	if(HxOverrides.cca(p,0) == 34) {
		p = p.substring(1,p.length - 1);
	}
	var text = "\x01" + quake_PR.GetString(quake_PR.netnames + (save.num << 5)) + ": ";
	var i = 62 - text.length;
	if(p.length > i) {
		p = p.substring(0,i);
	}
	text += p + "\n";
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var client = quake_SV.svs.clients[_g++];
		if(!client.active || !client.spawned) {
			continue;
		}
		if(quake_Host.teamplay.value != 0 && teamonly && client.edict.v.floats[78] != save.edict.v.floats[78]) {
			continue;
		}
		quake_Host.client = client;
		quake_Host.ClientPrint(text);
	}
	quake_Host.client = save;
	console.log("src/quake/Sys.hx:45:",text.substring(1));
};
quake_Host.Say_Team_f = function() {
	quake_Host.Say(true);
};
quake_Host.Tell_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_Cmd.argv.length <= 2) {
		return;
	}
	var text = quake_PR.GetString(quake_PR.netnames + (quake_Host.client.num << 5)) + ": ";
	var p = quake_Cmd.args;
	if(HxOverrides.cca(p,0) == 34) {
		p = p.substring(1,p.length - 1);
	}
	var i = 62 - text.length;
	if(p.length > i) {
		p = p.substring(0,i);
	}
	text += p + "\n";
	var save = quake_Host.client;
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var client = quake_SV.svs.clients[_g++];
		if(!client.active || !client.spawned) {
			continue;
		}
		if(quake_PR.GetString(quake_PR.netnames + (client.num << 5)).toLowerCase() != quake_Cmd.argv[1].toLowerCase()) {
			continue;
		}
		quake_Host.client = client;
		quake_Host.ClientPrint(text);
		break;
	}
	quake_Host.client = save;
};
quake_Host.Color_f = function() {
	if(quake_Cmd.argv.length <= 1) {
		var col = quake_CL.color.value | 0;
		quake_Console.Print("\"color\" is \"" + (col >> 4) + " " + (col & 15) + "\"\ncolor <0-13> [0-13]\n");
		return;
	}
	var top;
	var bottom;
	if(quake_Cmd.argv.length == 2) {
		bottom = (quake_Q.atoi(quake_Cmd.argv[1]) & 15) >>> 0;
		top = bottom;
	} else {
		top = (quake_Q.atoi(quake_Cmd.argv[1]) & 15) >>> 0;
		bottom = (quake_Q.atoi(quake_Cmd.argv[2]) & 15) >>> 0;
	}
	if(top >= 14) {
		top = 13;
	}
	if(bottom >= 14) {
		bottom = 13;
	}
	var playercolor = (top << 4) + bottom;
	if(!quake_Cmd.client) {
		quake_CL.color.setValue(playercolor);
		if(quake_CL.cls.state == 2) {
			quake_Cmd.ForwardToServer();
		}
		return;
	}
	quake_Host.client.colors = playercolor;
	quake_Host.client.edict.v.floats[78] = bottom + 1;
	var msg = quake_SV.server.reliable_datagram;
	msg.WriteByte(17);
	msg.WriteByte(quake_Host.client.num);
	msg.WriteByte(playercolor);
};
quake_Host.Kill_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_SV.player.v.floats[48] <= 0.0) {
		quake_Host.ClientPrint("Can't suicide -- already dead!\n");
		return;
	}
	quake_PR.globals.floats[31] = quake_SV.server.time;
	quake_PR.globals.ints[28] = quake_SV.player.num;
	quake_PR.ExecuteProgram(quake_PR.globals.ints[86]);
};
quake_Host.Pause_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_Host.pausable.value == 0) {
		quake_Host.ClientPrint("Pause not allowed.\n");
		return;
	}
	quake_SV.server.paused = !quake_SV.server.paused;
	quake_Host.BroadcastPrint(quake_PR.GetString(quake_PR.netnames + (quake_Host.client.num << 5)) + (quake_SV.server.paused ? " paused the game\n" : " unpaused the game\n"));
	quake_SV.server.reliable_datagram.WriteByte(24);
	quake_SV.server.reliable_datagram.WriteByte(quake_SV.server.paused ? 1 : 0);
};
quake_Host.PreSpawn_f = function() {
	if(!quake_Cmd.client) {
		quake_Console.Print("prespawn is not valid from the console\n");
		return;
	}
	var client = quake_Host.client;
	if(client.spawned) {
		quake_Console.Print("prespawn not valid -- already spawned\n");
		return;
	}
	client.message.Write(new Uint8Array(quake_SV.server.signon.data),quake_SV.server.signon.cursize);
	client.message.WriteByte(25);
	client.message.WriteByte(2);
	client.sendsignon = true;
};
quake_Host.Spawn_f = function() {
	if(!quake_Cmd.client) {
		quake_Console.Print("spawn is not valid from the console\n");
		return;
	}
	var client = quake_Host.client;
	if(client.spawned) {
		quake_Console.Print("Spawn not valid -- already spawned\n");
		return;
	}
	var ent = client.edict;
	if(quake_SV.server.loadgame) {
		quake_SV.server.paused = false;
	} else {
		var _g = 0;
		var _g1 = quake_PR.entityfields;
		while(_g < _g1) ent.v.ints[_g++] = 0;
		ent.v.floats[77] = ent.num;
		ent.v.floats[78] = (client.colors & 15) + 1;
		ent.v.ints[74] = quake_PR.netnames + (client.num << 5);
		var _this = quake_PR.globals;
		var values = client.spawn_parms;
		_this.floats[43] = values[0];
		_this.floats[44] = values[1];
		_this.floats[45] = values[2];
		_this.floats[46] = values[3];
		_this.floats[47] = values[4];
		_this.floats[48] = values[5];
		_this.floats[49] = values[6];
		_this.floats[50] = values[7];
		_this.floats[51] = values[8];
		_this.floats[52] = values[9];
		_this.floats[53] = values[10];
		_this.floats[54] = values[11];
		_this.floats[55] = values[12];
		_this.floats[56] = values[13];
		_this.floats[57] = values[14];
		_this.floats[58] = values[15];
		quake_PR.globals.floats[31] = quake_SV.server.time;
		quake_PR.globals.ints[28] = ent.num;
		quake_PR.ExecuteProgram(quake_PR.globals.ints[87]);
		if(new Date().getTime() * 0.001 - quake_Sys.oldtime - client.netconnection.connecttime <= quake_SV.server.time) {
			console.log("src/quake/Sys.hx:45:",quake_PR.GetString(quake_PR.netnames + (client.num << 5)) + " entered the game\n");
		}
		quake_PR.ExecuteProgram(quake_PR.globals.ints[88]);
	}
	var message = client.message;
	message.cursize = 0;
	message.WriteByte(7);
	message.WriteFloat(quake_SV.server.time);
	var _g2 = 0;
	var _g11 = quake_SV.svs.maxclients;
	while(_g2 < _g11) {
		var i = _g2++;
		client = quake_SV.svs.clients[i];
		message.WriteByte(13);
		message.WriteByte(i);
		message.WriteString(quake_PR.GetString(quake_PR.netnames + (client.num << 5)));
		message.WriteByte(14);
		message.WriteByte(i);
		message.WriteShort(client.old_frags);
		message.WriteByte(17);
		message.WriteByte(i);
		message.WriteByte(client.colors);
	}
	var _g21 = 0;
	while(_g21 < 64) {
		var i1 = _g21++;
		message.WriteByte(12);
		message.WriteByte(i1);
		message.WriteString(quake_SV.server.lightstyles[i1]);
	}
	message.WriteByte(3);
	message.WriteByte(11);
	message.WriteLong(quake_PR.globals.floats[39] | 0);
	message.WriteByte(3);
	message.WriteByte(12);
	message.WriteLong(quake_PR.globals.floats[40] | 0);
	message.WriteByte(3);
	message.WriteByte(13);
	message.WriteLong(quake_PR.globals.floats[41] | 0);
	message.WriteByte(3);
	message.WriteByte(14);
	message.WriteLong(quake_PR.globals.floats[42] | 0);
	message.WriteByte(10);
	message.WriteByte((ent.v.angles[0] * 256 / 360 | 0) & 255);
	message.WriteByte((ent.v.angles[1] * 256 / 360 | 0) & 255);
	message.WriteByte((0. | 0) & 255);
	quake_SV.WriteClientdataToMessage(ent,message);
	message.WriteByte(25);
	message.WriteByte(3);
	quake_Host.client.sendsignon = true;
};
quake_Host.Begin_f = function() {
	if(!quake_Cmd.client) {
		quake_Console.Print("begin is not valid from the console\n");
		return;
	}
	quake_Host.client.spawned = true;
};
quake_Host.Kick_f = function() {
	if(!quake_Cmd.client) {
		if(!quake_SV.server.active) {
			quake_Cmd.ForwardToServer();
			return;
		}
	} else if(quake_PR.globals.floats[35] != 0.0) {
		return;
	}
	if(quake_Cmd.argv.length <= 1) {
		return;
	}
	var save = quake_Host.client;
	var s = quake_Cmd.argv[1].toLowerCase();
	var i;
	var byNumber = null;
	if(quake_Cmd.argv.length >= 3 && s == "#") {
		i = quake_Q.atoi(quake_Cmd.argv[2]) - 1;
		if(i < 0 || i >= quake_SV.svs.maxclients) {
			return;
		}
		if(!quake_SV.svs.clients[i].active) {
			return;
		}
		quake_Host.client = quake_SV.svs.clients[i];
		byNumber = true;
	} else {
		i = 0;
		while(i < quake_SV.svs.maxclients) {
			quake_Host.client = quake_SV.svs.clients[i];
			if(!quake_Host.client.active) {
				++i;
				continue;
			}
			if(quake_PR.GetString(quake_PR.netnames + (quake_Host.client.num << 5)).toLowerCase() == s) {
				break;
			}
			++i;
		}
	}
	if(i >= quake_SV.svs.maxclients) {
		quake_Host.client = save;
		return;
	}
	if(quake_Host.client == save) {
		return;
	}
	var who;
	if(!quake_Cmd.client) {
		who = quake_CL.$name.string;
	} else {
		if(quake_Host.client == save) {
			return;
		}
		who = quake_PR.GetString(quake_PR.netnames + (save.num << 5));
	}
	var message = null;
	if(quake_Cmd.argv.length >= 3) {
		message = quake_COM.Parse(quake_Cmd.args);
	}
	if(message != null) {
		var p = 0;
		if(byNumber) {
			p = 1;
			while(p < message.length) {
				if(HxOverrides.cca(message,p) != 32) {
					break;
				}
				++p;
			}
			p += quake_Cmd.argv[2].length;
		}
		while(p < message.length) {
			if(HxOverrides.cca(message,p) != 32) {
				break;
			}
			++p;
		}
		quake_Host.ClientPrint("Kicked by " + who + ": " + message.substring(p) + "\n");
	} else {
		quake_Host.ClientPrint("Kicked by " + who + "\n");
	}
	quake_Host.DropClient(false);
	quake_Host.client = save;
};
quake_Host.Give_f = function() {
	if(!quake_Cmd.client) {
		quake_Cmd.ForwardToServer();
		return;
	}
	if(quake_PR.globals.floats[35] != 0) {
		return;
	}
	if(quake_Cmd.argv.length <= 1) {
		return;
	}
	var t = HxOverrides.cca(quake_Cmd.argv[1],0);
	var ent = quake_SV.player;
	if(t >= 48 && t <= 57) {
		if(!quake_COM.hipnotic) {
			if(t >= 50) {
				ent.v.floats[58] = ent.v.floats[58] | 0 | quake_Def.it.shotgun << t - 50;
			}
			return;
		}
		if(t == 54) {
			if(HxOverrides.cca(quake_Cmd.argv[1],1) == 97) {
				ent.v.floats[58] = ent.v.floats[58] | 0 | quake_Def.hit.proximity_gun;
			} else {
				ent.v.floats[58] = ent.v.floats[58] | 0 | quake_Def.it.grenade_launcher;
			}
			return;
		}
		if(t == 57) {
			ent.v.floats[58] = ent.v.floats[58] | 0 | quake_Def.hit.laser_cannon;
		} else if(t == 48) {
			ent.v.floats[58] = ent.v.floats[58] | 0 | quake_Def.hit.mjolnir;
		} else if(t >= 50) {
			ent.v.floats[58] = ent.v.floats[58] | 0 | quake_Def.it.shotgun << t - 50;
		}
		return;
	}
	var v = quake_Q.atoi(quake_Cmd.argv[2]);
	if(t == 104) {
		ent.v.floats[48] = v;
		return;
	}
	if(!quake_COM.rogue) {
		switch(t) {
		case 99:
			ent.v.floats[57] = v;
			break;
		case 110:
			ent.v.floats[55] = v;
			break;
		case 114:
			ent.v.floats[56] = v;
			break;
		case 115:
			ent.v.floats[54] = v;
			break;
		}
		return;
	}
	switch(t) {
	case 99:
		if(quake_EdictVars.ammo_cells1_ofs != null) {
			ent.v.floats[quake_EdictVars.ammo_cells1_ofs] = v;
			if(ent.v.floats[50] <= quake_Def.it.lightning) {
				ent.v.floats[57] = v;
			}
		}
		break;
	case 108:
		if(quake_EdictVars.ammo_lava_nails_ofs != null) {
			ent.v.floats[quake_EdictVars.ammo_lava_nails_ofs] = v;
			if(ent.v.floats[50] > quake_Def.it.lightning) {
				ent.v.floats[55] = v;
			}
		}
		break;
	case 109:
		if(quake_EdictVars.ammo_multi_rockets_ofs != null) {
			ent.v.floats[quake_EdictVars.ammo_multi_rockets_ofs] = v;
			if(ent.v.floats[50] > quake_Def.it.lightning) {
				ent.v.floats[56] = v;
			}
		}
		break;
	case 110:
		if(quake_EdictVars.ammo_nails1_ofs != null) {
			ent.v.floats[quake_EdictVars.ammo_nails1_ofs] = v;
			if(ent.v.floats[50] <= quake_Def.it.lightning) {
				ent.v.floats[55] = v;
			}
		}
		break;
	case 112:
		if(quake_EdictVars.ammo_plasma_ofs != null) {
			ent.v.floats[quake_EdictVars.ammo_plasma_ofs] = v;
			if(ent.v.floats[50] > quake_Def.it.lightning) {
				ent.v.floats[57] = v;
			}
		}
		break;
	case 114:
		if(quake_EdictVars.ammo_rockets1_ofs != null) {
			ent.v.floats[quake_EdictVars.ammo_rockets1_ofs] = v;
			if(ent.v.floats[50] <= quake_Def.it.lightning) {
				ent.v.floats[56] = v;
			}
		}
		break;
	case 115:
		if(quake_EdictVars.ammo_shells1_ofs != null) {
			ent.v.floats[quake_EdictVars.ammo_shells1_ofs] = v;
		}
		ent.v.floats[54] = v;
		break;
	}
};
quake_Host.FindViewthing = function() {
	if(quake_SV.server.active) {
		var _g = 0;
		var _g1 = quake_SV.server.num_edicts;
		while(_g < _g1) {
			var e = quake_SV.server.edicts[_g++];
			if(quake_PR.GetString(e.v.ints[28]) == "viewthing") {
				return e;
			}
		}
	}
	quake_Console.Print("No viewthing on map\n");
	return null;
};
quake_Host.Viewmodel_f = function() {
	if(quake_Cmd.argv.length != 2) {
		return;
	}
	var ent = quake_Host.FindViewthing();
	if(ent == null) {
		return;
	}
	var m = quake_Mod.LoadModel(quake_Mod.FindName(quake_Cmd.argv[1]),false);
	if(m == null) {
		quake_Console.Print("Can't load " + quake_Cmd.argv[1] + "\n");
		return;
	}
	ent.v.floats[30] = 0.0;
	quake_CL.state.model_precache[ent.v.floats[0] | 0] = m;
};
quake_Host.Viewframe_f = function() {
	var ent = quake_Host.FindViewthing();
	if(ent == null) {
		return;
	}
	var m = quake_CL.state.model_precache[ent.v.floats[0] | 0];
	var f = quake_Q.atoi(quake_Cmd.argv[1]);
	if(f >= m.frames.length) {
		f = m.frames.length - 1;
	}
	ent.v.floats[30] = f;
};
quake_Host.Viewnext_f = function() {
	var ent = quake_Host.FindViewthing();
	if(ent == null) {
		return;
	}
	var m = quake_CL.state.model_precache[ent.v.floats[0] | 0];
	var f = (ent.v.floats[30] | 0) + 1;
	if(f >= m.frames.length) {
		f = m.frames.length - 1;
	}
	ent.v.floats[30] = f;
	quake_Console.Print("frame " + f + ": " + m.frames[f].name + "\n");
};
quake_Host.Viewprev_f = function() {
	var ent = quake_Host.FindViewthing();
	if(ent == null) {
		return;
	}
	var m = quake_CL.state.model_precache[ent.v.floats[0] | 0];
	var f = (ent.v.floats[30] | 0) - 1;
	if(f < 0) {
		f = 0;
	}
	ent.v.floats[30] = f;
	quake_Console.Print("frame " + f + ": " + m.frames[f].name + "\n");
};
quake_Host.Startdemos_f = function() {
	quake_Console.Print(quake_Cmd.argv.length - 1 + " demo(s) in loop\n");
	quake_CL.cls.demos = [];
	var _g = 1;
	var _g1 = quake_Cmd.argv.length;
	while(_g < _g1) {
		var i = _g++;
		quake_CL.cls.demos[i - 1] = quake_Cmd.argv[i];
	}
	if(quake_CL.cls.demonum != -1 && !quake_CL.cls.demoplayback) {
		quake_CL.cls.demonum = 0;
		if(quake_Host.framecount != 0) {
			quake_CL.NextDemo();
		} else {
			quake_Host.startdemos = true;
		}
	} else {
		quake_CL.cls.demonum = -1;
	}
};
quake_Host.Demos_f = function() {
	if(quake_CL.cls.demonum == -1) {
		quake_CL.cls.demonum = 1;
	}
	quake_CL.Disconnect();
	quake_CL.NextDemo();
};
quake_Host.Stopdemo_f = function() {
	if(!quake_CL.cls.demoplayback) {
		return;
	}
	quake_CL.StopPlayback();
	quake_CL.Disconnect();
};
quake_Host.InitCommands = function() {
	quake_Cmd.AddCommand("status",quake_Host.Status_f);
	quake_Cmd.AddCommand("quit",quake_Host.Quit_f);
	quake_Cmd.AddCommand("god",quake_Host.God_f);
	quake_Cmd.AddCommand("notarget",quake_Host.Notarget_f);
	quake_Cmd.AddCommand("fly",quake_Host.Fly_f);
	quake_Cmd.AddCommand("map",quake_Host.Map_f);
	quake_Cmd.AddCommand("restart",quake_Host.Restart_f);
	quake_Cmd.AddCommand("changelevel",quake_Host.Changelevel_f);
	quake_Cmd.AddCommand("connect",quake_Host.Connect_f);
	quake_Cmd.AddCommand("reconnect",quake_Host.Reconnect_f);
	quake_Cmd.AddCommand("name",quake_Host.Name_f);
	quake_Cmd.AddCommand("noclip",quake_Host.Noclip_f);
	quake_Cmd.AddCommand("version",quake_Host.Version_f);
	quake_Cmd.AddCommand("say",function() {
		quake_Host.Say(false);
	});
	quake_Cmd.AddCommand("say_team",quake_Host.Say_Team_f);
	quake_Cmd.AddCommand("tell",quake_Host.Tell_f);
	quake_Cmd.AddCommand("color",quake_Host.Color_f);
	quake_Cmd.AddCommand("kill",quake_Host.Kill_f);
	quake_Cmd.AddCommand("pause",quake_Host.Pause_f);
	quake_Cmd.AddCommand("spawn",quake_Host.Spawn_f);
	quake_Cmd.AddCommand("begin",quake_Host.Begin_f);
	quake_Cmd.AddCommand("prespawn",quake_Host.PreSpawn_f);
	quake_Cmd.AddCommand("kick",quake_Host.Kick_f);
	quake_Cmd.AddCommand("ping",quake_Host.Ping_f);
	quake_Cmd.AddCommand("load",quake_Host.Loadgame_f);
	quake_Cmd.AddCommand("save",quake_Host.Savegame_f);
	quake_Cmd.AddCommand("give",quake_Host.Give_f);
	quake_Cmd.AddCommand("startdemos",quake_Host.Startdemos_f);
	quake_Cmd.AddCommand("demos",quake_Host.Demos_f);
	quake_Cmd.AddCommand("stopdemo",quake_Host.Stopdemo_f);
	quake_Cmd.AddCommand("viewmodel",quake_Host.Viewmodel_f);
	quake_Cmd.AddCommand("viewframe",quake_Host.Viewframe_f);
	quake_Cmd.AddCommand("viewnext",quake_Host.Viewnext_f);
	quake_Cmd.AddCommand("viewprev",quake_Host.Viewprev_f);
	quake_Cmd.AddCommand("mcache",quake_Mod.Print);
};
var quake__$IN_StdMouseHandler = function() { };
quake__$IN_StdMouseHandler.__name__ = true;
quake__$IN_StdMouseHandler.attach = function() {
	if(quake_VID.mainwindow.requestPointerLock != null) {
		quake_VID.mainwindow.onclick = quake__$IN_StdMouseHandler.onclick;
		window.document.onmousemove = quake__$IN_StdMouseHandler.onmousemove;
		window.document.onpointerlockchange = quake__$IN_StdMouseHandler.onpointerlockchange;
		return quake__$IN_StdMouseHandler.detach;
	}
	return null;
};
quake__$IN_StdMouseHandler.detach = function() {
	quake_VID.mainwindow.onclick = null;
	window.document.onmousemove = null;
	window.document.onpointerlockchange = null;
};
quake__$IN_StdMouseHandler.onclick = function() {
	if(window.document.pointerLockElement != quake_VID.mainwindow) {
		quake_VID.mainwindow.requestPointerLock();
	}
};
quake__$IN_StdMouseHandler.onmousemove = function(e) {
	if(window.document.pointerLockElement != quake_VID.mainwindow) {
		return;
	}
	quake_IN.mouse_x += e.movementX;
	quake_IN.mouse_y += e.movementY;
};
quake__$IN_StdMouseHandler.onpointerlockchange = function() {
	if(window.document.pointerLockElement == quake_VID.mainwindow) {
		return;
	}
	quake_Key.Event(27,true);
	quake_Key.Event(27,false);
};
var quake__$IN_MozMouseHandler = function() { };
quake__$IN_MozMouseHandler.__name__ = true;
quake__$IN_MozMouseHandler.attach = function() {
	if(quake_VID.mainwindow.mozRequestPointerLock != null) {
		quake_VID.mainwindow.onclick = quake__$IN_MozMouseHandler.onclick;
		window.document.onmousemove = quake__$IN_MozMouseHandler.onmousemove;
		window.document.onmozpointerlockchange = quake__$IN_MozMouseHandler.onmozpointerlockchange;
		return quake__$IN_MozMouseHandler.detach;
	}
	return null;
};
quake__$IN_MozMouseHandler.detach = function() {
	quake_VID.mainwindow.onclick = null;
	window.document.onmousemove = null;
	window.document.onmozpointerlockchange = null;
};
quake__$IN_MozMouseHandler.onclick = function() {
	if(window.document.mozPointerLockElement != quake_VID.mainwindow) {
		quake_VID.mainwindow.mozRequestPointerLock();
	}
};
quake__$IN_MozMouseHandler.onmousemove = function(e) {
	if(window.document.mozPointerLockElement != quake_VID.mainwindow) {
		return;
	}
	quake_IN.mouse_x += e.mozMovementX;
	quake_IN.mouse_y += e.mozMovementY;
};
quake__$IN_MozMouseHandler.onmozpointerlockchange = function() {
	if(window.document.mozPointerLockElement == quake_VID.mainwindow) {
		return;
	}
	quake_Key.Event(27,true);
	quake_Key.Event(27,false);
};
var quake__$IN_WebkitMouseHandler = function() { };
quake__$IN_WebkitMouseHandler.__name__ = true;
quake__$IN_WebkitMouseHandler.attach = function() {
	if(quake_VID.mainwindow.webkitRequestPointerLock != null) {
		quake_VID.mainwindow.onclick = quake__$IN_WebkitMouseHandler.onclick;
		window.document.onmousemove = quake__$IN_WebkitMouseHandler.onmousemove;
		window.document.onwebkitpointerlockchange = quake__$IN_WebkitMouseHandler.onwebkitpointerlockchange;
		return quake__$IN_WebkitMouseHandler.detach;
	}
	return null;
};
quake__$IN_WebkitMouseHandler.detach = function() {
	quake_VID.mainwindow.onclick = null;
	window.document.onmousemove = null;
	window.document.onwebkitpointerlockchange = null;
};
quake__$IN_WebkitMouseHandler.onclick = function() {
	if(window.document.webkitPointerLockElement != quake_VID.mainwindow) {
		quake_VID.mainwindow.webkitRequestPointerLock();
	}
};
quake__$IN_WebkitMouseHandler.onmousemove = function(e) {
	if(window.document.webkitPointerLockElement != quake_VID.mainwindow) {
		return;
	}
	quake_IN.mouse_x += e.webkitMovementX;
	quake_IN.mouse_y += e.webkitMovementY;
};
quake__$IN_WebkitMouseHandler.onwebkitpointerlockchange = function() {
	if(window.document.webkitPointerLockElement == quake_VID.mainwindow) {
		return;
	}
	quake_Key.Event(27,true);
	quake_Key.Event(27,false);
};
var quake_IN = function() { };
quake_IN.__name__ = true;
quake_IN.Init = function() {
	quake_IN.m_filter = quake_Cvar.RegisterVariable("m_filter","1");
	if(quake_COM.CheckParm("-nomouse") != null) {
		return;
	}
	quake_IN.detachMouseHandler = quake_IN.attachMouseHandler();
	if(quake_IN.detachMouseHandler != null) {
		quake_IN.mouse_avail = true;
	}
};
quake_IN.attachMouseHandler = function() {
	var detach = quake__$IN_StdMouseHandler.attach();
	if(detach == null) {
		detach = quake__$IN_MozMouseHandler.attach();
	}
	if(detach == null) {
		detach = quake__$IN_WebkitMouseHandler.attach();
	}
	return detach;
};
quake_IN.Shutdown = function() {
	if(quake_IN.detachMouseHandler != null) {
		quake_IN.detachMouseHandler();
	}
};
quake_IN.Move = function() {
	if(!quake_IN.mouse_avail) {
		return;
	}
	var mouse_x;
	var mouse_y;
	if(quake_IN.m_filter.value != 0) {
		mouse_x = (quake_IN.mouse_x + quake_IN.old_mouse_x) * 0.5;
		mouse_y = (quake_IN.mouse_y + quake_IN.old_mouse_y) * 0.5;
	} else {
		mouse_x = quake_IN.mouse_x;
		mouse_y = quake_IN.mouse_y;
	}
	quake_IN.old_mouse_x = quake_IN.mouse_x;
	quake_IN.old_mouse_y = quake_IN.mouse_y;
	mouse_x *= quake_CL.sensitivity.value;
	mouse_y *= quake_CL.sensitivity.value;
	var strafe = quake_CL.kbuttons[quake_CL.kbutton.strafe].state & 1;
	var mlook = quake_CL.kbuttons[quake_CL.kbutton.mlook].state & 1;
	var angles = quake_CL.state.viewangles;
	if(strafe != 0 || quake_CL.lookstrafe.value != 0 && mlook != 0) {
		quake_CL.state.cmd.sidemove += quake_CL.m_side.value * mouse_x;
	} else {
		angles[1] -= quake_CL.m_yaw.value * mouse_x;
	}
	if(mlook != 0) {
		quake_V.StopPitchDrift();
	}
	if(mlook != 0 && strafe == 0) {
		if((angles[0] += quake_CL.m_pitch.value * mouse_y) > 80.0) {
			angles[0] = 80.0;
		} else if(angles[0] < -70.0) {
			angles[0] = -70.0;
		}
	} else if(strafe != 0 && quake_Host.noclip_anglehack) {
		quake_CL.state.cmd.upmove -= quake_CL.m_forward.value * mouse_y;
	} else {
		quake_CL.state.cmd.forwardmove -= quake_CL.m_forward.value * mouse_y;
	}
	quake_IN.mouse_x = quake_IN.mouse_y = 0;
};
var quake_Key = function() { };
quake_Key.__name__ = true;
quake_Key.ProcessConsole = function(key) {
	if(key == 13) {
		quake_Cmd.text += quake_Key.edit_line + "\n";
		quake_Console.Print("]" + quake_Key.edit_line + "\n");
		quake_Key.lines.push(quake_Key.edit_line);
		quake_Key.edit_line = "";
		quake_Key.history_line = quake_Key.lines.length;
		return;
	}
	if(key == 9) {
		var cmd = quake_Cmd.CompleteCommand(quake_Key.edit_line);
		if(cmd == null) {
			cmd = quake_Cvar.CompleteVariable(quake_Key.edit_line);
		}
		if(cmd == null) {
			return;
		}
		quake_Key.edit_line = cmd + " ";
		return;
	}
	if(key == 127 || key == 130) {
		if(quake_Key.edit_line.length > 0) {
			quake_Key.edit_line = quake_Key.edit_line.substring(0,quake_Key.edit_line.length - 1);
		}
		return;
	}
	if(key == 128) {
		if(--quake_Key.history_line < 0) {
			quake_Key.history_line = 0;
		}
		quake_Key.edit_line = quake_Key.lines[quake_Key.history_line];
		return;
	}
	if(key == 129) {
		if(quake_Key.history_line >= quake_Key.lines.length) {
			return;
		}
		if(++quake_Key.history_line >= quake_Key.lines.length) {
			quake_Key.history_line = quake_Key.lines.length;
			quake_Key.edit_line = "";
			return;
		}
		quake_Key.edit_line = quake_Key.lines[quake_Key.history_line];
		return;
	}
	if(key == 150) {
		quake_Console.backscroll += 2;
		if(quake_Console.backscroll > quake_Console.text.length) {
			quake_Console.backscroll = quake_Console.text.length;
		}
		return;
	}
	if(key == 149) {
		quake_Console.backscroll -= 2;
		if(quake_Console.backscroll < 0) {
			quake_Console.backscroll = 0;
		}
		return;
	}
	if(key == 151) {
		quake_Console.backscroll = quake_Console.text.length - 10;
		if(quake_Console.backscroll < 0) {
			quake_Console.backscroll = 0;
		}
		return;
	}
	if(key == 152) {
		quake_Console.backscroll = 0;
		return;
	}
	if(key < 32 || key > 127) {
		return;
	}
	quake_Key.edit_line += String.fromCodePoint(key);
};
quake_Key.Message = function(key) {
	if(key == 13) {
		if(quake_Key.team_message) {
			quake_Cmd.text += "say_team \"" + quake_Key.chat_buffer + "\"\n";
		} else {
			quake_Cmd.text += "say \"" + quake_Key.chat_buffer + "\"\n";
		}
		quake_Key.dest = 0;
		quake_Key.chat_buffer = "";
		return;
	}
	if(key == 27) {
		quake_Key.dest = 0;
		quake_Key.chat_buffer = "";
		return;
	}
	if(key < 32 || key > 127) {
		return;
	}
	if(key == 127) {
		if(quake_Key.chat_buffer.length != 0) {
			quake_Key.chat_buffer = quake_Key.chat_buffer.substring(0,quake_Key.chat_buffer.length - 1);
		}
		return;
	}
	if(quake_Key.chat_buffer.length >= 31) {
		return;
	}
	quake_Key.chat_buffer += String.fromCodePoint(key);
};
quake_Key.StringToKeynum = function(str) {
	if(str.length == 1) {
		return HxOverrides.cca(str,0);
	}
	str = str.toUpperCase();
	var _g = 0;
	var _g1 = quake_Key.names;
	while(_g < _g1.length) {
		var k = _g1[_g];
		++_g;
		if(k.name == str) {
			return k.keynum;
		}
	}
	return null;
};
quake_Key.KeynumToString = function(keynum) {
	if(keynum > 32 && keynum < 127) {
		return String.fromCodePoint(keynum);
	}
	var _g = 0;
	var _g1 = quake_Key.names;
	while(_g < _g1.length) {
		var k = _g1[_g];
		++_g;
		if(k.keynum == keynum) {
			return k.name;
		}
	}
	return "<UNKNOWN KEYNUM>";
};
quake_Key.Unbind_f = function() {
	if(quake_Cmd.argv.length != 2) {
		quake_Console.Print("unbind <key> : remove commands from a key\n");
		return;
	}
	var b = quake_Key.StringToKeynum(quake_Cmd.argv[1]);
	if(b == null) {
		quake_Console.Print("\"" + quake_Cmd.argv[1] + "\" isn't a valid key\n");
		return;
	}
	quake_Key.bindings[b] = null;
};
quake_Key.Unbindall_f = function() {
	quake_Key.bindings = [];
};
quake_Key.Bind_f = function() {
	var c = quake_Cmd.argv.length;
	if(c != 2 && c != 3) {
		quake_Console.Print("bind <key> [command] : attach a command to a key\n");
		return;
	}
	var b = quake_Key.StringToKeynum(quake_Cmd.argv[1]);
	if(b == null) {
		quake_Console.Print("\"" + quake_Cmd.argv[1] + "\" isn't a valid key\n");
		return;
	}
	if(c == 2) {
		if(quake_Key.bindings[b] != null) {
			quake_Console.Print("\"" + quake_Cmd.argv[1] + "\" = \"" + quake_Key.bindings[b] + "\"\n");
		} else {
			quake_Console.Print("\"" + quake_Cmd.argv[1] + "\" is not bound\n");
		}
		return;
	}
	var cmd = quake_Cmd.argv[2];
	var _g = 3;
	while(_g < c) cmd += " " + quake_Cmd.argv[_g++];
	quake_Key.bindings[b] = cmd;
};
quake_Key.WriteBindings = function() {
	var f_b = "";
	var _g = 0;
	var _g1 = quake_Key.bindings.length;
	while(_g < _g1) {
		var i = _g++;
		var b = quake_Key.bindings[i];
		if(b != null) {
			f_b += Std.string("bind \"" + quake_Key.KeynumToString(i) + "\" \"" + b + "\"\n");
		}
	}
	return f_b;
};
quake_Key.Init = function() {
	var _g = 32;
	while(_g < 128) quake_Key.consolekeys[_g++] = true;
	quake_Key.consolekeys[13] = true;
	quake_Key.consolekeys[9] = true;
	quake_Key.consolekeys[130] = true;
	quake_Key.consolekeys[131] = true;
	quake_Key.consolekeys[128] = true;
	quake_Key.consolekeys[129] = true;
	quake_Key.consolekeys[127] = true;
	quake_Key.consolekeys[151] = true;
	quake_Key.consolekeys[152] = true;
	quake_Key.consolekeys[150] = true;
	quake_Key.consolekeys[149] = true;
	quake_Key.consolekeys[134] = true;
	quake_Key.consolekeys[96] = false;
	quake_Key.consolekeys[126] = false;
	var _g1 = 0;
	while(_g1 < 256) {
		var i = _g1++;
		quake_Key.shift[i] = i;
	}
	quake_Key.shift[97] = 65;
	quake_Key.shift[98] = 66;
	quake_Key.shift[99] = 67;
	quake_Key.shift[100] = 68;
	quake_Key.shift[101] = 69;
	quake_Key.shift[102] = 70;
	quake_Key.shift[103] = 71;
	quake_Key.shift[104] = 72;
	quake_Key.shift[105] = 73;
	quake_Key.shift[106] = 74;
	quake_Key.shift[107] = 75;
	quake_Key.shift[108] = 76;
	quake_Key.shift[109] = 77;
	quake_Key.shift[110] = 78;
	quake_Key.shift[111] = 79;
	quake_Key.shift[112] = 80;
	quake_Key.shift[113] = 81;
	quake_Key.shift[114] = 82;
	quake_Key.shift[115] = 83;
	quake_Key.shift[116] = 84;
	quake_Key.shift[117] = 85;
	quake_Key.shift[118] = 86;
	quake_Key.shift[119] = 87;
	quake_Key.shift[120] = 88;
	quake_Key.shift[121] = 89;
	quake_Key.shift[122] = 90;
	quake_Key.shift[49] = 33;
	quake_Key.shift[50] = 64;
	quake_Key.shift[51] = 35;
	quake_Key.shift[52] = 36;
	quake_Key.shift[53] = 37;
	quake_Key.shift[54] = 94;
	quake_Key.shift[55] = 38;
	quake_Key.shift[56] = 42;
	quake_Key.shift[57] = 40;
	quake_Key.shift[48] = 41;
	quake_Key.shift[45] = 95;
	quake_Key.shift[61] = 43;
	quake_Key.shift[43] = 60;
	quake_Key.shift[46] = 62;
	quake_Key.shift[47] = 63;
	quake_Key.shift[59] = 58;
	quake_Key.shift[39] = 34;
	quake_Key.shift[91] = 123;
	quake_Key.shift[93] = 125;
	quake_Key.shift[96] = 126;
	quake_Key.shift[92] = 124;
	quake_Cmd.AddCommand("bind",quake_Key.Bind_f);
	quake_Cmd.AddCommand("unbind",quake_Key.Unbind_f);
	quake_Cmd.AddCommand("unbindall",quake_Key.Unbindall_f);
};
quake_Key.Event = function(key,down) {
	if(quake_CL.cls.state == 1) {
		return;
	}
	if(down) {
		if(key != 127 && key != 255 && quake_Key.down[key]) {
			return;
		}
		if(key >= 200 && quake_Key.bindings[key] == null) {
			quake_Console.Print(quake_Key.KeynumToString(key) + " is unbound, hit F4 to set.\n");
		}
	}
	quake_Key.down[key] = down;
	if(key == 134) {
		quake_Key.shift_down = down;
	}
	if(key == 27) {
		if(!down) {
			return;
		}
		if(quake_Key.dest == 2) {
			quake_Key.Message(key);
		} else if(quake_Key.dest == 3) {
			quake_Menu.Keydown(key);
		} else {
			quake_Menu.ToggleMenu_f();
		}
		return;
	}
	var kb;
	if(!down) {
		kb = quake_Key.bindings[key];
		if(kb != null) {
			if(HxOverrides.cca(kb,0) == 43) {
				quake_Cmd.text += "-" + kb.substring(1) + " " + key + "\n";
			}
		}
		if(quake_Key.shift[key] != key) {
			kb = quake_Key.bindings[quake_Key.shift[key]];
			if(kb != null) {
				if(HxOverrides.cca(kb,0) == 43) {
					quake_Cmd.text += "-" + kb.substring(1) + " " + key + "\n";
				}
			}
		}
		return;
	}
	if(quake_CL.cls.demoplayback && quake_Key.consolekeys[key] && quake_Key.dest == 0) {
		quake_Menu.ToggleMenu_f();
		return;
	}
	if(quake_Key.dest == 3 && (key == 27 || key >= 135 && key <= 146) || quake_Key.dest == 1 && !quake_Key.consolekeys[key] || quake_Key.dest == 0 && (!quake_Console.forcedup || !quake_Key.consolekeys[key])) {
		kb = quake_Key.bindings[key];
		if(kb != null) {
			if(HxOverrides.cca(kb,0) == 43) {
				quake_Cmd.text += kb + " " + key + "\n";
			} else {
				quake_Cmd.text += kb + "\n";
			}
		}
		return;
	}
	if(quake_Key.shift_down) {
		key = quake_Key.shift[key];
	}
	if(quake_Key.dest == 2) {
		quake_Key.Message(key);
	} else if(quake_Key.dest == 3) {
		quake_Menu.Keydown(key);
	} else {
		quake_Key.ProcessConsole(key);
	}
};
var quake_Menu = function() { };
quake_Menu.__name__ = true;
quake_Menu.DrawCharacter = function(cx,line,num) {
	quake_Draw.Character(cx + (quake_VID.width >> 1) - 160,line + (quake_VID.height >> 1) - 100,num);
};
quake_Menu.Print = function(cx,cy,str) {
	quake_Draw.StringWhite(cx + (quake_VID.width >> 1) - 160,cy + (quake_VID.height >> 1) - 100,str);
};
quake_Menu.PrintWhite = function(cx,cy,str) {
	quake_Draw.String(cx + (quake_VID.width >> 1) - 160,cy + (quake_VID.height >> 1) - 100,str);
};
quake_Menu.DrawPic = function(x,y,pic) {
	quake_Draw.Pic(x + (quake_VID.width >> 1) - 160,y + (quake_VID.height >> 1) - 100,pic);
};
quake_Menu.DrawPicTranslate = function(x,y,pic,top,bottom) {
	quake_Draw.PicTranslate(x + (quake_VID.width >> 1) - 160,y + (quake_VID.height >> 1) - 100,pic,top,bottom);
};
quake_Menu.DrawTextBox = function(x,y,width,lines) {
	var cy = y;
	quake_Menu.DrawPic(x,y,quake_Menu.box_tl);
	var _g = 0;
	while(_g < lines) {
		++_g;
		quake_Menu.DrawPic(x,cy += 8,quake_Menu.box_ml);
	}
	quake_Menu.DrawPic(x,cy + 8,quake_Menu.box_bl);
	var cx = x + 8;
	var p;
	while(width > 0) {
		cy = y;
		quake_Menu.DrawPic(cx,y,quake_Menu.box_tm);
		p = quake_Menu.box_mm;
		var _g2 = 0;
		while(_g2 < lines) {
			quake_Menu.DrawPic(cx,cy += 8,p);
			if(_g2++ == 0) {
				p = quake_Menu.box_mm2;
			}
		}
		quake_Menu.DrawPic(cx,cy + 8,quake_Menu.box_bm);
		width -= 2;
		cx += 16;
	}
	cy = y;
	quake_Menu.DrawPic(cx,y,quake_Menu.box_tr);
	var _g21 = 0;
	while(_g21 < lines) {
		++_g21;
		quake_Menu.DrawPic(cx,cy += 8,quake_Menu.box_mr);
	}
	quake_Menu.DrawPic(cx,cy + 8,quake_Menu.box_br);
};
quake_Menu.ToggleMenu_f = function() {
	quake_Menu.entersound = true;
	if(quake_Key.dest == 3) {
		if(quake_Menu.state != 1) {
			quake_Menu.Menu_Main_f();
			return;
		}
		quake_Key.dest = 0;
		quake_Menu.state = 0;
		return;
	}
	quake_Menu.Menu_Main_f();
};
quake_Menu.Menu_Main_f = function() {
	if(quake_Key.dest != 3) {
		quake_Menu.save_demonum = quake_CL.cls.demonum;
		quake_CL.cls.demonum = -1;
	}
	quake_Key.dest = 3;
	quake_Menu.state = 1;
	quake_Menu.entersound = true;
};
quake_Menu.Main_Draw = function() {
	quake_Menu.DrawPic(16,4,quake_Menu.qplaque);
	quake_Menu.DrawPic(160 - (quake_Menu.ttl_main.width >> 1),4,quake_Menu.ttl_main);
	quake_Menu.DrawPic(72,32,quake_Menu.mainmenu);
	quake_Menu.DrawPic(54,32 + quake_Menu.main_cursor * 20,quake_Menu.menudot[Math.floor(quake_Host.realtime * 10.0) % 6]);
};
quake_Menu.Main_Key = function(k) {
	switch(k) {
	case 13:
		quake_Menu.entersound = true;
		switch(quake_Menu.main_cursor) {
		case 0:
			quake_Menu.Menu_SinglePlayer_f();
			break;
		case 1:
			quake_Menu.Menu_MultiPlayer_f();
			break;
		case 2:
			quake_Menu.Menu_Options_f();
			break;
		case 3:
			quake_Menu.Menu_Help_f();
			break;
		case 4:
			quake_Menu.Menu_Quit_f();
			break;
		}
		break;
	case 27:
		quake_Key.dest = 0;
		quake_Menu.state = 0;
		quake_CL.cls.demonum = quake_Menu.save_demonum;
		if(quake_CL.cls.demonum != -1 && !quake_CL.cls.demoplayback && quake_CL.cls.state != 2) {
			quake_CL.NextDemo();
		}
		break;
	case 128:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(--quake_Menu.main_cursor < 0) {
			quake_Menu.main_cursor = 4;
		}
		break;
	case 129:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(++quake_Menu.main_cursor >= 5) {
			quake_Menu.main_cursor = 0;
		}
		break;
	default:
	}
};
quake_Menu.Menu_SinglePlayer_f = function() {
	quake_Key.dest = 3;
	quake_Menu.state = 2;
	quake_Menu.entersound = true;
};
quake_Menu.SinglePlayer_Draw = function() {
	quake_Menu.DrawPic(16,4,quake_Menu.qplaque);
	quake_Menu.DrawPic(160 - (quake_Menu.ttl_sgl.width >> 1),4,quake_Menu.ttl_sgl);
	quake_Menu.DrawPic(72,32,quake_Menu.sp_menu);
	quake_Menu.DrawPic(54,32 + quake_Menu.singleplayer_cursor * 20,quake_Menu.menudot[Math.floor(quake_Host.realtime * 10.0) % 6]);
};
quake_Menu.SinglePlayer_Key = function(k) {
	switch(k) {
	case 13:
		quake_Menu.entersound = true;
		switch(quake_Menu.singleplayer_cursor) {
		case 0:
			if(quake_SV.server.active) {
				if(!window.confirm("Are you sure you want to start a new game?")) {
					return;
				}
				quake_Cmd.text += "disconnect\n";
			}
			quake_Key.dest = 0;
			quake_Cmd.text += "maxplayers 1\nmap start\n";
			break;
		case 1:
			quake_Menu.Menu_Load_f();
			break;
		case 2:
			quake_Menu.Menu_Save_f();
			break;
		}
		break;
	case 27:
		quake_Menu.Menu_Main_f();
		break;
	case 128:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(--quake_Menu.singleplayer_cursor < 0) {
			quake_Menu.singleplayer_cursor = 2;
		}
		break;
	case 129:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(++quake_Menu.singleplayer_cursor >= 3) {
			quake_Menu.singleplayer_cursor = 0;
		}
		break;
	default:
	}
};
quake_Menu.ScanSaves = function() {
	var searchpaths = quake_COM.searchpaths;
	var search = "Quake." + quake_COM.gamedir[0].filename + "/s";
	quake_COM.searchpaths = quake_COM.gamedir;
	var _g = 0;
	var _g1 = quake_Menu.max_savegames;
	while(_g < _g1) {
		var i = _g++;
		var f = quake_Menu.localStorage.getItem(search + i + ".sav");
		if(f != null) {
			quake_Menu.removable[i] = true;
		} else {
			quake_Menu.removable[i] = false;
			f = quake_COM.LoadTextFile("s" + i + ".sav");
			if(f == null) {
				quake_Menu.filenames[i] = "--- UNUSED SLOT ---";
				quake_Menu.loadable[i] = false;
				continue;
			}
		}
		var version = 0;
		while(version < f.length) if(HxOverrides.cca(f,version++) == 10) {
			break;
		}
		var name = [];
		var _g2 = 0;
		while(_g2 < 40) {
			var j = _g2++;
			var c = HxOverrides.cca(f,version + j);
			if(c == 13) {
				break;
			}
			if(c == 95) {
				name[j] = " ";
			} else {
				name[j] = String.fromCodePoint(c);
			}
		}
		quake_Menu.filenames[i] = name.join("");
		quake_Menu.loadable[i] = true;
	}
	quake_COM.searchpaths = searchpaths;
};
quake_Menu.Menu_Load_f = function() {
	quake_Menu.entersound = true;
	quake_Menu.state = 3;
	quake_Key.dest = 3;
	quake_Menu.ScanSaves();
};
quake_Menu.Menu_Save_f = function() {
	if(!quake_SV.server.active || quake_CL.state.intermission != 0 || quake_SV.svs.maxclients != 1) {
		return;
	}
	quake_Menu.entersound = true;
	quake_Menu.state = 4;
	quake_Key.dest = 3;
	quake_Menu.ScanSaves();
};
quake_Menu.Load_Draw = function() {
	quake_Menu.DrawPic(160 - (quake_Menu.p_load.width >> 1),4,quake_Menu.p_load);
	var _g = 0;
	var _g1 = quake_Menu.max_savegames;
	while(_g < _g1) {
		var i = _g++;
		quake_Menu.Print(16,32 + (i << 3),quake_Menu.filenames[i]);
	}
	quake_Menu.DrawCharacter(8,32 + (quake_Menu.load_cursor << 3),12 + ((quake_Host.realtime * 4 | 0) & 1));
};
quake_Menu.Save_Draw = function() {
	quake_Menu.DrawPic(160 - (quake_Menu.p_save.width >> 1),4,quake_Menu.p_save);
	var _g = 0;
	var _g1 = quake_Menu.max_savegames;
	while(_g < _g1) {
		var i = _g++;
		quake_Menu.Print(16,32 + (i << 3),quake_Menu.filenames[i]);
	}
	quake_Menu.DrawCharacter(8,32 + (quake_Menu.load_cursor << 3),12 + ((quake_Host.realtime * 4 | 0) & 1));
};
quake_Menu.Load_Key = function(k) {
	switch(k) {
	case 13:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu2,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(!quake_Menu.loadable[quake_Menu.load_cursor]) {
			return;
		}
		quake_Menu.state = 0;
		quake_Key.dest = 0;
		quake_SCR.BeginLoadingPlaque();
		quake_Cmd.text += "load s" + quake_Menu.load_cursor + "\n";
		break;
	case 27:
		quake_Menu.Menu_SinglePlayer_f();
		break;
	case 129:case 131:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(++quake_Menu.load_cursor >= quake_Menu.max_savegames) {
			quake_Menu.load_cursor = 0;
		}
		return;
	case 128:case 130:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(--quake_Menu.load_cursor < 0) {
			quake_Menu.load_cursor = quake_Menu.max_savegames - 1;
		}
		break;
	case 148:
		if(!quake_Menu.removable[quake_Menu.load_cursor]) {
			return;
		}
		if(!window.confirm("Delete selected game?")) {
			return;
		}
		quake_Menu.localStorage.removeItem("Quake." + quake_COM.gamedir[0].filename + "/s" + quake_Menu.load_cursor + ".sav");
		quake_Menu.ScanSaves();
		break;
	default:
	}
};
quake_Menu.Save_Key = function(k) {
	switch(k) {
	case 13:
		quake_Menu.state = 0;
		quake_Key.dest = 0;
		quake_Cmd.text += "save s" + quake_Menu.load_cursor + "\n";
		break;
	case 27:
		quake_Menu.Menu_SinglePlayer_f();
		break;
	case 129:case 131:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(++quake_Menu.load_cursor >= quake_Menu.max_savegames) {
			quake_Menu.load_cursor = 0;
		}
		break;
	case 128:case 130:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(--quake_Menu.load_cursor < 0) {
			quake_Menu.load_cursor = quake_Menu.max_savegames - 1;
		}
		break;
	case 148:
		if(!quake_Menu.removable[quake_Menu.load_cursor]) {
			return;
		}
		if(!window.confirm("Delete selected game?")) {
			return;
		}
		quake_Menu.localStorage.removeItem("Quake." + quake_COM.gamedir[0].filename + "/s" + quake_Menu.load_cursor + ".sav");
		quake_Menu.ScanSaves();
		break;
	default:
	}
};
quake_Menu.Menu_MultiPlayer_f = function() {
	quake_Key.dest = 3;
	quake_Menu.state = 5;
	quake_Menu.entersound = true;
	quake_Menu.multiplayer_myname = quake_CL.$name.string;
	quake_Menu.multiplayer_top = quake_Menu.multiplayer_oldtop = (quake_CL.color.value | 0) >> 4;
	quake_Menu.multiplayer_bottom = quake_Menu.multiplayer_oldbottom = (quake_CL.color.value | 0) & 15;
};
quake_Menu.MultiPlayer_Draw = function() {
	quake_Menu.DrawPic(16,4,quake_Menu.qplaque);
	quake_Menu.DrawPic(160 - (quake_Menu.p_multi.width >> 1),4,quake_Menu.p_multi);
	quake_Menu.Print(64,40,"Join game at:");
	quake_Menu.DrawTextBox(72,48,22,1);
	quake_Menu.Print(80,56,quake_Menu.multiplayer_joinname.substring(quake_Menu.multiplayer_joinname.length - 21));
	quake_Menu.Print(64,72,"Your name");
	quake_Menu.DrawTextBox(160,64,16,1);
	quake_Menu.Print(168,72,quake_Menu.multiplayer_myname);
	quake_Menu.Print(64,96,"Shirt color");
	quake_Menu.Print(64,120,"Pants color");
	quake_Menu.DrawTextBox(64,148,14,1);
	quake_Menu.Print(72,156,"Accept Changes");
	quake_Menu.DrawPic(160,80,quake_Menu.bigbox);
	quake_Menu.DrawPicTranslate(172,88,quake_Menu.menuplyr,(quake_Menu.multiplayer_top << 4) + (quake_Menu.multiplayer_top >= 8 ? 4 : 11),(quake_Menu.multiplayer_bottom << 4) + (quake_Menu.multiplayer_bottom >= 8 ? 4 : 11));
	quake_Menu.DrawCharacter(56,quake_Menu.multiplayer_cursor_table[quake_Menu.multiplayer_cursor],12 + ((quake_Host.realtime * 4 | 0) & 1));
	if(quake_Menu.multiplayer_cursor == 0) {
		quake_Menu.DrawCharacter(quake_Menu.multiplayer_joinname.length <= 20 ? 80 + (quake_Menu.multiplayer_joinname.length << 3) : 248,56,10 + ((quake_Host.realtime * 4 | 0) & 1));
	} else if(quake_Menu.multiplayer_cursor == 1) {
		quake_Menu.DrawCharacter(168 + (quake_Menu.multiplayer_myname.length << 3),72,10 + ((quake_Host.realtime * 4 | 0) & 1));
	}
	if(!quake_NET_$WEBS.available) {
		quake_Menu.PrintWhite(52,172,"No Communications Available");
	}
};
quake_Menu.MultiPlayer_Key = function(k) {
	if(k == 27) {
		quake_Menu.Menu_Main_f();
	}
	switch(k) {
	case 13:
		switch(quake_Menu.multiplayer_cursor) {
		case 0:
			quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu2,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
			if(!quake_NET_$WEBS.available) {
				return;
			}
			quake_Key.dest = 0;
			quake_Menu.state = 0;
			quake_Cmd.text += "connect \"";
			if(quake_Menu.multiplayer_joinname.substring(0,5) != "ws://") {
				quake_Cmd.text += "ws://";
			}
			quake_Cmd.text += quake_Menu.multiplayer_joinname + "\"\n";
			break;
		case 2:
			quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu3,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
			if(quake_Menu.multiplayer_top <= 12) {
				++quake_Menu.multiplayer_top;
			} else {
				quake_Menu.multiplayer_top = 0;
			}
			break;
		case 3:
			quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu3,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
			if(quake_Menu.multiplayer_bottom <= 12) {
				++quake_Menu.multiplayer_bottom;
			} else {
				quake_Menu.multiplayer_bottom = 0;
			}
			break;
		case 4:
			if(quake_CL.$name.string != quake_Menu.multiplayer_myname) {
				quake_Cmd.text += "name \"" + quake_Menu.multiplayer_myname + "\"\n";
			}
			if(quake_Menu.multiplayer_top != quake_Menu.multiplayer_oldtop || quake_Menu.multiplayer_bottom != quake_Menu.multiplayer_oldbottom) {
				quake_Menu.multiplayer_oldtop = quake_Menu.multiplayer_top;
				quake_Menu.multiplayer_oldbottom = quake_Menu.multiplayer_bottom;
				quake_Cmd.text += "color " + quake_Menu.multiplayer_top + " " + quake_Menu.multiplayer_bottom + "\n";
			}
			quake_Menu.entersound = true;
			break;
		}
		break;
	case 127:
		if(quake_Menu.multiplayer_cursor == 0) {
			if(quake_Menu.multiplayer_joinname.length != 0) {
				quake_Menu.multiplayer_joinname = quake_Menu.multiplayer_joinname.substring(0,quake_Menu.multiplayer_joinname.length - 1);
			}
			return;
		}
		if(quake_Menu.multiplayer_cursor == 1) {
			if(quake_Menu.multiplayer_myname.length != 0) {
				quake_Menu.multiplayer_myname = quake_Menu.multiplayer_myname.substring(0,quake_Menu.multiplayer_myname.length - 1);
			}
		}
		return;
	case 128:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(--quake_Menu.multiplayer_cursor < 0) {
			quake_Menu.multiplayer_cursor = 4;
		}
		return;
	case 129:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(++quake_Menu.multiplayer_cursor >= 5) {
			quake_Menu.multiplayer_cursor = 0;
		}
		return;
	case 130:
		if(quake_Menu.multiplayer_cursor == 2) {
			if(--quake_Menu.multiplayer_top < 0) {
				quake_Menu.multiplayer_top = 13;
			}
			quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu3,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		} else if(quake_Menu.multiplayer_cursor == 3) {
			if(--quake_Menu.multiplayer_bottom < 0) {
				quake_Menu.multiplayer_bottom = 13;
			}
			quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu3,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		}
		return;
	case 131:
		if(quake_Menu.multiplayer_cursor == 2) {
			if(quake_Menu.multiplayer_top <= 12) {
				++quake_Menu.multiplayer_top;
			} else {
				quake_Menu.multiplayer_top = 0;
			}
		} else if(quake_Menu.multiplayer_cursor == 3) {
			if(quake_Menu.multiplayer_bottom <= 12) {
				++quake_Menu.multiplayer_bottom;
			} else {
				quake_Menu.multiplayer_bottom = 0;
			}
		} else {
			return;
		}
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu3,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		return;
	default:
	}
	if(k < 32 || k > 127) {
		return;
	}
	if(quake_Menu.multiplayer_cursor == 0) {
		quake_Menu.multiplayer_joinname += String.fromCodePoint(k);
		return;
	}
	if(quake_Menu.multiplayer_cursor == 1) {
		if(quake_Menu.multiplayer_myname.length <= 14) {
			quake_Menu.multiplayer_myname += String.fromCodePoint(k);
		}
	}
};
quake_Menu.Menu_Options_f = function() {
	quake_Key.dest = 3;
	quake_Menu.state = 6;
	quake_Menu.entersound = true;
};
quake_Menu.AdjustSliders = function(dir) {
	quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu3,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
	switch(quake_Menu.options_cursor) {
	case 3:
		quake_SCR.viewsize.value += dir * 10;
		if(quake_SCR.viewsize.value < 30) {
			quake_SCR.viewsize.value = 30;
		} else if(quake_SCR.viewsize.value > 120) {
			quake_SCR.viewsize.value = 120;
		}
		quake_SCR.viewsize.setValue(quake_SCR.viewsize.value);
		return;
	case 4:
		quake_V.gamma.value -= dir * 0.05;
		if(quake_V.gamma.value < 0.5) {
			quake_V.gamma.value = 0.5;
		} else if(quake_V.gamma.value > 1.0) {
			quake_V.gamma.value = 1.0;
		}
		quake_V.gamma.setValue(quake_V.gamma.value);
		return;
	case 5:
		quake_CL.sensitivity.value += dir * 0.5;
		if(quake_CL.sensitivity.value < 1.0) {
			quake_CL.sensitivity.value = 1.0;
		} else if(quake_CL.sensitivity.value > 11.0) {
			quake_CL.sensitivity.value = 11.0;
		}
		quake_CL.sensitivity.setValue(quake_CL.sensitivity.value);
		return;
	case 6:
		quake_S.bgmvolume.value += dir * 0.1;
		if(quake_S.bgmvolume.value < 0.0) {
			quake_S.bgmvolume.value = 0.0;
		} else if(quake_S.bgmvolume.value > 1.0) {
			quake_S.bgmvolume.value = 1.0;
		}
		quake_S.bgmvolume.setValue(quake_S.bgmvolume.value);
		return;
	case 7:
		quake_S.volume.value += dir * 0.1;
		if(quake_S.volume.value < 0.0) {
			quake_S.volume.value = 0.0;
		} else if(quake_S.volume.value > 1.0) {
			quake_S.volume.value = 1.0;
		}
		quake_S.volume.setValue(quake_S.volume.value);
		return;
	case 8:
		if(quake_CL.forwardspeed.value > 200.0) {
			quake_CL.forwardspeed.setValue(200);
			quake_CL.backspeed.setValue(200);
			return;
		}
		quake_CL.forwardspeed.setValue(400);
		quake_CL.backspeed.setValue(400);
		return;
	case 9:
		quake_CL.m_pitch.setValue(-quake_CL.m_pitch.value);
		return;
	case 10:
		quake_CL.lookspring.setValue(quake_CL.lookspring.value != 0 ? 0 : 1);
		return;
	case 11:
		quake_CL.lookstrafe.setValue(quake_CL.lookstrafe.value != 0 ? 0 : 1);
		break;
	}
};
quake_Menu.DrawSlider = function(x,y,range) {
	if(range < 0) {
		range = 0;
	} else if(range > 1) {
		range = 1;
	}
	quake_Menu.DrawCharacter(x - 8,y,128);
	quake_Menu.DrawCharacter(x,y,129);
	quake_Menu.DrawCharacter(x + 8,y,129);
	quake_Menu.DrawCharacter(x + 16,y,129);
	quake_Menu.DrawCharacter(x + 24,y,129);
	quake_Menu.DrawCharacter(x + 32,y,129);
	quake_Menu.DrawCharacter(x + 40,y,129);
	quake_Menu.DrawCharacter(x + 48,y,129);
	quake_Menu.DrawCharacter(x + 56,y,129);
	quake_Menu.DrawCharacter(x + 64,y,129);
	quake_Menu.DrawCharacter(x + 72,y,129);
	quake_Menu.DrawCharacter(x + 80,y,130);
	quake_Menu.DrawCharacter(x + Math.floor(72 * range),y,131);
};
quake_Menu.Options_Draw = function() {
	quake_Menu.DrawPic(16,4,quake_Menu.qplaque);
	quake_Menu.DrawPic(160 - (quake_Menu.p_option.width >> 1),4,quake_Menu.p_option);
	quake_Menu.Print(48,32,"Customize controls");
	quake_Menu.Print(88,40,"Go to console");
	quake_Menu.Print(56,48,"Reset to defaults");
	quake_Menu.Print(104,56,"Screen size");
	quake_Menu.DrawSlider(220,56,(quake_SCR.viewsize.value - 30) / 90);
	quake_Menu.Print(112,64,"Brightness");
	quake_Menu.DrawSlider(220,64,(1.0 - quake_V.gamma.value) * 2.0);
	quake_Menu.Print(104,72,"Mouse Speed");
	quake_Menu.DrawSlider(220,72,(quake_CL.sensitivity.value - 1) / 10);
	quake_Menu.Print(72,80,"CD Music Volume");
	quake_Menu.DrawSlider(220,80,quake_S.bgmvolume.value);
	quake_Menu.Print(96,88,"Sound Volume");
	quake_Menu.DrawSlider(220,88,quake_S.volume.value);
	quake_Menu.Print(112,96,"Always Run");
	quake_Menu.Print(220,96,quake_CL.forwardspeed.value > 200.0 ? "on" : "off");
	quake_Menu.Print(96,104,"Invert Mouse");
	quake_Menu.Print(220,104,quake_CL.m_pitch.value < 0.0 ? "on" : "off");
	quake_Menu.Print(112,112,"Lookspring");
	quake_Menu.Print(220,112,quake_CL.lookspring.value != 0 ? "on" : "off");
	quake_Menu.Print(112,120,"Lookstrafe");
	quake_Menu.Print(220,120,quake_CL.lookstrafe.value != 0 ? "on" : "off");
	quake_Menu.DrawCharacter(200,32 + (quake_Menu.options_cursor << 3),12 + ((quake_Host.realtime * 4 | 0) & 1));
};
quake_Menu.Options_Key = function(k) {
	switch(k) {
	case 13:
		quake_Menu.entersound = true;
		switch(quake_Menu.options_cursor) {
		case 0:
			quake_Menu.Menu_Keys_f();
			return;
		case 1:
			quake_Menu.state = 0;
			quake_Console.ToggleConsole_f();
			return;
		case 2:
			quake_Cmd.text += "exec default.cfg\n";
			return;
		default:
			quake_Menu.AdjustSliders(1);
		}
		return;
	case 27:
		quake_Menu.Menu_Main_f();
		return;
	case 128:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(--quake_Menu.options_cursor < 0) {
			quake_Menu.options_cursor = 11;
		}
		return;
	case 129:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(++quake_Menu.options_cursor >= 12) {
			quake_Menu.options_cursor = 0;
		}
		return;
	case 130:
		quake_Menu.AdjustSliders(-1);
		return;
	case 131:
		quake_Menu.AdjustSliders(1);
		break;
	default:
	}
};
quake_Menu.Menu_Keys_f = function() {
	quake_Key.dest = 3;
	quake_Menu.state = 7;
	quake_Menu.entersound = true;
};
quake_Menu.FindKeysForCommand = function(command) {
	var twokeys = [];
	var _g = 0;
	var _g1 = quake_Key.bindings.length;
	while(_g < _g1) {
		var i = _g++;
		if(quake_Key.bindings[i] == command) {
			twokeys.push(i);
			if(twokeys.length == 2) {
				return twokeys;
			}
		}
	}
	return twokeys;
};
quake_Menu.UnbindCommand = function(command) {
	var _g = 0;
	var _g1 = quake_Key.bindings.length;
	while(_g < _g1) {
		var i = _g++;
		if(quake_Key.bindings[i] == command) {
			quake_Key.bindings[i] = null;
		}
	}
};
quake_Menu.Keys_Draw = function() {
	quake_Menu.DrawPic(160 - (quake_Menu.ttl_cstm.width >> 1),4,quake_Menu.ttl_cstm);
	if(quake_Menu.bind_grab) {
		quake_Menu.Print(12,32,"Press a key or button for this action");
		quake_Menu.DrawCharacter(130,48 + (quake_Menu.keys_cursor << 3),61);
	} else {
		quake_Menu.Print(18,32,"Enter to change, backspace to clear");
		quake_Menu.DrawCharacter(130,48 + (quake_Menu.keys_cursor << 3),12 + ((quake_Host.realtime * 4 | 0) & 1));
	}
	var y = 48;
	var _g = 0;
	var _g1 = quake_Menu.bindnames.length;
	while(_g < _g1) {
		var i = _g++;
		quake_Menu.Print(16,y,quake_Menu.bindnames[i][1]);
		var keys = quake_Menu.FindKeysForCommand(quake_Menu.bindnames[i][0]);
		if(keys[0] == null) {
			quake_Menu.Print(140,y,"???");
		} else {
			var name = quake_Key.KeynumToString(keys[0]);
			if(keys[1] != null) {
				name += " or " + quake_Key.KeynumToString(keys[1]);
			}
			quake_Menu.Print(140,y,name);
		}
		y += 8;
	}
};
quake_Menu.Keys_Key = function(k) {
	if(quake_Menu.bind_grab) {
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(k != 27 && k != 96) {
			quake_Cmd.text = "bind \"" + quake_Key.KeynumToString(k) + "\" \"" + quake_Menu.bindnames[quake_Menu.keys_cursor][0] + "\"\n" + quake_Cmd.text;
		}
		quake_Menu.bind_grab = false;
		return;
	}
	switch(k) {
	case 13:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu2,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(quake_Menu.FindKeysForCommand(quake_Menu.bindnames[quake_Menu.keys_cursor][0])[1] != null) {
			quake_Menu.UnbindCommand(quake_Menu.bindnames[quake_Menu.keys_cursor][0]);
		}
		quake_Menu.bind_grab = true;
		break;
	case 27:
		quake_Menu.Menu_Options_f();
		break;
	case 127:case 148:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu2,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		quake_Menu.UnbindCommand(quake_Menu.bindnames[quake_Menu.keys_cursor][0]);
		break;
	case 129:case 131:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(++quake_Menu.keys_cursor >= quake_Menu.bindnames.length) {
			quake_Menu.keys_cursor = 0;
		}
		break;
	case 128:case 130:
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu1,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		if(--quake_Menu.keys_cursor < 0) {
			quake_Menu.keys_cursor = quake_Menu.bindnames.length - 1;
		}
		break;
	default:
	}
};
quake_Menu.Menu_Help_f = function() {
	quake_Key.dest = 3;
	quake_Menu.state = 8;
	quake_Menu.entersound = true;
	quake_Menu.help_page = 0;
};
quake_Menu.Help_Draw = function() {
	quake_Menu.DrawPic(0,0,quake_Menu.help_pages[quake_Menu.help_page]);
};
quake_Menu.Help_Key = function(k) {
	switch(k) {
	case 27:
		quake_Menu.Menu_Main_f();
		return;
	case 128:
		break;
	case 129:
		break;
	case 130:
		quake_Menu.entersound = true;
		if(--quake_Menu.help_page < 0) {
			quake_Menu.help_page = 5;
		}
		break;
	case 131:
		quake_Menu.entersound = true;
		if(++quake_Menu.help_page >= 6) {
			quake_Menu.help_page = 0;
		}
		return;
	default:
	}
};
quake_Menu.Menu_Quit_f = function() {
	if(quake_Menu.state == 9) {
		return;
	}
	quake_Menu.wasInMenus = quake_Key.dest == 3;
	quake_Key.dest = 3;
	quake_Menu.quit_prevstate = quake_Menu.state;
	quake_Menu.state = 9;
	quake_Menu.entersound = true;
	quake_Menu.msgNumber = Math.floor(Math.random() * quake_Menu.quitMessage.length);
};
quake_Menu.Quit_Draw = function() {
	if(quake_Menu.wasInMenus) {
		quake_Menu.state = quake_Menu.quit_prevstate;
		quake_Menu.recursiveDraw = true;
		quake_Menu.DrawMenu();
		quake_Menu.state = 9;
	}
	quake_Menu.DrawTextBox(56,76,24,4);
	quake_Menu.Print(64,84,quake_Menu.quitMessage[quake_Menu.msgNumber][0]);
	quake_Menu.Print(64,92,quake_Menu.quitMessage[quake_Menu.msgNumber][1]);
	quake_Menu.Print(64,100,quake_Menu.quitMessage[quake_Menu.msgNumber][2]);
	quake_Menu.Print(64,108,quake_Menu.quitMessage[quake_Menu.msgNumber][3]);
};
quake_Menu.Quit_Key = function(k) {
	switch(k) {
	case 27:case 110:
		if(quake_Menu.wasInMenus) {
			quake_Menu.state = quake_Menu.quit_prevstate;
			quake_Menu.entersound = true;
		} else {
			quake_Key.dest = 0;
			quake_Menu.state = 0;
		}
		break;
	case 121:
		quake_Key.dest = 1;
		quake_Host.Quit_f();
		break;
	default:
	}
};
quake_Menu.Init = function() {
	quake_Cmd.AddCommand("togglemenu",quake_Menu.ToggleMenu_f);
	quake_Cmd.AddCommand("menu_main",quake_Menu.Menu_Main_f);
	quake_Cmd.AddCommand("menu_singleplayer",quake_Menu.Menu_SinglePlayer_f);
	quake_Cmd.AddCommand("menu_load",quake_Menu.Menu_Load_f);
	quake_Cmd.AddCommand("menu_save",quake_Menu.Menu_Save_f);
	quake_Cmd.AddCommand("menu_multiplayer",quake_Menu.Menu_MultiPlayer_f);
	quake_Cmd.AddCommand("menu_setup",quake_Menu.Menu_MultiPlayer_f);
	quake_Cmd.AddCommand("menu_options",quake_Menu.Menu_Options_f);
	quake_Cmd.AddCommand("menu_keys",quake_Menu.Menu_Keys_f);
	quake_Cmd.AddCommand("help",quake_Menu.Menu_Help_f);
	quake_Cmd.AddCommand("menu_quit",quake_Menu.Menu_Quit_f);
	quake_Menu.sfx_menu1 = quake_S.PrecacheSound("misc/menu1.wav");
	quake_Menu.sfx_menu2 = quake_S.PrecacheSound("misc/menu2.wav");
	quake_Menu.sfx_menu3 = quake_S.PrecacheSound("misc/menu3.wav");
	quake_Menu.box_tl = quake_Draw.CachePic("box_tl");
	quake_Menu.box_ml = quake_Draw.CachePic("box_ml");
	quake_Menu.box_bl = quake_Draw.CachePic("box_bl");
	quake_Menu.box_tm = quake_Draw.CachePic("box_tm");
	quake_Menu.box_mm = quake_Draw.CachePic("box_mm");
	quake_Menu.box_mm2 = quake_Draw.CachePic("box_mm2");
	quake_Menu.box_bm = quake_Draw.CachePic("box_bm");
	quake_Menu.box_tr = quake_Draw.CachePic("box_tr");
	quake_Menu.box_mr = quake_Draw.CachePic("box_mr");
	quake_Menu.box_br = quake_Draw.CachePic("box_br");
	quake_Menu.qplaque = quake_Draw.CachePic("qplaque");
	quake_Menu.menudot = [quake_Draw.CachePic("menudot1"),quake_Draw.CachePic("menudot2"),quake_Draw.CachePic("menudot3"),quake_Draw.CachePic("menudot4"),quake_Draw.CachePic("menudot5"),quake_Draw.CachePic("menudot6")];
	quake_Menu.ttl_main = quake_Draw.CachePic("ttl_main");
	quake_Menu.mainmenu = quake_Draw.CachePic("mainmenu");
	quake_Menu.ttl_sgl = quake_Draw.CachePic("ttl_sgl");
	quake_Menu.sp_menu = quake_Draw.CachePic("sp_menu");
	quake_Menu.p_load = quake_Draw.CachePic("p_load");
	quake_Menu.p_save = quake_Draw.CachePic("p_save");
	quake_Menu.p_multi = quake_Draw.CachePic("p_multi");
	quake_Menu.bigbox = quake_Draw.CachePic("bigbox");
	quake_Menu.menuplyr = quake_Draw.CachePic("menuplyr");
	quake_COM.LoadFile("gfx/menuplyr.lmp");
	var data = quake_GL.ResampleTexture(quake_Menu.menuplyr.data,quake_Menu.menuplyr.width,quake_Menu.menuplyr.height,64,64);
	var trans = new Uint8Array(new ArrayBuffer(16384));
	var _g = 0;
	while(_g < 4096) {
		var i = _g++;
		var p = data[i];
		if(p >> 4 == 1) {
			trans[i << 2] = (p & 15) * 17;
			trans[(i << 2) + 1] = 255;
		} else if(p >> 4 == 6) {
			trans[(i << 2) + 2] = (p & 15) * 17;
			trans[(i << 2) + 3] = 255;
		}
	}
	quake_Menu.menuplyr.translate = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Menu.menuplyr.translate);
	quake_GL.gl.texImage2D(3553,0,6408,64,64,0,6408,5121,trans);
	quake_GL.gl.texParameterf(3553,10241,9729);
	quake_GL.gl.texParameterf(3553,10240,9729);
	quake_Menu.p_option = quake_Draw.CachePic("p_option");
	quake_Menu.ttl_cstm = quake_Draw.CachePic("ttl_cstm");
	quake_Menu.help_pages = [quake_Draw.CachePic("help0"),quake_Draw.CachePic("help1"),quake_Draw.CachePic("help2"),quake_Draw.CachePic("help3"),quake_Draw.CachePic("help4"),quake_Draw.CachePic("help5")];
};
quake_Menu.DrawMenu = function() {
	if(quake_Menu.state == 0 || quake_Key.dest != 3) {
		return;
	}
	if(!quake_Menu.recursiveDraw) {
		if(quake_SCR.con_current != 0) {
			quake_Draw.ConsoleBackground(quake_VID.height);
		} else {
			quake_Draw.FadeScreen();
		}
	} else {
		quake_Menu.recursiveDraw = false;
	}
	switch(quake_Menu.state) {
	case 0:
		break;
	case 1:
		quake_Menu.Main_Draw();
		break;
	case 2:
		quake_Menu.SinglePlayer_Draw();
		break;
	case 3:
		quake_Menu.Load_Draw();
		break;
	case 4:
		quake_Menu.Save_Draw();
		break;
	case 5:
		quake_Menu.MultiPlayer_Draw();
		break;
	case 6:
		quake_Menu.Options_Draw();
		break;
	case 7:
		quake_Menu.Keys_Draw();
		break;
	case 8:
		quake_Menu.Help_Draw();
		break;
	case 9:
		quake_Menu.Quit_Draw();
		break;
	}
	if(quake_Menu.entersound) {
		quake_S.StartSound(quake_CL.state.viewentity,-1,quake_Menu.sfx_menu2,quake__$Vec_Vec_$Impl_$.origin,1.0,1.0);
		quake_Menu.entersound = false;
	}
};
quake_Menu.Keydown = function(key) {
	switch(quake_Menu.state) {
	case 0:
		break;
	case 1:
		quake_Menu.Main_Key(key);
		break;
	case 2:
		quake_Menu.SinglePlayer_Key(key);
		break;
	case 3:
		quake_Menu.Load_Key(key);
		break;
	case 4:
		quake_Menu.Save_Key(key);
		break;
	case 5:
		quake_Menu.MultiPlayer_Key(key);
		break;
	case 6:
		quake_Menu.Options_Key(key);
		break;
	case 7:
		quake_Menu.Keys_Key(key);
		break;
	case 8:
		quake_Menu.Help_Key(key);
		break;
	case 9:
		quake_Menu.Quit_Key(key);
		break;
	}
};
var quake_MModel = function(name) {
	this.name = name;
	this.needload = true;
};
quake_MModel.__name__ = true;
var quake_MFrame = function(g) {
	this.group = g;
};
quake_MFrame.__name__ = true;
var quake_Mod = function() { };
quake_Mod.__name__ = true;
quake_Mod.Init = function() {
	quake_Mod_$Brush.Init();
	quake_Mod_$Alias.Init();
};
quake_Mod.ClearAll = function() {
	var _g = 0;
	var _g1 = quake_Mod.known.length;
	while(_g < _g1) {
		var i = _g++;
		var mod = quake_Mod.known[i];
		if(mod.type != 0) {
			continue;
		}
		if(mod.cmds != null) {
			quake_GL.gl.deleteBuffer(mod.cmds);
		}
		quake_Mod.known[i] = new quake_MModel(mod.name);
	}
};
quake_Mod.FindName = function(name) {
	if(name.length == 0) {
		quake_Sys.Error("Mod.FindName: NULL name");
	}
	var _g = 0;
	var _g1 = quake_Mod.known;
	while(_g < _g1.length) {
		var mod = _g1[_g];
		++_g;
		if(mod == null) {
			continue;
		}
		if(mod.name == name) {
			return mod;
		}
	}
	var _g2 = 0;
	var _g3 = quake_Mod.known.length + 1;
	while(_g2 < _g3) {
		var i = _g2++;
		if(quake_Mod.known[i] != null) {
			continue;
		}
		return quake_Mod.known[i] = new quake_MModel(name);
	}
	return null;
};
quake_Mod.LoadModel = function(mod,crash) {
	if(!mod.needload) {
		return mod;
	}
	var buf = quake_COM.LoadFile(mod.name);
	if(buf == null) {
		if(crash) {
			quake_Sys.Error("Mod.LoadModel: " + mod.name + " not found");
		}
		return null;
	}
	mod.needload = false;
	var view = new DataView(buf);
	switch(view.getUint32(0,true)) {
	case 1330660425:
		quake_Mod_$Alias.LoadAliasModel(mod,view);
		break;
	case 1347634249:
		quake_Mod_$Sprite.LoadSpriteModel(mod,view);
		break;
	default:
		quake_Mod_$Brush.LoadBrushModel(mod,view);
	}
	return mod;
};
quake_Mod.Print = function() {
	quake_Console.Print("Cached models:\n");
	var _g = 0;
	var _g1 = quake_Mod.known;
	while(_g < _g1.length) quake_Console.Print(_g1[_g++].name + "\n");
};
var quake__$Mod_$Alias_STVert = function(onseam,s,t) {
	this.onseam = onseam;
	this.s = s;
	this.t = t;
};
quake__$Mod_$Alias_STVert.__name__ = true;
var quake__$Mod_$Alias_Triangle = function(facesfront,vertindex) {
	this.facesfront = facesfront;
	this.vertindex = vertindex;
};
quake__$Mod_$Alias_Triangle.__name__ = true;
var quake_Trivert = function(v,lightnormalindex) {
	this.v = v;
	this.lightnormalindex = lightnormalindex;
};
quake_Trivert.__name__ = true;
var quake_Skin = function(g) {
	this.group = g;
};
quake_Skin.__name__ = true;
var quake_Mod_$Alias = function() { };
quake_Mod_$Alias.__name__ = true;
quake_Mod_$Alias.Init = function() {
	quake_Mod_$Alias.filledcolor = 0;
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		if(quake_VID.d_8to24table[i] == 0) {
			quake_Mod_$Alias.filledcolor = i;
			break;
		}
	}
};
quake_Mod_$Alias.LoadAliasModel = function(loadmodel,model) {
	var version = model.getUint32(4,true);
	if(version != 6) {
		quake_Sys.Error(loadmodel.name + " has wrong version number (" + version + " should be " + 6 + ")");
	}
	loadmodel.type = 2;
	loadmodel.player = loadmodel.name == "progs/player.mdl";
	var x = model.getFloat32(8,true);
	var y = model.getFloat32(12,true);
	var z = model.getFloat32(16,true);
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	loadmodel.scale = v;
	var x1 = model.getFloat32(20,true);
	var y1 = model.getFloat32(24,true);
	var z1 = model.getFloat32(28,true);
	var v1 = new Float32Array(3);
	v1[0] = x1;
	v1[1] = y1;
	v1[2] = z1;
	loadmodel.scale_origin = v1;
	loadmodel.boundingradius = model.getFloat32(32,true);
	loadmodel.numskins = model.getUint32(48,true);
	if(loadmodel.numskins == 0) {
		quake_Sys.Error("model " + loadmodel.name + " has no skins");
	}
	loadmodel.skinwidth = model.getUint32(52,true);
	loadmodel.skinheight = model.getUint32(56,true);
	loadmodel.numverts = model.getUint32(60,true);
	if(loadmodel.numverts == 0) {
		quake_Sys.Error("model " + loadmodel.name + " has no vertices");
	}
	loadmodel.numtris = model.getUint32(64,true);
	if(loadmodel.numtris == 0) {
		quake_Sys.Error("model " + loadmodel.name + " has no triangles");
	}
	loadmodel.numframes = model.getUint32(68,true);
	if(loadmodel.numframes == 0) {
		quake_Sys.Error("model " + loadmodel.name + " has no frames");
	}
	loadmodel.random = model.getUint32(72,true) == 1;
	loadmodel.flags = model.getUint32(76,true);
	var v2 = new Float32Array(3);
	v2[0] = -16.0;
	v2[1] = -16.0;
	v2[2] = -16.0;
	loadmodel.mins = v2;
	var v3 = new Float32Array(3);
	v3[0] = 16.0;
	v3[1] = 16.0;
	v3[2] = 16.0;
	loadmodel.maxs = v3;
	var inmodel = quake_Mod_$Alias.LoadAllSkins(loadmodel,model,84);
	var stverts = [];
	var _g = 0;
	var _g1 = loadmodel.numverts;
	while(_g < _g1) {
		++_g;
		stverts.push(new quake__$Mod_$Alias_STVert(model.getUint32(inmodel,true) != 0,model.getUint32(inmodel + 4,true),model.getUint32(inmodel + 8,true)));
		inmodel += 12;
	}
	var triangles = [];
	var _g2 = 0;
	var _g3 = loadmodel.numtris;
	while(_g2 < _g3) {
		++_g2;
		triangles.push(new quake__$Mod_$Alias_Triangle(model.getUint32(inmodel,true) != 0,[model.getUint32(inmodel + 4,true),model.getUint32(inmodel + 8,true),model.getUint32(inmodel + 12,true)]));
		inmodel += 16;
	}
	quake_Mod_$Alias.LoadAllFrames(loadmodel,model,inmodel);
	var cmds = [];
	var _g4 = 0;
	var _g5 = loadmodel.numtris;
	while(_g4 < _g5) {
		var triangle = triangles[_g4++];
		if(triangle.facesfront) {
			var vert = stverts[triangle.vertindex[0]];
			cmds.push((vert.s + 0.5) / loadmodel.skinwidth);
			cmds.push((vert.t + 0.5) / loadmodel.skinheight);
			vert = stverts[triangle.vertindex[1]];
			cmds.push((vert.s + 0.5) / loadmodel.skinwidth);
			cmds.push((vert.t + 0.5) / loadmodel.skinheight);
			vert = stverts[triangle.vertindex[2]];
			cmds.push((vert.s + 0.5) / loadmodel.skinwidth);
			cmds.push((vert.t + 0.5) / loadmodel.skinheight);
			continue;
		}
		var vert1 = stverts[triangle.vertindex[0]];
		if(vert1.onseam) {
			cmds.push((vert1.s + loadmodel.skinwidth / 2 + 0.5) / loadmodel.skinwidth);
		} else {
			cmds.push((vert1.s + 0.5) / loadmodel.skinwidth);
		}
		cmds.push((vert1.t + 0.5) / loadmodel.skinheight);
		var vert2 = stverts[triangle.vertindex[1]];
		if(vert2.onseam) {
			cmds.push((vert2.s + loadmodel.skinwidth / 2 + 0.5) / loadmodel.skinwidth);
		} else {
			cmds.push((vert2.s + 0.5) / loadmodel.skinwidth);
		}
		cmds.push((vert2.t + 0.5) / loadmodel.skinheight);
		var vert3 = stverts[triangle.vertindex[2]];
		if(vert3.onseam) {
			cmds.push((vert3.s + loadmodel.skinwidth / 2 + 0.5) / loadmodel.skinwidth);
		} else {
			cmds.push((vert3.s + 0.5) / loadmodel.skinwidth);
		}
		cmds.push((vert3.t + 0.5) / loadmodel.skinheight);
	}
	var group;
	var frame;
	var _g6 = 0;
	var _g7 = loadmodel.numframes;
	while(_g6 < _g7) {
		group = loadmodel.frames[_g6++];
		if(group.group) {
			var _g61 = 0;
			var _g71 = group.frames.length;
			while(_g61 < _g71) {
				frame = group.frames[_g61++];
				frame.cmdofs = cmds.length << 2;
				var _g62 = 0;
				var _g72 = loadmodel.numtris;
				while(_g62 < _g72) {
					var triangle1 = triangles[_g62++];
					var _g63 = 0;
					while(_g63 < 3) {
						var vert4 = frame.v[triangle1.vertindex[_g63++]];
						if(vert4.lightnormalindex >= 162) {
							quake_Sys.Error("lightnormalindex >= NUMVERTEXNORMALS");
						}
						cmds.push(vert4.v[0] * loadmodel.scale[0] + loadmodel.scale_origin[0]);
						cmds.push(vert4.v[1] * loadmodel.scale[1] + loadmodel.scale_origin[1]);
						cmds.push(vert4.v[2] * loadmodel.scale[2] + loadmodel.scale_origin[2]);
						cmds.push(quake_Render.avertexnormals[vert4.lightnormalindex * 3]);
						cmds.push(quake_Render.avertexnormals[vert4.lightnormalindex * 3 + 1]);
						cmds.push(quake_Render.avertexnormals[vert4.lightnormalindex * 3 + 2]);
					}
				}
			}
			continue;
		}
		frame = group;
		group.cmdofs = cmds.length << 2;
		var _g64 = 0;
		var _g73 = loadmodel.numtris;
		while(_g64 < _g73) {
			var triangle2 = triangles[_g64++];
			var _g65 = 0;
			while(_g65 < 3) {
				var vert5 = group.v[triangle2.vertindex[_g65++]];
				if(vert5.lightnormalindex >= 162) {
					quake_Sys.Error("lightnormalindex >= NUMVERTEXNORMALS");
				}
				cmds.push(vert5.v[0] * loadmodel.scale[0] + loadmodel.scale_origin[0]);
				cmds.push(vert5.v[1] * loadmodel.scale[1] + loadmodel.scale_origin[1]);
				cmds.push(vert5.v[2] * loadmodel.scale[2] + loadmodel.scale_origin[2]);
				cmds.push(quake_Render.avertexnormals[vert5.lightnormalindex * 3]);
				cmds.push(quake_Render.avertexnormals[vert5.lightnormalindex * 3 + 1]);
				cmds.push(quake_Render.avertexnormals[vert5.lightnormalindex * 3 + 2]);
			}
		}
	}
	loadmodel.cmds = quake_GL.gl.createBuffer();
	quake_GL.gl.bindBuffer(34962,loadmodel.cmds);
	quake_GL.gl.bufferData(34962,new Float32Array(cmds),35044);
};
quake_Mod_$Alias.LoadAllSkins = function(loadmodel,model,inmodel) {
	loadmodel.skins = [];
	var skinsize = loadmodel.skinwidth * loadmodel.skinheight;
	var _g = 0;
	var _g1 = loadmodel.numskins;
	while(_g < _g1) {
		var i = _g++;
		inmodel += 4;
		if(model.getUint32(inmodel - 4,true) == 0) {
			var skin = new Uint8Array(model.buffer,inmodel,skinsize);
			quake_Mod_$Alias.FloodFillSkin(loadmodel,skin);
			var g = new quake_Skin(false);
			g.texturenum = quake_GL.LoadTexture(loadmodel.name + "_" + i,loadmodel.skinwidth,loadmodel.skinheight,skin);
			loadmodel.skins[i] = g;
			if(loadmodel.player) {
				quake_Mod_$Alias.TranslatePlayerSkin(loadmodel,new Uint8Array(model.buffer,inmodel,skinsize),loadmodel.skins[i]);
			}
			inmodel += skinsize;
		} else {
			var group = new quake_Skin(true);
			var numskins = model.getUint32(inmodel,true);
			inmodel += 4;
			var _g2 = 0;
			while(_g2 < numskins) {
				var j = _g2++;
				var s = new quake_Skin(false);
				s.interval = model.getFloat32(inmodel,true);
				if(s.interval <= 0.0) {
					quake_Sys.Error("Mod.LoadAllSkins: interval<=0");
				}
				group.skins[j] = s;
				inmodel += 4;
			}
			var _g21 = 0;
			while(_g21 < numskins) {
				var j1 = _g21++;
				var skin1 = new Uint8Array(model.buffer,inmodel,skinsize);
				quake_Mod_$Alias.FloodFillSkin(loadmodel,skin1);
				group.skins[j1].texturenum = quake_GL.LoadTexture(loadmodel.name + "_" + i + "_" + j1,loadmodel.skinwidth,loadmodel.skinheight,skin1);
				if(loadmodel.player) {
					quake_Mod_$Alias.TranslatePlayerSkin(loadmodel,new Uint8Array(model.buffer,inmodel,skinsize),group.skins[j1]);
				}
				inmodel += skinsize;
			}
			loadmodel.skins[i] = group;
		}
	}
	return inmodel;
};
quake_Mod_$Alias.LoadAllFrames = function(loadmodel,model,inmodel) {
	loadmodel.frames = [];
	var _g = 0;
	var _g1 = loadmodel.numframes;
	while(_g < _g1) {
		var i = _g++;
		inmodel += 4;
		if(model.getUint32(inmodel - 4,true) == 0) {
			var frame = new quake_MFrame(false);
			frame.group = false;
			frame.bboxmin = [model.getUint8(inmodel),model.getUint8(inmodel + 1),model.getUint8(inmodel + 2)];
			frame.bboxmax = [model.getUint8(inmodel + 4),model.getUint8(inmodel + 5),model.getUint8(inmodel + 6)];
			frame.name = quake_Q.memstr(new Uint8Array(model.buffer,inmodel + 8,16));
			frame.v = [];
			inmodel += 24;
			var _g2 = 0;
			var _g11 = loadmodel.numverts;
			while(_g2 < _g11) {
				frame.v[_g2++] = new quake_Trivert([model.getUint8(inmodel),model.getUint8(inmodel + 1),model.getUint8(inmodel + 2)],model.getUint8(inmodel + 3));
				inmodel += 4;
			}
			loadmodel.frames[i] = frame;
		} else {
			var group = new quake_MFrame(true);
			group.bboxmin = [model.getUint8(inmodel + 4),model.getUint8(inmodel + 5),model.getUint8(inmodel + 6)];
			group.bboxmax = [model.getUint8(inmodel + 8),model.getUint8(inmodel + 9),model.getUint8(inmodel + 10)];
			group.frames = [];
			var numframes = model.getUint32(inmodel,true);
			inmodel += 12;
			var _g3 = 0;
			while(_g3 < numframes) {
				var j = _g3++;
				var f = new quake_MFrame(false);
				f.interval = model.getFloat32(inmodel,true);
				group.frames[j] = f;
				if(group.frames[j].interval <= 0.0) {
					quake_Sys.Error("Mod.LoadAllFrames: interval<=0");
				}
				inmodel += 4;
			}
			var _g21 = 0;
			while(_g21 < numframes) {
				var frame1 = group.frames[_g21++];
				frame1.bboxmin = [model.getUint8(inmodel),model.getUint8(inmodel + 1),model.getUint8(inmodel + 2)];
				frame1.bboxmax = [model.getUint8(inmodel + 4),model.getUint8(inmodel + 5),model.getUint8(inmodel + 6)];
				frame1.name = quake_Q.memstr(new Uint8Array(model.buffer,inmodel + 8,16));
				frame1.v = [];
				inmodel += 24;
				var _g22 = 0;
				var _g31 = loadmodel.numverts;
				while(_g22 < _g31) {
					frame1.v[_g22++] = new quake_Trivert([model.getUint8(inmodel),model.getUint8(inmodel + 1),model.getUint8(inmodel + 2)],model.getUint8(inmodel + 3));
					inmodel += 4;
				}
			}
			loadmodel.frames[i] = group;
		}
	}
};
quake_Mod_$Alias.FloodFillSkin = function(loadmodel,skin) {
	var fillcolor = skin[0];
	if(fillcolor == quake_Mod_$Alias.filledcolor) {
		return;
	}
	var width = loadmodel.skinwidth;
	var height = loadmodel.skinheight;
	var lifo = [[0,0]];
	var sp = 1;
	while(sp > 0) {
		var cur = lifo[--sp];
		var x = cur[0];
		var y = cur[1];
		skin[y * width + x] = quake_Mod_$Alias.filledcolor;
		if(x > 0) {
			if(skin[y * width + x - 1] == fillcolor) {
				lifo[sp++] = [x - 1,y];
			}
		}
		if(x < width - 1) {
			if(skin[y * width + x + 1] == fillcolor) {
				lifo[sp++] = [x + 1,y];
			}
		}
		if(y > 0) {
			if(skin[(y - 1) * width + x] == fillcolor) {
				lifo[sp++] = [x,y - 1];
			}
		}
		if(y < height - 1) {
			if(skin[(y + 1) * width + x] == fillcolor) {
				lifo[sp++] = [x,y + 1];
			}
		}
	}
};
quake_Mod_$Alias.TranslatePlayerSkin = function(loadmodel,data,skin) {
	if(loadmodel.skinwidth != 512 || loadmodel.skinheight != 256) {
		data = quake_GL.ResampleTexture(data,loadmodel.skinwidth,loadmodel.skinheight,512,256);
	}
	var out = new Uint8Array(new ArrayBuffer(524288));
	var _g = 0;
	while(_g < 131072) {
		var i = _g++;
		var original = data[i];
		if(original >> 4 == 1) {
			out[i << 2] = (original & 15) * 17;
			out[(i << 2) + 1] = 255;
		} else if(original >> 4 == 6) {
			out[(i << 2) + 2] = (original & 15) * 17;
			out[(i << 2) + 3] = 255;
		}
	}
	skin.playertexture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,skin.playertexture);
	quake_GL.gl.texImage2D(3553,0,6408,512,256,0,6408,5121,out);
	quake_GL.gl.generateMipmap(3553);
	quake_GL.gl.texParameteri(3553,10241,quake_GL.filter_min);
	quake_GL.gl.texParameteri(3553,10240,quake_GL.filter_max);
};
var quake_Hull = function() {
};
quake_Hull.__name__ = true;
var quake_ClipNode = function() {
};
quake_ClipNode.__name__ = true;
var quake_Surface = function() {
};
quake_Surface.__name__ = true;
var quake_Node = function() {
};
quake_Node.__name__ = true;
var quake_Leaf = function() {
	quake_Node.call(this);
};
quake_Leaf.__name__ = true;
quake_Leaf.__super__ = quake_Node;
quake_Leaf.prototype = $extend(quake_Node.prototype,{
});
var quake_Texinfo = function(v,t,f) {
	this.vecs = v;
	this.texture = t;
	this.flags = f;
};
quake_Texinfo.__name__ = true;
var quake_MTexture = function() {
};
quake_MTexture.__name__ = true;
var quake_Mod_$Brush = function() { };
quake_Mod_$Brush.__name__ = true;
quake_Mod_$Brush.Init = function() {
	quake_Mod_$Brush.novis = [];
	var _g = 0;
	while(_g < 1024) {
		++_g;
		quake_Mod_$Brush.novis.push(255);
	}
};
quake_Mod_$Brush.PointInLeaf = function(p,model) {
	if(model == null || model.nodes == null) {
		quake_Sys.Error("Mod.PointInLeaf: bad model");
	}
	var node = model.nodes[0];
	while(true) {
		if(node.contents < 0) {
			return node;
		}
		var plane = node.plane;
		var v2 = plane.normal;
		if(p[0] * v2[0] + p[1] * v2[1] + p[2] * v2[2] - plane.dist > 0) {
			node = node.child0;
		} else {
			node = node.child1;
		}
	}
};
quake_Mod_$Brush.LeafPVS = function(leaf,model) {
	if(leaf == model.leafs[0]) {
		return quake_Mod_$Brush.novis;
	}
	return quake_Mod_$Brush.DecompressVis(leaf.visofs,model);
};
quake_Mod_$Brush.DecompressVis = function(i,model) {
	var decompressed = [];
	var out = 0;
	var row = model.leafs.length + 7 >> 3;
	if(model.visdata == null) {
		while(row >= 0) {
			decompressed[out++] = 255;
			--row;
		}
		return decompressed;
	}
	var out1 = 0;
	while(out1 < row) {
		if(model.visdata[i] != 0) {
			decompressed[out1++] = model.visdata[i++];
			continue;
		}
		var c = model.visdata[i + 1];
		while(c > 0) {
			decompressed[out1++] = 0;
			--c;
		}
		i += 2;
	}
	return decompressed;
};
quake_Mod_$Brush.LoadBrushModel = function(loadmodel,data) {
	var version = data.getUint32(0,true);
	if(version != 29) {
		quake_Sys.Error("Mod.LoadBrushModel: " + loadmodel.name + " has wrong version number (" + version + " should be " + 29 + ")");
	}
	loadmodel.type = 0;
	quake_Mod_$Brush.LoadVertexes(loadmodel,data);
	quake_Mod_$Brush.LoadEdges(loadmodel,data);
	quake_Mod_$Brush.LoadSurfedges(loadmodel,data);
	quake_Mod_$Brush.LoadTextures(loadmodel,data);
	quake_Mod_$Brush.LoadLighting(loadmodel,data);
	quake_Mod_$Brush.LoadPlanes(loadmodel,data);
	quake_Mod_$Brush.LoadTexinfo(loadmodel,data);
	quake_Mod_$Brush.LoadFaces(loadmodel,data);
	quake_Mod_$Brush.LoadMarksurfaces(loadmodel,data);
	quake_Mod_$Brush.LoadVisibility(loadmodel,data);
	quake_Mod_$Brush.LoadLeafs(loadmodel,data);
	quake_Mod_$Brush.LoadNodes(loadmodel,data);
	quake_Mod_$Brush.LoadClipnodes(loadmodel,data);
	quake_Mod_$Brush.MakeHull0(loadmodel);
	quake_Mod_$Brush.LoadEntities(loadmodel,data);
	quake_Mod_$Brush.LoadSubmodels(loadmodel,data);
	var mins_0 = 0.0;
	var mins_1 = 0.0;
	var mins_2 = 0.0;
	var maxs_0 = 0.0;
	var maxs_1 = 0.0;
	var maxs_2 = 0.0;
	var _g = 0;
	var _g1 = loadmodel.vertexes;
	while(_g < _g1.length) {
		var vert = _g1[_g];
		++_g;
		if(vert[0] < mins_0) {
			mins_0 = vert[0];
		} else if(vert[0] > maxs_0) {
			maxs_0 = vert[0];
		}
		if(vert[1] < mins_1) {
			mins_1 = vert[1];
		} else if(vert[1] > maxs_1) {
			maxs_1 = vert[1];
		}
		if(vert[2] < mins_2) {
			mins_2 = vert[2];
		} else if(vert[2] > maxs_2) {
			maxs_2 = vert[2];
		}
	}
	var x = Math.max(Math.abs(mins_0),Math.abs(maxs_0));
	var y = Math.max(Math.abs(mins_1),Math.abs(maxs_1));
	var z = Math.max(Math.abs(mins_2),Math.abs(maxs_2));
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	loadmodel.radius = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
};
quake_Mod_$Brush.LoadVertexes = function(loadmodel,view) {
	var fileofs = view.getUint32(28,true);
	var filelen = view.getUint32(32,true);
	if(filelen % 12 != 0) {
		quake_Sys.Error("Mod.LoadVisibility: funny lump size in " + loadmodel.name);
	}
	var count = filelen / 12 | 0;
	loadmodel.vertexes = [];
	var _g = 0;
	while(_g < count) {
		var loadmodel1 = loadmodel.vertexes;
		var x = view.getFloat32(fileofs,true);
		var y = view.getFloat32(fileofs + 4,true);
		var z = view.getFloat32(fileofs + 8,true);
		var v = new Float32Array(3);
		v[0] = x;
		v[1] = y;
		v[2] = z;
		loadmodel1[_g++] = v;
		fileofs += 12;
	}
};
quake_Mod_$Brush.LoadEdges = function(loadmodel,view) {
	var fileofs = view.getUint32(100,true);
	var filelen = view.getUint32(104,true);
	if((filelen & 3) != 0) {
		quake_Sys.Error("Mod.LoadEdges: funny lump size in " + loadmodel.name);
	}
	var count = filelen >> 2;
	loadmodel.edges = [];
	var _g = 0;
	while(_g < count) {
		loadmodel.edges[_g++] = [view.getUint16(fileofs,true),view.getUint16(fileofs + 2,true)];
		fileofs += 4;
	}
};
quake_Mod_$Brush.LoadSurfedges = function(loadmodel,view) {
	var fileofs = view.getUint32(108,true);
	var count = view.getUint32(112,true) >> 2;
	loadmodel.surfedges = [];
	var _g = 0;
	while(_g < count) {
		var i = _g++;
		loadmodel.surfedges[i] = view.getInt32(fileofs + (i << 2),true);
	}
};
quake_Mod_$Brush.LoadTextures = function(loadmodel,view) {
	var fileofs = view.getUint32(20,true);
	loadmodel.textures = [];
	var nummiptex = view.getUint32(fileofs,true);
	var dataofs = fileofs + 4;
	var _g = 0;
	while(_g < nummiptex) {
		var i = _g++;
		var miptexofs = view.getInt32(dataofs,true);
		dataofs += 4;
		if(miptexofs == -1) {
			loadmodel.textures[i] = quake_Render.notexture_mip;
			continue;
		}
		miptexofs += fileofs;
		var tx = new quake_MTexture();
		tx.name = quake_Q.memstr(new Uint8Array(view.buffer,miptexofs,16));
		tx.width = view.getUint32(miptexofs + 16,true);
		tx.height = view.getUint32(miptexofs + 20,true);
		if(tx.name.substring(0,3).toLowerCase() == "sky") {
			quake_Render.InitSky(new Uint8Array(view.buffer,miptexofs + view.getUint32(miptexofs + 24,true),32768));
			tx.texturenum = quake_Render.solidskytexture;
			quake_Render.skytexturenum = i;
			tx.sky = true;
		} else {
			tx.texturenum = quake_GL.LoadTexture(tx.name,tx.width,tx.height,new Uint8Array(view.buffer,miptexofs + view.getUint32(miptexofs + 24,true),tx.width * tx.height)).texnum;
			if(HxOverrides.cca(tx.name,0) == 42) {
				tx.turbulent = true;
			}
		}
		loadmodel.textures[i] = tx;
	}
	var _g2 = 0;
	while(_g2 < nummiptex) {
		var i1 = _g2++;
		var tx1 = loadmodel.textures[i1];
		if(HxOverrides.cca(tx1.name,0) != 43) {
			continue;
		}
		if(HxOverrides.cca(tx1.name,1) != 48) {
			continue;
		}
		var name = tx1.name.substring(2);
		tx1.anims = [i1];
		tx1.alternate_anims = [];
		var _g21 = 0;
		while(_g21 < nummiptex) {
			var j = _g21++;
			var tx2 = loadmodel.textures[j];
			if(HxOverrides.cca(tx2.name,0) != 43) {
				continue;
			}
			if(tx2.name.substring(2) != name) {
				continue;
			}
			var num = HxOverrides.cca(tx2.name,1);
			if(num == 48) {
				continue;
			}
			if(num >= 49 && num <= 57) {
				tx1.anims[num - 48] = j;
				tx2.anim_base = i1;
				tx2.anim_frame = num - 48;
				continue;
			}
			if(num >= 97) {
				num -= 32;
			}
			if(num >= 65 && num <= 74) {
				tx1.alternate_anims[num - 65] = j;
				tx2.anim_base = i1;
				tx2.anim_frame = num - 65;
				continue;
			}
			quake_Sys.Error("Bad animating texture " + tx1.name);
		}
		var _g4 = 0;
		var _g5 = tx1.anims.length;
		while(_g4 < _g5) {
			var j1 = _g4++;
			if(tx1.anims[j1] == null) {
				quake_Sys.Error("Missing frame " + j1 + " of " + tx1.name);
			}
		}
		var _g6 = 0;
		var _g7 = tx1.alternate_anims.length;
		while(_g6 < _g7) {
			var j2 = _g6++;
			if(tx1.alternate_anims[j2] == null) {
				quake_Sys.Error("Missing frame " + j2 + " of " + tx1.name);
			}
		}
		loadmodel.textures[i1] = tx1;
	}
	loadmodel.textures.push(quake_Render.notexture_mip);
};
quake_Mod_$Brush.LoadLighting = function(loadmodel,view) {
	var fileofs = view.getUint32(68,true);
	var filelen = view.getUint32(72,true);
	if(filelen == 0) {
		return;
	}
	loadmodel.lightdata = new Uint8Array(view.buffer.slice(fileofs,fileofs + filelen));
};
quake_Mod_$Brush.LoadPlanes = function(loadmodel,view) {
	var fileofs = view.getUint32(12,true);
	var filelen = view.getUint32(16,true);
	if(filelen % 20 != 0) {
		quake_Sys.Error("Mod.LoadPlanes: funny lump size in " + loadmodel.name);
	}
	var count = filelen / 20 | 0;
	loadmodel.planes = [];
	var _g = 0;
	while(_g < count) {
		var i = _g++;
		var out = new quake_Plane();
		var this1 = out.normal;
		var y = view.getFloat32(fileofs + 4,true);
		var z = view.getFloat32(fileofs + 8,true);
		this1[0] = view.getFloat32(fileofs,true);
		this1[1] = y;
		this1[2] = z;
		out.dist = view.getFloat32(fileofs + 12,true);
		out.type = view.getUint32(fileofs + 16,true);
		out.signbits = 0;
		if(out.normal[0] < 0) {
			++out.signbits;
		}
		if(out.normal[1] < 0) {
			out.signbits += 2;
		}
		if(out.normal[2] < 0) {
			out.signbits += 4;
		}
		loadmodel.planes[i] = out;
		fileofs += 20;
	}
};
quake_Mod_$Brush.LoadTexinfo = function(loadmodel,view) {
	var fileofs = view.getUint32(52,true);
	var filelen = view.getUint32(56,true);
	if(filelen % 40 != 0) {
		quake_Sys.Error("Mod.LoadTexinfo: funny lump size in " + loadmodel.name);
	}
	var count = filelen / 40 | 0;
	loadmodel.texinfo = [];
	var _g = 0;
	while(_g < count) {
		var i = _g++;
		var out = new quake_Texinfo([[view.getFloat32(fileofs,true),view.getFloat32(fileofs + 4,true),view.getFloat32(fileofs + 8,true),view.getFloat32(fileofs + 12,true)],[view.getFloat32(fileofs + 16,true),view.getFloat32(fileofs + 20,true),view.getFloat32(fileofs + 24,true),view.getFloat32(fileofs + 28,true)]],view.getUint32(fileofs + 32,true),view.getUint32(fileofs + 36,true));
		if(out.texture >= loadmodel.textures.length) {
			out.texture = loadmodel.textures.length - 1;
			out.flags = 0;
		}
		loadmodel.texinfo[i] = out;
		fileofs += 40;
	}
};
quake_Mod_$Brush.LoadFaces = function(loadmodel,view) {
	var fileofs = view.getUint32(60,true);
	var filelen = view.getUint32(64,true);
	if(filelen % 20 != 0) {
		quake_Sys.Error("Mod.LoadFaces: funny lump size in " + loadmodel.name);
	}
	var count = filelen / 20 | 0;
	loadmodel.firstface = 0;
	loadmodel.numfaces = count;
	loadmodel.faces = [];
	var _g = 0;
	while(_g < count) {
		var i = _g++;
		var styles = new Uint8Array(view.buffer,fileofs + 12,4);
		var out = new quake_Surface();
		out.plane = loadmodel.planes[view.getUint16(fileofs,true)];
		out.firstedge = view.getUint16(fileofs + 4,true);
		out.numedges = view.getUint16(fileofs + 8,true);
		out.texinfo = view.getUint16(fileofs + 10,true);
		out.styles = [];
		out.lightofs = view.getInt32(fileofs + 16,true);
		if(styles[0] != 255) {
			out.styles[0] = styles[0];
		}
		if(styles[1] != 255) {
			out.styles[1] = styles[1];
		}
		if(styles[2] != 255) {
			out.styles[2] = styles[2];
		}
		if(styles[3] != 255) {
			out.styles[3] = styles[3];
		}
		var mins_0 = 999999.0;
		var mins_1 = 999999.0;
		var maxs_0 = -99999.0;
		var maxs_1 = -99999.0;
		var tex = loadmodel.texinfo[out.texinfo];
		out.texture = tex.texture;
		var _g1 = 0;
		var _g11 = out.numedges;
		while(_g1 < _g11) {
			var e = loadmodel.surfedges[out.firstedge + _g1++];
			var v;
			if(e >= 0) {
				v = loadmodel.vertexes[loadmodel.edges[e][0]];
			} else {
				v = loadmodel.vertexes[loadmodel.edges[-e][1]];
			}
			var a = tex.vecs[0];
			var v1 = new Float32Array(3);
			v1[0] = a[0];
			v1[1] = a[1];
			v1[2] = a[2];
			var val = v[0] * v1[0] + v[1] * v1[1] + v[2] * v1[2] + tex.vecs[0][3];
			if(val < mins_0) {
				mins_0 = val;
			}
			if(val > maxs_0) {
				maxs_0 = val;
			}
			var a1 = tex.vecs[1];
			var v2 = new Float32Array(3);
			v2[0] = a1[0];
			v2[1] = a1[1];
			v2[2] = a1[2];
			val = v[0] * v2[0] + v[1] * v2[1] + v[2] * v2[2] + tex.vecs[1][3];
			if(val < mins_1) {
				mins_1 = val;
			}
			if(val > maxs_1) {
				maxs_1 = val;
			}
		}
		out.texturemins = [Math.floor(mins_0 / 16) * 16,Math.floor(mins_1 / 16) * 16];
		out.extents = [Math.ceil(maxs_0 / 16) * 16 - out.texturemins[0],Math.ceil(maxs_1 / 16) * 16 - out.texturemins[1]];
		if(loadmodel.textures[tex.texture].turbulent) {
			out.turbulent = true;
		} else if(loadmodel.textures[tex.texture].sky) {
			out.sky = true;
		}
		loadmodel.faces[i] = out;
		fileofs += 20;
	}
};
quake_Mod_$Brush.LoadMarksurfaces = function(loadmodel,view) {
	var fileofs = view.getUint32(92,true);
	var count = view.getUint32(96,true) >> 1;
	loadmodel.marksurfaces = [];
	var _g = 0;
	while(_g < count) {
		var i = _g++;
		var j = view.getUint16(fileofs + (i << 1),true);
		if(j > loadmodel.faces.length) {
			quake_Sys.Error("Mod.LoadMarksurfaces: bad surface number");
		}
		loadmodel.marksurfaces[i] = j;
	}
};
quake_Mod_$Brush.LoadVisibility = function(loadmodel,view) {
	var fileofs = view.getUint32(36,true);
	var filelen = view.getUint32(40,true);
	if(filelen == 0) {
		return;
	}
	loadmodel.visdata = new Uint8Array(view.buffer.slice(fileofs,fileofs + filelen));
};
quake_Mod_$Brush.LoadLeafs = function(loadmodel,view) {
	var fileofs = view.getUint32(84,true);
	var filelen = view.getUint32(88,true);
	if(filelen % 28 != 0) {
		quake_Sys.Error("Mod.LoadLeafs: funny lump size in " + loadmodel.name);
	}
	var count = filelen / 28 | 0;
	loadmodel.leafs = [];
	var _g = 0;
	while(_g < count) {
		var out = new quake_Leaf();
		out.num = _g++;
		out.contents = view.getInt32(fileofs,true);
		out.visofs = view.getInt32(fileofs + 4,true);
		var x = view.getInt16(fileofs + 8,true);
		var y = view.getInt16(fileofs + 10,true);
		var z = view.getInt16(fileofs + 12,true);
		var v = new Float32Array(3);
		v[0] = x;
		v[1] = y;
		v[2] = z;
		out.mins = v;
		var x1 = view.getInt16(fileofs + 14,true);
		var y1 = view.getInt16(fileofs + 16,true);
		var z1 = view.getInt16(fileofs + 18,true);
		var v1 = new Float32Array(3);
		v1[0] = x1;
		v1[1] = y1;
		v1[2] = z1;
		out.maxs = v1;
		out.firstmarksurface = view.getUint16(fileofs + 20,true);
		out.nummarksurfaces = view.getUint16(fileofs + 22,true);
		out.ambient_level = [view.getUint8(fileofs + 24),view.getUint8(fileofs + 25),view.getUint8(fileofs + 26),view.getUint8(fileofs + 27)];
		out.cmds = [];
		out.skychain = 0;
		out.waterchain = 0;
		loadmodel.leafs.push(out);
		fileofs += 28;
	}
};
quake_Mod_$Brush.LoadNodes = function(loadmodel,view) {
	var fileofs = view.getUint32(44,true);
	var filelen = view.getUint32(48,true);
	if(filelen == 0 || filelen % 24 != 0) {
		quake_Sys.Error("Mod.LoadNodes: funny lump size in " + loadmodel.name);
	}
	var count = filelen / 24 | 0;
	loadmodel.nodes = [];
	var children = new Array(count);
	var _g = 0;
	while(_g < count) {
		var i = _g++;
		var n = loadmodel.nodes[i] = new quake_Node();
		n.num = i;
		n.contents = 0;
		n.planenum = view.getUint32(fileofs,true);
		children[i] = [view.getInt16(fileofs + 4,true),view.getInt16(fileofs + 6,true)];
		var x = view.getInt16(fileofs + 8,true);
		var y = view.getInt16(fileofs + 10,true);
		var z = view.getInt16(fileofs + 12,true);
		var v = new Float32Array(3);
		v[0] = x;
		v[1] = y;
		v[2] = z;
		n.mins = v;
		var x1 = view.getInt16(fileofs + 14,true);
		var y1 = view.getInt16(fileofs + 16,true);
		var z1 = view.getInt16(fileofs + 18,true);
		var v1 = new Float32Array(3);
		v1[0] = x1;
		v1[1] = y1;
		v1[2] = z1;
		n.maxs = v1;
		n.firstface = view.getUint16(fileofs + 20,true);
		n.numfaces = view.getUint16(fileofs + 22,true);
		n.cmds = [];
		fileofs += 24;
	}
	var _g2 = 0;
	while(_g2 < count) {
		var i1 = _g2++;
		var out = loadmodel.nodes[i1];
		out.plane = loadmodel.planes[out.planenum];
		var children1 = children[i1];
		if(children1[0] >= 0) {
			out.child0 = loadmodel.nodes[children1[0]];
		} else {
			out.child0 = loadmodel.leafs[-1 - children1[0]];
		}
		if(children1[1] >= 0) {
			out.child1 = loadmodel.nodes[children1[1]];
		} else {
			out.child1 = loadmodel.leafs[-1 - children1[1]];
		}
	}
	quake_Mod_$Brush.SetParent(loadmodel.nodes[0],null);
};
quake_Mod_$Brush.SetParent = function(node,parent) {
	node.parent = parent;
	if(node.contents < 0) {
		return;
	}
	quake_Mod_$Brush.SetParent(node.child0,node);
	quake_Mod_$Brush.SetParent(node.child1,node);
};
quake_Mod_$Brush.LoadClipnodes = function(loadmodel,view) {
	var fileofs = view.getUint32(76,true);
	var count = view.getUint32(80,true) >> 3;
	loadmodel.clipnodes = [];
	loadmodel.hulls = [];
	var loadmodel1 = loadmodel.hulls;
	var h = new quake_Hull();
	h.clipnodes = loadmodel.clipnodes;
	h.firstclipnode = 0;
	h.lastclipnode = count - 1;
	h.planes = loadmodel.planes;
	var v = new Float32Array(3);
	v[0] = -16.0;
	v[1] = -16.0;
	v[2] = -24.0;
	h.clip_mins = v;
	var v1 = new Float32Array(3);
	v1[0] = 16.0;
	v1[1] = 16.0;
	v1[2] = 32.0;
	h.clip_maxs = v1;
	loadmodel1[1] = h;
	var loadmodel2 = loadmodel.hulls;
	var h1 = new quake_Hull();
	h1.clipnodes = loadmodel.clipnodes;
	h1.firstclipnode = 0;
	h1.lastclipnode = count - 1;
	h1.planes = loadmodel.planes;
	var v2 = new Float32Array(3);
	v2[0] = -32.0;
	v2[1] = -32.0;
	v2[2] = -24.0;
	h1.clip_mins = v2;
	var v3 = new Float32Array(3);
	v3[0] = 32.0;
	v3[1] = 32.0;
	v3[2] = 64.0;
	h1.clip_maxs = v3;
	loadmodel2[2] = h1;
	var _g = 0;
	while(_g < count) {
		++_g;
		var n = new quake_ClipNode();
		n.planenum = view.getUint32(fileofs,true);
		n.child0 = view.getInt16(fileofs + 4,true);
		n.child1 = view.getInt16(fileofs + 6,true);
		loadmodel.clipnodes.push(n);
		fileofs += 8;
	}
};
quake_Mod_$Brush.MakeHull0 = function(loadmodel) {
	var clipnodes = [];
	var h = new quake_Hull();
	h.clipnodes = clipnodes;
	h.lastclipnode = loadmodel.nodes.length - 1;
	h.planes = loadmodel.planes;
	h.clip_mins = new Float32Array(3);
	h.clip_maxs = new Float32Array(3);
	var _g = 0;
	var _g1 = loadmodel.nodes.length;
	while(_g < _g1) {
		var i = _g++;
		var node = loadmodel.nodes[i];
		var out = new quake_ClipNode();
		out.planenum = node.planenum;
		var child = node.child0;
		out.child0 = child.contents < 0 ? child.contents : child.num;
		child = node.child1;
		out.child1 = child.contents < 0 ? child.contents : child.num;
		clipnodes[i] = out;
	}
	loadmodel.hulls[0] = h;
};
quake_Mod_$Brush.LoadEntities = function(loadmodel,view) {
	loadmodel.entities = quake_Q.memstr(new Uint8Array(view.buffer,view.getUint32(4,true),view.getUint32(8,true)));
};
quake_Mod_$Brush.LoadSubmodels = function(loadmodel,view) {
	var fileofs = view.getUint32(116,true);
	var count = view.getUint32(120,true) >> 6;
	if(count == 0) {
		quake_Sys.Error("Mod.LoadSubmodels: funny lump size in " + loadmodel.name);
	}
	loadmodel.submodels = [];
	var x = view.getFloat32(fileofs,true) - 1.0;
	var y = view.getFloat32(fileofs + 4,true) - 1.0;
	var z = view.getFloat32(fileofs + 8,true) - 1.0;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	loadmodel.mins = v;
	var x1 = view.getFloat32(fileofs + 12,true) + 1.0;
	var y1 = view.getFloat32(fileofs + 16,true) + 1.0;
	var z1 = view.getFloat32(fileofs + 20,true) + 1.0;
	var v1 = new Float32Array(3);
	v1[0] = x1;
	v1[1] = y1;
	v1[2] = z1;
	loadmodel.maxs = v1;
	loadmodel.hulls[0].firstclipnode = view.getUint32(fileofs + 36,true);
	loadmodel.hulls[1].firstclipnode = view.getUint32(fileofs + 40,true);
	loadmodel.hulls[2].firstclipnode = view.getUint32(fileofs + 44,true);
	fileofs += 64;
	var clipnodes = loadmodel.hulls[0].clipnodes;
	var _g = 1;
	while(_g < count) {
		var i = _g++;
		var out = quake_Mod.FindName("*" + i);
		out.needload = false;
		out.type = 0;
		out.submodel = true;
		var x2 = view.getFloat32(fileofs,true) - 1.0;
		var y2 = view.getFloat32(fileofs + 4,true) - 1.0;
		var z2 = view.getFloat32(fileofs + 8,true) - 1.0;
		var v2 = new Float32Array(3);
		v2[0] = x2;
		v2[1] = y2;
		v2[2] = z2;
		out.mins = v2;
		var x3 = view.getFloat32(fileofs + 12,true) + 1.0;
		var y3 = view.getFloat32(fileofs + 16,true) + 1.0;
		var z3 = view.getFloat32(fileofs + 20,true) + 1.0;
		var v3 = new Float32Array(3);
		v3[0] = x3;
		v3[1] = y3;
		v3[2] = z3;
		out.maxs = v3;
		var x4 = view.getFloat32(fileofs + 24,true);
		var y4 = view.getFloat32(fileofs + 28,true);
		var z4 = view.getFloat32(fileofs + 32,true);
		var v4 = new Float32Array(3);
		v4[0] = x4;
		v4[1] = y4;
		v4[2] = z4;
		out.origin = v4;
		var h = new quake_Hull();
		h.clipnodes = clipnodes;
		h.firstclipnode = view.getUint32(fileofs + 36,true);
		h.lastclipnode = loadmodel.nodes.length - 1;
		h.planes = loadmodel.planes;
		h.clip_mins = new Float32Array(3);
		h.clip_maxs = new Float32Array(3);
		var h1 = new quake_Hull();
		h1.clipnodes = loadmodel.clipnodes;
		h1.firstclipnode = view.getUint32(fileofs + 40,true);
		h1.lastclipnode = loadmodel.clipnodes.length - 1;
		h1.planes = loadmodel.planes;
		var v5 = new Float32Array(3);
		v5[0] = -16.0;
		v5[1] = -16.0;
		v5[2] = -24.0;
		h1.clip_mins = v5;
		var v6 = new Float32Array(3);
		v6[0] = 16.0;
		v6[1] = 16.0;
		v6[2] = 32.0;
		h1.clip_maxs = v6;
		var h2 = new quake_Hull();
		h2.clipnodes = loadmodel.clipnodes;
		h2.firstclipnode = view.getUint32(fileofs + 44,true);
		h2.lastclipnode = loadmodel.clipnodes.length - 1;
		h2.planes = loadmodel.planes;
		var v7 = new Float32Array(3);
		v7[0] = -32.0;
		v7[1] = -32.0;
		v7[2] = -24.0;
		h2.clip_mins = v7;
		var v8 = new Float32Array(3);
		v8[0] = 32.0;
		v8[1] = 32.0;
		v8[2] = 64.0;
		h2.clip_maxs = v8;
		out.hulls = [h,h1,h2];
		out.textures = loadmodel.textures;
		out.lightdata = loadmodel.lightdata;
		out.faces = loadmodel.faces;
		out.firstface = view.getUint32(fileofs + 56,true);
		out.numfaces = view.getUint32(fileofs + 60,true);
		loadmodel.submodels[i - 1] = out;
		fileofs += 64;
	}
};
var quake_Mod_$Sprite = function() { };
quake_Mod_$Sprite.__name__ = true;
quake_Mod_$Sprite.LoadSpriteModel = function(loadmodel,model) {
	var version = model.getUint32(4,true);
	if(version != 1) {
		quake_Sys.Error(loadmodel.name + " has wrong version number (" + version + " should be " + 1 + ")");
	}
	loadmodel.type = 1;
	loadmodel.oriented = model.getUint32(8,true) == 3;
	loadmodel.boundingradius = model.getFloat32(12,true);
	loadmodel.width = model.getUint32(16,true);
	loadmodel.height = model.getUint32(20,true);
	loadmodel.numframes = model.getUint32(24,true);
	if(loadmodel.numframes == 0) {
		quake_Sys.Error("model " + loadmodel.name + " has no frames");
	}
	loadmodel.random = model.getUint32(32,true) == 1;
	var x = loadmodel.width * -0.5;
	var y = loadmodel.width * -0.5;
	var z = loadmodel.height * -0.5;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	loadmodel.mins = v;
	var x1 = loadmodel.width * 0.5;
	var y1 = loadmodel.width * 0.5;
	var z1 = loadmodel.height * 0.5;
	var v1 = new Float32Array(3);
	v1[0] = x1;
	v1[1] = y1;
	v1[2] = z1;
	loadmodel.maxs = v1;
	loadmodel.frames = [];
	var inframe = 36;
	var frame;
	var group;
	var numframes;
	var _g = 0;
	var _g1 = loadmodel.numframes;
	while(_g < _g1) {
		var i = _g++;
		inframe += 4;
		if(model.getUint32(inframe - 4,true) == 0) {
			frame = new quake_MFrame(false);
			loadmodel.frames[i] = frame;
			inframe = quake_Mod_$Sprite.LoadSpriteFrame(loadmodel.name + "_" + i,model,inframe,frame);
		} else {
			group = new quake_MFrame(true);
			group.frames = [];
			loadmodel.frames[i] = group;
			numframes = model.getUint32(inframe,true);
			inframe += 4;
			var _g2 = 0;
			while(_g2 < numframes) {
				var j = _g2++;
				var f = new quake_MFrame(false);
				f.interval = model.getFloat32(inframe,true);
				group.frames[j] = f;
				if(group.frames[j].interval <= 0.0) {
					quake_Sys.Error("Mod.LoadSpriteModel: interval<=0");
				}
				inframe += 4;
			}
			var _g21 = 0;
			while(_g21 < numframes) {
				var j1 = _g21++;
				inframe = quake_Mod_$Sprite.LoadSpriteFrame(loadmodel.name + "_" + i + "_" + j1,model,inframe,group.frames[j1]);
			}
		}
	}
};
quake_Mod_$Sprite.LoadSpriteFrame = function(identifier,model,inframe,frame) {
	frame.origin = [model.getInt32(inframe,true),-model.getInt32(inframe + 4,true)];
	frame.width = model.getUint32(inframe + 8,true);
	frame.height = model.getUint32(inframe + 12,true);
	var size = frame.width * frame.height;
	var _g = 0;
	var _g1 = quake_GL.textures;
	while(_g < _g1.length) {
		var glt = _g1[_g];
		++_g;
		if(glt.identifier == identifier) {
			if(frame.width != glt.width || frame.height != glt.height) {
				quake_Sys.Error("Mod.LoadSpriteFrame: cache mismatch");
			}
			frame.texturenum = glt.texnum;
			return inframe + 16 + frame.width * frame.height;
		}
	}
	var data = new Uint8Array(model.buffer,inframe + 16,size);
	var scaled_width = frame.width;
	var scaled_height = frame.height;
	if((frame.width & frame.width - 1) != 0 || (frame.height & frame.height - 1) != 0) {
		--scaled_width;
		scaled_width |= scaled_width >> 1;
		scaled_width |= scaled_width >> 2;
		scaled_width |= scaled_width >> 4;
		scaled_width |= scaled_width >> 8;
		scaled_width |= scaled_width >> 16;
		++scaled_width;
		--scaled_height;
		scaled_height |= scaled_height >> 1;
		scaled_height |= scaled_height >> 2;
		scaled_height |= scaled_height >> 4;
		scaled_height |= scaled_height >> 8;
		scaled_height |= scaled_height >> 16;
		++scaled_height;
	}
	if(scaled_width > quake_GL.maxtexturesize) {
		scaled_width = quake_GL.maxtexturesize;
	}
	if(scaled_height > quake_GL.maxtexturesize) {
		scaled_height = quake_GL.maxtexturesize;
	}
	if(scaled_width != frame.width || scaled_height != frame.height) {
		size = scaled_width * scaled_height;
		data = quake_GL.ResampleTexture(data,frame.width,frame.height,scaled_width,scaled_height);
	}
	var trans = new ArrayBuffer(size << 2);
	var trans32 = new Uint32Array(trans);
	var _g2 = 0;
	var _g3 = size;
	while(_g2 < _g3) {
		var i = _g2++;
		if(data[i] != 255) {
			trans32[i] = quake_COM.LittleLong(quake_VID.d_8to24table[data[i]] + (-16777216));
		}
	}
	var glt1 = new quake_GLTexture(identifier,frame.width,frame.height);
	quake_GL.Bind(0,glt1.texnum);
	quake_GL.gl.texImage2D(3553,0,6408,scaled_width,scaled_height,0,6408,5121,new Uint8Array(trans));
	quake_GL.gl.generateMipmap(3553);
	quake_GL.gl.texParameterf(3553,10241,quake_GL.filter_min);
	quake_GL.gl.texParameterf(3553,10240,quake_GL.filter_max);
	quake_GL.textures.push(glt1);
	frame.texturenum = glt1.texnum;
	return inframe + 16 + frame.width * frame.height;
};
var quake_NETSocketBase = function(address) {
	this.connecttime = quake_NET.time;
	this.lastMessageTime = quake_NET.time;
	this.driver = quake_NET.driverlevel;
	this.address = address;
};
quake_NETSocketBase.__name__ = true;
var quake_NET = function() { };
quake_NET.__name__ = true;
quake_NET.AddNewSocket = function(sock) {
	var i = 0;
	while(i < quake_NET.activeSockets.length) {
		if(quake_NET.activeSockets[i].disconnected) {
			break;
		}
		++i;
	}
	quake_NET.activeSockets[i] = sock;
};
quake_NET.Connect = function(host) {
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	if(host == "local") {
		quake_NET.driverlevel = 0;
		return quake_NET_$Loop.Connect(host);
	}
	var _g = 1;
	var _g1 = quake_NET.drivers.length;
	while(_g < _g1) {
		quake_NET.driverlevel = _g++;
		var dfunc = quake_NET.drivers[quake_NET.driverlevel];
		if(!dfunc.initialized) {
			continue;
		}
		var ret = dfunc.Connect(host);
		if(ret == 0) {
			quake_CL.cls.state = 1;
			quake_Console.Print("trying...\n");
			quake_NET.start_time = quake_NET.time;
			quake_NET.reps = 0;
			throw new js__$Boot_HaxeError("NET.Connect");
		}
		if(ret != null) {
			return ret;
		}
	}
	return null;
};
quake_NET.CheckForResend = function() {
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	var dfunc = quake_NET.drivers[quake_NET.newsocket.driver];
	if(quake_NET.reps <= 2) {
		if(quake_NET.time - quake_NET.start_time >= 2.5 * (quake_NET.reps + 1)) {
			quake_Console.Print("still trying...\n");
			++quake_NET.reps;
		}
	} else if(quake_NET.reps == 3) {
		if(quake_NET.time - quake_NET.start_time >= 10.0) {
			quake_NET.Close(quake_NET.newsocket);
			quake_CL.cls.state = 0;
			quake_Console.Print("No Response\n");
			quake_Host.Error("NET.CheckForResend: connect failed\n");
		}
	}
	var ret = dfunc.CheckForResend();
	if(ret == 1) {
		quake_NET.newsocket.disconnected = false;
		quake_CL.Connect(quake_NET.newsocket);
	} else if(ret == -1) {
		quake_NET.newsocket.disconnected = false;
		quake_NET.Close(quake_NET.newsocket);
		quake_CL.cls.state = 0;
		quake_Console.Print("Network Error\n");
		quake_Host.Error("NET.CheckForResend: connect failed\n");
	}
};
quake_NET.CheckNewConnections = function() {
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	var _g = 0;
	var _g1 = quake_NET.drivers.length;
	while(_g < _g1) {
		quake_NET.driverlevel = _g++;
		var dfunc = quake_NET.drivers[quake_NET.driverlevel];
		if(!dfunc.initialized) {
			continue;
		}
		var ret = dfunc.CheckNewConnections();
		if(ret != null) {
			return ret;
		}
	}
	return null;
};
quake_NET.Close = function(sock) {
	if(sock == null) {
		return;
	}
	if(sock.disconnected) {
		return;
	}
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	sock.Close();
	sock.disconnected = true;
};
quake_NET.GetMessage = function(sock) {
	if(sock == null) {
		return -1;
	}
	if(sock.disconnected) {
		quake_Console.Print("NET.GetMessage: disconnected socket\n");
		return -1;
	}
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	var ret = sock.GetMessage();
	if(sock.driver != 0) {
		if(ret == 0) {
			if(quake_NET.time - sock.lastMessageTime > quake_NET.messagetimeout.value) {
				quake_NET.Close(sock);
				return -1;
			}
		} else if(ret > 0) {
			sock.lastMessageTime = quake_NET.time;
		}
	}
	return ret;
};
quake_NET.SendMessage = function(sock,data) {
	if(sock == null) {
		return -1;
	}
	if(sock.disconnected) {
		quake_Console.Print("NET.SendMessage: disconnected socket\n");
		return -1;
	}
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	return sock.SendMessage(data);
};
quake_NET.SendUnreliableMessage = function(sock,data) {
	if(sock == null) {
		return -1;
	}
	if(sock.disconnected) {
		quake_Console.Print("NET.SendUnreliableMessage: disconnected socket\n");
		return -1;
	}
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	return sock.SendUnreliableMessage(data);
};
quake_NET.CanSendMessage = function(sock) {
	if(sock == null) {
		return false;
	}
	if(sock.disconnected) {
		return false;
	}
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	return sock.CanSendMessage();
};
quake_NET.SendToAll = function(data) {
	var count = 0;
	var state1 = [];
	var state2 = [];
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var i = _g++;
		quake_Host.client = quake_SV.svs.clients[i];
		if(quake_Host.client.netconnection == null) {
			continue;
		}
		if(!quake_Host.client.active) {
			state2[i] = true;
			state1[i] = true;
			continue;
		}
		if(quake_Host.client.netconnection.driver == 0) {
			quake_NET.SendMessage(quake_Host.client.netconnection,data);
			state2[i] = true;
			state1[i] = true;
			continue;
		}
		++count;
		state2[i] = false;
		state1[i] = false;
	}
	var start = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	while(count != 0) {
		count = 0;
		var _g2 = 0;
		var _g3 = quake_SV.svs.maxclients;
		while(_g2 < _g3) {
			var i1 = _g2++;
			quake_Host.client = quake_SV.svs.clients[i1];
			if(!state1[i1]) {
				if(quake_NET.CanSendMessage(quake_Host.client.netconnection)) {
					state1[i1] = true;
					quake_NET.SendMessage(quake_Host.client.netconnection,data);
				} else {
					quake_NET.GetMessage(quake_Host.client.netconnection);
				}
				++count;
				continue;
			}
			if(!state2[i1]) {
				if(quake_NET.CanSendMessage(quake_Host.client.netconnection)) {
					state2[i1] = true;
				} else {
					quake_NET.GetMessage(quake_Host.client.netconnection);
				}
				++count;
			}
		}
		if(new Date().getTime() * 0.001 - quake_Sys.oldtime - start > 5.0) {
			return count;
		}
	}
	return count;
};
quake_NET.Init = function() {
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	quake_NET.messagetimeout = quake_Cvar.RegisterVariable("net_messagetimeout","300");
	quake_NET.hostname = quake_Cvar.RegisterVariable("hostname","UNNAMED");
	quake_NET.drivers = [quake_NET_$Loop,quake_NET_$WEBS];
	var _g = 0;
	var _g1 = quake_NET.drivers.length;
	while(_g < _g1) {
		quake_NET.driverlevel = _g++;
		quake_NET.drivers[quake_NET.driverlevel].initialized = quake_NET.drivers[quake_NET.driverlevel].Init();
	}
};
quake_NET.Shutdown = function() {
	quake_NET.time = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	var _g = 0;
	var _g1 = quake_NET.activeSockets.length;
	while(_g < _g1) quake_NET.Close(quake_NET.activeSockets[_g++]);
};
var quake__$NET_$Loop_LoopNETSocket = function(address) {
	quake_NETSocketBase.call(this,address);
	this.receiveMessage = new Uint8Array(new ArrayBuffer(8192));
};
quake__$NET_$Loop_LoopNETSocket.__name__ = true;
quake__$NET_$Loop_LoopNETSocket.__super__ = quake_NETSocketBase;
quake__$NET_$Loop_LoopNETSocket.prototype = $extend(quake_NETSocketBase.prototype,{
	Close: function() {
		if(this.other_side != null) {
			this.other_side.other_side = null;
		}
		this.receiveMessageLength = 0;
		this.canSend = false;
		if(this == quake_NET_$Loop.client) {
			quake_NET_$Loop.client = null;
		} else {
			quake_NET_$Loop.server = null;
		}
	}
	,GetMessage: function() {
		if(this.receiveMessageLength == 0) {
			return 0;
		}
		var ret = this.receiveMessage[0];
		var length = this.receiveMessage[1] + (this.receiveMessage[2] << 8);
		if(length > quake_NET.message.data.byteLength) {
			quake_Sys.Error("GetMessage: overflow");
		}
		quake_NET.message.cursize = length;
		new Uint8Array(quake_NET.message.data).set(this.receiveMessage.subarray(3,length + 3));
		this.receiveMessageLength -= length;
		if(this.receiveMessageLength >= 4) {
			var _g = 0;
			var _g1 = this.receiveMessageLength;
			while(_g < _g1) {
				var i = _g++;
				this.receiveMessage[i] = this.receiveMessage[length + 3 + i];
			}
		}
		this.receiveMessageLength -= 3;
		if(this.other_side != null && ret == 1) {
			this.other_side.canSend = true;
		}
		return ret;
	}
	,SendMessage: function(data) {
		if(this.other_side == null) {
			return -1;
		}
		var bufferLength = this.other_side.receiveMessageLength;
		this.other_side.receiveMessageLength += data.cursize + 3;
		if(this.other_side.receiveMessageLength > 8192) {
			quake_Sys.Error("SendMessage: overflow");
		}
		var buffer = this.other_side.receiveMessage;
		buffer[bufferLength] = 1;
		buffer[bufferLength + 1] = data.cursize & 255;
		buffer[bufferLength + 2] = data.cursize >> 8;
		buffer.set(new Uint8Array(data.data,0,data.cursize),bufferLength + 3);
		this.canSend = false;
		return 1;
	}
	,SendUnreliableMessage: function(data) {
		if(this.other_side == null) {
			return -1;
		}
		var bufferLength = this.other_side.receiveMessageLength;
		this.other_side.receiveMessageLength += data.cursize + 3;
		if(this.other_side.receiveMessageLength > 8192) {
			quake_Sys.Error("SendMessage: overflow");
		}
		var buffer = this.other_side.receiveMessage;
		buffer[bufferLength] = 2;
		buffer[bufferLength + 1] = data.cursize & 255;
		buffer[bufferLength + 2] = data.cursize >> 8;
		buffer.set(new Uint8Array(data.data,0,data.cursize),bufferLength + 3);
		return 1;
	}
	,CanSendMessage: function() {
		if(this.other_side != null) {
			return this.canSend;
		}
		return false;
	}
});
var quake_NET_$Loop = function() { };
quake_NET_$Loop.__name__ = true;
quake_NET_$Loop.Init = function() {
	return true;
};
quake_NET_$Loop.Connect = function(host) {
	if(host != "local") {
		return null;
	}
	quake_NET_$Loop.localconnectpending = true;
	if(quake_NET_$Loop.client == null) {
		quake_NET_$Loop.client = new quake__$NET_$Loop_LoopNETSocket("localhost");
	}
	quake_NET_$Loop.client.receiveMessageLength = 0;
	quake_NET_$Loop.client.canSend = true;
	if(quake_NET_$Loop.server == null) {
		quake_NET_$Loop.server = new quake__$NET_$Loop_LoopNETSocket("LOCAL");
	}
	quake_NET_$Loop.server.receiveMessageLength = 0;
	quake_NET_$Loop.server.canSend = true;
	quake_NET_$Loop.client.other_side = quake_NET_$Loop.server;
	quake_NET_$Loop.server.other_side = quake_NET_$Loop.client;
	quake_NET.AddNewSocket(quake_NET_$Loop.client);
	quake_NET.AddNewSocket(quake_NET_$Loop.server);
	return quake_NET_$Loop.client;
};
quake_NET_$Loop.CheckNewConnections = function() {
	if(!quake_NET_$Loop.localconnectpending) {
		return null;
	}
	quake_NET_$Loop.localconnectpending = false;
	quake_NET_$Loop.server.receiveMessageLength = 0;
	quake_NET_$Loop.server.canSend = true;
	quake_NET_$Loop.client.receiveMessageLength = 0;
	quake_NET_$Loop.client.canSend = true;
	return quake_NET_$Loop.server;
};
quake_NET_$Loop.CheckForResend = function() {
	throw new js__$Boot_HaxeError("Not implemented");
};
var quake__$NET_$WEBS_WEBSNETSocket = function(address) {
	quake_NETSocketBase.call(this,address);
	this.disconnected = true;
	this.receiveMessage = [];
	this.native_socket = new WebSocket(address,"quake");
	this.native_socket.data_socket = this;
	this.native_socket.binaryType = "arraybuffer";
	this.native_socket.onerror = $bind(this,this.OnError);
	this.native_socket.onmessage = $bind(this,this.OnMessage);
};
quake__$NET_$WEBS_WEBSNETSocket.__name__ = true;
quake__$NET_$WEBS_WEBSNETSocket.__super__ = quake_NETSocketBase;
quake__$NET_$WEBS_WEBSNETSocket.prototype = $extend(quake_NETSocketBase.prototype,{
	OnError: function() {
		quake_NET.Close(this);
	}
	,OnMessage: function(message) {
		var data = message.data;
		if(typeof(data) == "string") {
			return;
		}
		if(data.byteLength > 8000) {
			return;
		}
		this.receiveMessage.push(new Uint8Array(data));
	}
	,Close: function() {
		if(this.native_socket != null) {
			this.native_socket.close(1000);
		}
	}
	,GetMessage: function() {
		if(this.native_socket == null) {
			return -1;
		}
		if(this.native_socket.readyState != 1) {
			return -1;
		}
		if(this.receiveMessage.length == 0) {
			return 0;
		}
		var message = this.receiveMessage.shift();
		quake_NET.message.cursize = message.length - 1;
		new Uint8Array(quake_NET.message.data).set(message.subarray(1,message.length));
		return message[0];
	}
	,SendMessage: function(data) {
		if(this.native_socket == null) {
			return -1;
		}
		if(this.native_socket.readyState != 1) {
			return -1;
		}
		var buf = new ArrayBuffer(data.cursize + 1);
		var dest = new Uint8Array(buf);
		dest[0] = 1;
		dest.set(new Uint8Array(data.data,0,data.cursize),1);
		this.native_socket.send(buf);
		return 1;
	}
	,SendUnreliableMessage: function(data) {
		if(this.native_socket == null) {
			return -1;
		}
		if(this.native_socket.readyState != 1) {
			return -1;
		}
		var buf = new ArrayBuffer(data.cursize + 1);
		var dest = new Uint8Array(buf);
		dest[0] = 2;
		dest.set(new Uint8Array(data.data,0,data.cursize),1);
		this.native_socket.send(buf);
		return 1;
	}
	,CanSendMessage: function() {
		if(this.native_socket == null) {
			return false;
		}
		if(this.native_socket.readyState == 1) {
			return true;
		}
		return false;
	}
});
var quake_NET_$WEBS = function() { };
quake_NET_$WEBS.__name__ = true;
quake_NET_$WEBS.Init = function() {
	if(window.WebSocket == null || window.document.location.protocol == "https:") {
		return false;
	}
	quake_NET_$WEBS.available = true;
	return true;
};
quake_NET_$WEBS.Connect = function(host) {
	if(host.length <= 5) {
		return null;
	}
	if(HxOverrides.cca(host,5) == 47) {
		return null;
	}
	if(host.substring(0,5) != "ws://") {
		return null;
	}
	host = "ws://" + host.split("/")[2];
	var sock;
	try {
		sock = new quake__$NET_$WEBS_WEBSNETSocket(host);
	} catch( e ) {
		return null;
	}
	quake_NET.newsocket = sock;
	quake_NET.AddNewSocket(sock);
	return 0;
};
quake_NET_$WEBS.CheckNewConnections = function() {
	return null;
};
quake_NET_$WEBS.CheckForResend = function() {
	var sock = quake_NET.newsocket;
	if(sock.native_socket.readyState == 1) {
		return 1;
	}
	if(sock.native_socket.readyState != 0) {
		return -1;
	}
	return null;
};
var quake_PR = function() { };
quake_PR.__name__ = true;
quake_PR.CheckEmptyString = function(s) {
	var c = HxOverrides.cca(s,0);
	if(c == null || c <= 32) {
		quake_PR.RunError("Bad string");
	}
};
quake_PR.ValueString = function(type,val,ofs) {
	var val_float = new Float32Array(val);
	var val_int = new Int32Array(val);
	var type1 = type & 32767;
	switch(type1) {
	case 0:
		return "void";
	case 1:
		return quake_PR.GetString(val_int[ofs]);
	case 2:
		return val_float[ofs].toFixed(1);
	case 3:
		return "'" + val_float[ofs].toFixed(1) + " " + val_float[ofs + 1].toFixed(1) + " " + val_float[ofs + 2].toFixed(1) + "'";
	case 4:
		return "entity " + val_int[ofs];
	case 5:
		var def = quake_ED.FieldAtOfs(val_int[ofs]);
		if(def != null) {
			return "." + quake_PR.GetString(def.name);
		}
		return ".";
	case 6:
		return quake_PR.GetString(quake_PR.functions[val_int[ofs]].name) + "()";
	case 7:
		return "pointer";
	default:
		return "bad type " + type1;
	}
};
quake_PR.UglyValueString = function(type,val,ofs) {
	var val_float = new Float32Array(val);
	var val_int = new Int32Array(val);
	var type1 = type & 32767;
	switch(type1) {
	case 0:
		return "void";
	case 1:
		return quake_PR.GetString(val_int[ofs]);
	case 2:
		return val_float[ofs].toFixed(6);
	case 3:
		return val_float[ofs].toFixed(6) + " " + val_float[ofs + 1].toFixed(6) + " " + val_float[ofs + 2].toFixed(6);
	case 4:
		return Std.string(val_int[ofs]);
	case 5:
		var def = quake_ED.FieldAtOfs(val_int[ofs]);
		if(def != null) {
			return quake_PR.GetString(def.name);
		}
		return "";
	case 6:
		return quake_PR.GetString(quake_PR.functions[val_int[ofs]].name);
	default:
		return "bad type " + type1;
	}
};
quake_PR.GlobalString = function(ofs) {
	var def = quake_ED.GlobalAtOfs(ofs);
	var line;
	if(def != null) {
		line = ofs + "(" + quake_PR.GetString(def.name) + ")" + quake_PR.ValueString(def.type,quake_PR.globals.buffer,ofs);
	} else {
		line = ofs + "(???)";
	}
	while(line.length <= 20) line += " ";
	return line;
};
quake_PR.GlobalStringNoContents = function(ofs) {
	var def = quake_ED.GlobalAtOfs(ofs);
	var line;
	if(def != null) {
		line = ofs + "(" + quake_PR.GetString(def.name) + ")";
	} else {
		line = ofs + "(???)";
	}
	while(line.length <= 20) line += " ";
	return line;
};
quake_PR.LoadProgs = function() {
	var progs = quake_COM.LoadFile("progs.dat");
	if(progs == null) {
		quake_Sys.Error("PR.LoadProgs: couldn't load progs.dat");
	}
	quake_Console.DPrint("Programs occupy " + (progs.byteLength >> 10) + "K.\n");
	var view = new DataView(progs);
	var i = view.getUint32(0,true);
	if(i != 6) {
		quake_Sys.Error("progs.dat has wrong version number (" + i + " should be " + 6 + ")");
	}
	if(view.getUint32(4,true) != 5927) {
		quake_Sys.Error("progs.dat system vars have been modified, PR.js is out of date");
	}
	quake_PR.crc = quake_CRC.Block(new Uint8Array(progs));
	quake_PR.stack = [];
	quake_PR.depth = 0;
	quake_PR.localstack = [];
	var _g = 0;
	var _g1 = quake_PR.localstack_size;
	while(_g < _g1) {
		++_g;
		quake_PR.localstack.push(0);
	}
	quake_PR.localstack_used = 0;
	var ofs = view.getUint32(8,true);
	var num = view.getUint32(12,true);
	quake_PR.statements = [];
	var _g2 = 0;
	var _g3 = num;
	while(_g2 < _g3) {
		++_g2;
		quake_PR.statements.push(new quake__$PR_PRStatement(view,ofs));
		ofs += 8;
	}
	ofs = view.getUint32(16,true);
	num = view.getUint32(20,true);
	quake_PR.globaldefs = [];
	var _g4 = 0;
	var _g5 = num;
	while(_g4 < _g5) {
		++_g4;
		quake_PR.globaldefs.push(new quake_PRDef(view,ofs));
		ofs += 8;
	}
	ofs = view.getUint32(24,true);
	num = view.getUint32(28,true);
	quake_PR.fielddefs = [];
	var _g6 = 0;
	var _g7 = num;
	while(_g6 < _g7) {
		++_g6;
		quake_PR.fielddefs.push(new quake_PRDef(view,ofs));
		ofs += 8;
	}
	ofs = view.getUint32(32,true);
	num = view.getUint32(36,true);
	quake_PR.functions = [];
	var _g8 = 0;
	var _g9 = num;
	while(_g8 < _g9) {
		++_g8;
		quake_PR.functions.push(new quake__$PR_PRFunction(view,ofs));
		ofs += 36;
	}
	ofs = view.getUint32(40,true);
	num = view.getUint32(44,true);
	quake_PR.strings = new Uint8Array(num);
	quake_PR.strings.set(new Uint8Array(progs,ofs,num));
	quake_PR.string_temp = quake_PR.NewString("",128);
	quake_PR.netnames = quake_PR.NewString("",quake_SV.svs.maxclients << 5);
	ofs = view.getUint32(48,true);
	num = view.getUint32(52,true);
	quake_PR.globals = new quake_GlobalVars(new ArrayBuffer(num << 2));
	var _g10 = 0;
	var _g11 = num;
	while(_g10 < _g11) {
		var i1 = _g10++;
		quake_PR.globals.ints[i1] = view.getInt32(ofs + (i1 << 2),true);
	}
	quake_PR.entityfields = view.getUint32(56,true);
	quake_PR.edict_size = 96 + (quake_PR.entityfields << 2);
	var def = quake_ED.FindField("ammo_shells1");
	if(def != null) {
		quake_EdictVars.ammo_shells1_ofs = def.ofs;
	}
	var def1 = quake_ED.FindField("ammo_nails1");
	if(def1 != null) {
		quake_EdictVars.ammo_nails1_ofs = def1.ofs;
	}
	var def2 = quake_ED.FindField("ammo_lava_nails");
	if(def2 != null) {
		quake_EdictVars.ammo_lava_nails_ofs = def2.ofs;
	}
	var def3 = quake_ED.FindField("ammo_rockets1");
	if(def3 != null) {
		quake_EdictVars.ammo_rockets1_ofs = def3.ofs;
	}
	var def4 = quake_ED.FindField("ammo_multi_rockets");
	if(def4 != null) {
		quake_EdictVars.ammo_multi_rockets_ofs = def4.ofs;
	}
	var def5 = quake_ED.FindField("ammo_cells1");
	if(def5 != null) {
		quake_EdictVars.ammo_cells1_ofs = def5.ofs;
	}
	var def6 = quake_ED.FindField("ammo_plasma");
	if(def6 != null) {
		quake_EdictVars.ammo_plasma_ofs = def6.ofs;
	}
	var def7 = quake_ED.FindField("gravity");
	if(def7 != null) {
		quake_EdictVars.gravity_ofs = def7.ofs;
	}
	var def8 = quake_ED.FindField("items2");
	if(def8 != null) {
		quake_EdictVars.items2_ofs = def8.ofs;
	}
};
quake_PR.Init = function() {
	quake_Cmd.AddCommand("edict",quake_ED.PrintEdict_f);
	quake_Cmd.AddCommand("edicts",quake_ED.PrintEdicts);
	quake_Cmd.AddCommand("edictcount",quake_ED.Count);
	quake_Cmd.AddCommand("profile",quake_PR.Profile_f);
	quake_Cvar.RegisterVariable("nomonsters","0");
	quake_Cvar.RegisterVariable("gamecfg","0");
	quake_Cvar.RegisterVariable("scratch1","0");
	quake_Cvar.RegisterVariable("scratch2","0");
	quake_Cvar.RegisterVariable("scratch3","0");
	quake_Cvar.RegisterVariable("scratch4","0");
	quake_Cvar.RegisterVariable("savedgamecfg","0",true);
	quake_Cvar.RegisterVariable("saved1","0",true);
	quake_Cvar.RegisterVariable("saved2","0",true);
	quake_Cvar.RegisterVariable("saved3","0",true);
	quake_Cvar.RegisterVariable("saved4","0",true);
};
quake_PR.PrintStatement = function(s) {
	var text;
	if(s.op < quake_PR.opnames.length) {
		text = quake_PR.opnames[s.op] + " ";
		while(text.length <= 9) text += " ";
	} else {
		text = "";
	}
	if(s.op == 49 || s.op == 50) {
		text += quake_PR.GlobalString(s.a) + "branch " + s.b;
	} else if(s.op == 61) {
		text += "branch " + s.a;
	} else if(s.op >= 31 && s.op <= 36) {
		text += quake_PR.GlobalString(s.a) + quake_PR.GlobalStringNoContents(s.b);
	} else {
		if(s.a != 0) {
			text += quake_PR.GlobalString(s.a);
		}
		if(s.b != 0) {
			text += quake_PR.GlobalString(s.b);
		}
		if(s.c != 0) {
			text += quake_PR.GlobalStringNoContents(s.c);
		}
	}
	quake_Console.Print(text + "\n");
};
quake_PR.StackTrace = function() {
	if(quake_PR.depth == 0) {
		quake_Console.Print("<NO STACK>\n");
		return;
	}
	quake_PR.stack[quake_PR.depth] = new quake__$PR_PRStackItem(quake_PR.xstatement,quake_PR.xfunction);
	while(quake_PR.depth >= 0) {
		var f = quake_PR.stack[quake_PR.depth--].func;
		if(f == null) {
			quake_Console.Print("<NO FUNCTION>\n");
			continue;
		}
		var file = quake_PR.GetString(f.file);
		while(file.length <= 11) file += " ";
		quake_Console.Print(file + " : " + quake_PR.GetString(f.name) + "\n");
	}
	quake_PR.depth = 0;
};
quake_PR.Profile_f = function() {
	if(!quake_SV.server.active) {
		return;
	}
	var num = 0;
	while(true) {
		var max = 0;
		var best = null;
		var _g = 0;
		var _g1 = quake_PR.functions;
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			if(f.profile > max) {
				max = f.profile;
				best = f;
			}
		}
		if(best == null) {
			return;
		}
		if(num < 10) {
			var profile = best.profile == null ? "null" : "" + best.profile;
			while(profile.length <= 6) profile = " " + profile;
			quake_Console.Print(profile + " " + quake_PR.GetString(best.name) + "\n");
		}
		++num;
		best.profile = 0;
	}
};
quake_PR.RunError = function(error) {
	quake_PR.PrintStatement(quake_PR.statements[quake_PR.xstatement]);
	quake_PR.StackTrace();
	quake_Console.Print(error + "\n");
	quake_Host.Error("Program error");
};
quake_PR.EnterFunction = function(f) {
	quake_PR.stack[quake_PR.depth++] = new quake__$PR_PRStackItem(quake_PR.xstatement,quake_PR.xfunction);
	var c = f.locals;
	if(quake_PR.localstack_used + c > quake_PR.localstack_size) {
		quake_PR.RunError("PR.EnterFunction: locals stack overflow\n");
	}
	var _g = 0;
	while(_g < c) {
		var i = _g++;
		quake_PR.localstack[quake_PR.localstack_used + i] = quake_PR.globals.ints[f.parm_start + i];
	}
	quake_PR.localstack_used += c;
	var o = f.parm_start;
	var _g2 = 0;
	var _g3 = f.numparms;
	while(_g2 < _g3) {
		var i1 = _g2++;
		var _g21 = 0;
		var _g31 = f.parm_size[i1];
		while(_g21 < _g31) quake_PR.globals.ints[o++] = quake_PR.globals.ints[4 + i1 * 3 + _g21++];
	}
	quake_PR.xfunction = f;
	return f.first_statement - 1;
};
quake_PR.LeaveFunction = function() {
	if(quake_PR.depth <= 0) {
		quake_Sys.Error("prog stack underflow");
	}
	var c = quake_PR.xfunction.locals;
	quake_PR.localstack_used -= c;
	if(quake_PR.localstack_used < 0) {
		quake_PR.RunError("PR.LeaveFunction: locals stack underflow\n");
	}
	--c;
	while(c >= 0) {
		quake_PR.globals.ints[quake_PR.xfunction.parm_start + c] = quake_PR.localstack[quake_PR.localstack_used + c];
		--c;
	}
	quake_PR.xfunction = quake_PR.stack[--quake_PR.depth].func;
	return quake_PR.stack[quake_PR.depth].stmt;
};
quake_PR.ExecuteProgram = function(fnum) {
	if(fnum == 0 || fnum >= quake_PR.functions.length) {
		if(quake_PR.globals.ints[28] != 0) {
			quake_ED.Print(quake_SV.server.edicts[quake_PR.globals.ints[28]]);
		}
		quake_Host.Error("PR.ExecuteProgram: NULL function");
	}
	var runaway = 100000;
	quake_PR.trace = false;
	var exitdepth = quake_PR.depth;
	var s = quake_PR.EnterFunction(quake_PR.functions[fnum]);
	while(true) {
		++s;
		var st = quake_PR.statements[s];
		if(--runaway == 0) {
			quake_PR.RunError("runaway loop error");
		}
		++quake_PR.xfunction.profile;
		quake_PR.xstatement = s;
		if(quake_PR.trace) {
			quake_PR.PrintStatement(st);
		}
		switch(st.op) {
		case 1:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] * quake_PR.globals.floats[st.b];
			break;
		case 2:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] * quake_PR.globals.floats[st.b] + quake_PR.globals.floats[st.a + 1] * quake_PR.globals.floats[st.b + 1] + quake_PR.globals.floats[st.a + 2] * quake_PR.globals.floats[st.b + 2];
			break;
		case 3:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] * quake_PR.globals.floats[st.b];
			quake_PR.globals.floats[st.c + 1] = quake_PR.globals.floats[st.a] * quake_PR.globals.floats[st.b + 1];
			quake_PR.globals.floats[st.c + 2] = quake_PR.globals.floats[st.a] * quake_PR.globals.floats[st.b + 2];
			break;
		case 4:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.b] * quake_PR.globals.floats[st.a];
			quake_PR.globals.floats[st.c + 1] = quake_PR.globals.floats[st.b] * quake_PR.globals.floats[st.a + 1];
			quake_PR.globals.floats[st.c + 2] = quake_PR.globals.floats[st.b] * quake_PR.globals.floats[st.a + 2];
			break;
		case 5:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] / quake_PR.globals.floats[st.b];
			break;
		case 6:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] + quake_PR.globals.floats[st.b];
			break;
		case 7:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] + quake_PR.globals.floats[st.b];
			quake_PR.globals.floats[st.c + 1] = quake_PR.globals.floats[st.a + 1] + quake_PR.globals.floats[st.b + 1];
			quake_PR.globals.floats[st.c + 2] = quake_PR.globals.floats[st.a + 2] + quake_PR.globals.floats[st.b + 2];
			break;
		case 8:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] - quake_PR.globals.floats[st.b];
			break;
		case 9:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] - quake_PR.globals.floats[st.b];
			quake_PR.globals.floats[st.c + 1] = quake_PR.globals.floats[st.a + 1] - quake_PR.globals.floats[st.b + 1];
			quake_PR.globals.floats[st.c + 2] = quake_PR.globals.floats[st.a + 2] - quake_PR.globals.floats[st.b + 2];
			break;
		case 10:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] == quake_PR.globals.floats[st.b] ? 1.0 : 0.0;
			break;
		case 11:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] == quake_PR.globals.floats[st.b] && quake_PR.globals.floats[st.a + 1] == quake_PR.globals.floats[st.b + 1] && quake_PR.globals.floats[st.a + 2] == quake_PR.globals.floats[st.b + 2] ? 1.0 : 0.0;
			break;
		case 12:
			quake_PR.globals.floats[st.c] = quake_PR.GetString(quake_PR.globals.ints[st.a]) == quake_PR.GetString(quake_PR.globals.ints[st.b]) ? 1.0 : 0.0;
			break;
		case 13:case 14:
			quake_PR.globals.floats[st.c] = quake_PR.globals.ints[st.a] == quake_PR.globals.ints[st.b] ? 1.0 : 0.0;
			break;
		case 15:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] != quake_PR.globals.floats[st.b] ? 1.0 : 0.0;
			break;
		case 16:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] != quake_PR.globals.floats[st.b] || quake_PR.globals.floats[st.a + 1] != quake_PR.globals.floats[st.b + 1] || quake_PR.globals.floats[st.a + 2] != quake_PR.globals.floats[st.b + 2] ? 1.0 : 0.0;
			break;
		case 17:
			quake_PR.globals.floats[st.c] = quake_PR.GetString(quake_PR.globals.ints[st.a]) != quake_PR.GetString(quake_PR.globals.ints[st.b]) ? 1.0 : 0.0;
			break;
		case 18:case 19:
			quake_PR.globals.floats[st.c] = quake_PR.globals.ints[st.a] != quake_PR.globals.ints[st.b] ? 1.0 : 0.0;
			break;
		case 20:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] <= quake_PR.globals.floats[st.b] ? 1.0 : 0.0;
			break;
		case 21:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] >= quake_PR.globals.floats[st.b] ? 1.0 : 0.0;
			break;
		case 22:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] < quake_PR.globals.floats[st.b] ? 1.0 : 0.0;
			break;
		case 23:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] > quake_PR.globals.floats[st.b] ? 1.0 : 0.0;
			break;
		case 25:
			var ed = quake_SV.server.edicts[quake_PR.globals.ints[st.a]];
			var ptr = quake_PR.globals.ints[st.b];
			quake_PR.globals.ints[st.c] = ed.v.ints[ptr];
			quake_PR.globals.ints[st.c + 1] = ed.v.ints[ptr + 1];
			quake_PR.globals.ints[st.c + 2] = ed.v.ints[ptr + 2];
			break;
		case 24:case 26:case 27:case 28:case 29:
			quake_PR.globals.ints[st.c] = quake_SV.server.edicts[quake_PR.globals.ints[st.a]].v.ints[quake_PR.globals.ints[st.b]];
			break;
		case 30:
			var ed1 = quake_PR.globals.ints[st.a];
			if(ed1 == 0 && !quake_SV.server.loading) {
				quake_PR.RunError("assignment to world entity");
			}
			quake_PR.globals.ints[st.c] = ed1 * quake_PR.edict_size + 96 + (quake_PR.globals.ints[st.b] << 2);
			break;
		case 32:
			quake_PR.globals.ints[st.b] = quake_PR.globals.ints[st.a];
			quake_PR.globals.ints[st.b + 1] = quake_PR.globals.ints[st.a + 1];
			quake_PR.globals.ints[st.b + 2] = quake_PR.globals.ints[st.a + 2];
			break;
		case 31:case 33:case 34:case 35:case 36:
			quake_PR.globals.ints[st.b] = quake_PR.globals.ints[st.a];
			break;
		case 38:
			var ed2 = quake_SV.server.edicts[Math.floor(quake_PR.globals.ints[st.b] / quake_PR.edict_size)];
			var ptr1 = quake_PR.globals.ints[st.b] % quake_PR.edict_size - 96 >> 2;
			ed2.v.ints[ptr1] = quake_PR.globals.ints[st.a];
			ed2.v.ints[ptr1 + 1] = quake_PR.globals.ints[st.a + 1];
			ed2.v.ints[ptr1 + 2] = quake_PR.globals.ints[st.a + 2];
			break;
		case 37:case 39:case 40:case 41:case 42:
			var ptr2 = quake_PR.globals.ints[st.b];
			quake_SV.server.edicts[Math.floor(ptr2 / quake_PR.edict_size)].v.ints[ptr2 % quake_PR.edict_size - 96 >> 2] = quake_PR.globals.ints[st.a];
			break;
		case 0:case 43:
			quake_PR.globals.ints[1] = quake_PR.globals.ints[st.a];
			quake_PR.globals.ints[2] = quake_PR.globals.ints[st.a + 1];
			quake_PR.globals.ints[3] = quake_PR.globals.ints[st.a + 2];
			s = quake_PR.LeaveFunction();
			if(quake_PR.depth == exitdepth) {
				return;
			}
			break;
		case 44:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] == 0.0 ? 1.0 : 0.0;
			break;
		case 45:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] == 0.0 && quake_PR.globals.floats[st.a + 1] == 0.0 && quake_PR.globals.floats[st.a + 2] == 0.0 ? 1.0 : 0.0;
			break;
		case 46:
			if(quake_PR.globals.ints[st.a] != 0) {
				quake_PR.globals.floats[st.c] = quake_PR.strings[quake_PR.globals.ints[st.a]] == 0 ? 1.0 : 0.0;
			} else {
				quake_PR.globals.floats[st.c] = 1.0;
			}
			break;
		case 47:case 48:
			quake_PR.globals.floats[st.c] = quake_PR.globals.ints[st.a] == 0 ? 1.0 : 0.0;
			break;
		case 49:
			if(quake_PR.globals.ints[st.a] != 0) {
				s += st.b - 1;
			}
			break;
		case 50:
			if(quake_PR.globals.ints[st.a] == 0) {
				s += st.b - 1;
			}
			break;
		case 51:case 52:case 53:case 54:case 55:case 56:case 57:case 58:case 59:
			if(quake_PR.globals.ints[st.a] == 0) {
				quake_PR.RunError("NULL function");
			}
			var newf = quake_PR.functions[quake_PR.globals.ints[st.a]];
			if(newf.first_statement < 0) {
				var argc = st.op - 51;
				var idx = -newf.first_statement;
				if(idx >= quake_PF.builtin.length) {
					quake_PR.RunError("Bad builtin call number");
				}
				quake_PF.argc = argc;
				quake_PF.builtin[idx]();
				continue;
			}
			s = quake_PR.EnterFunction(newf);
			break;
		case 60:
			var ed3 = quake_SV.server.edicts[quake_PR.globals.ints[28]];
			ed3.v.floats[46] = quake_PR.globals.floats[31] + 0.1;
			ed3.v.floats[30] = quake_PR.globals.floats[st.a];
			ed3.v.ints[44] = quake_PR.globals.ints[st.b];
			break;
		case 61:
			s += st.a - 1;
			break;
		case 62:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] != 0.0 && quake_PR.globals.floats[st.b] != 0.0 ? 1.0 : 0.0;
			break;
		case 63:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] != 0.0 || quake_PR.globals.floats[st.b] != 0.0 ? 1.0 : 0.0;
			break;
		case 64:
			quake_PR.globals.floats[st.c] = (quake_PR.globals.floats[st.a] | 0) & (quake_PR.globals.floats[st.b] | 0);
			break;
		case 65:
			quake_PR.globals.floats[st.c] = quake_PR.globals.floats[st.a] | 0 | (quake_PR.globals.floats[st.b] | 0);
			break;
		default:
			quake_PR.RunError("Bad opcode " + st.op);
		}
	}
};
quake_PR.GetString = function(num) {
	var buf_b = "";
	var _g = num;
	var _g1 = quake_PR.strings.length;
	while(_g < _g1) {
		var num1 = _g++;
		if(quake_PR.strings[num1] == 0) {
			break;
		}
		var c = quake_PR.strings[num1];
		buf_b += String.fromCodePoint(c);
	}
	return buf_b;
};
quake_PR.NewString = function(s,length) {
	var ofs = quake_PR.strings.length;
	var old_strings = quake_PR.strings;
	quake_PR.strings = new Uint8Array(ofs + length);
	quake_PR.strings.set(old_strings);
	var _g = 0;
	var _g1 = s.length >= length ? length - 1 : s.length;
	while(_g < _g1) {
		var i = _g++;
		quake_PR.strings[ofs + i] = HxOverrides.cca(s,i);
	}
	return ofs;
};
quake_PR.TempString = function(string) {
	if(string.length > 127) {
		string = string.substring(0,127);
	}
	var _g = 0;
	var _g1 = string.length;
	while(_g < _g1) {
		var i = _g++;
		quake_PR.strings[quake_PR.string_temp + i] = HxOverrides.cca(string,i);
	}
	quake_PR.strings[quake_PR.string_temp + string.length] = 0;
};
var quake_VID = function() { };
quake_VID.__name__ = true;
quake_VID.SetPalette = function() {
	var palette = quake_COM.LoadFile("gfx/palette.lmp");
	if(palette == null) {
		quake_Sys.Error("Couldn't load gfx/palette.lmp");
	}
	var pal = new Uint8Array(palette);
	var src = 0;
	var _g = 0;
	while(_g < 256) {
		quake_VID.d_8to24table[_g++] = pal[src] + (pal[src + 1] << 8) + (pal[src + 2] << 16);
		src += 3;
	}
};
quake_VID.Init = function() {
	window.document.getElementById("progress").style.display = "none";
	quake_GL.Init();
	quake_VID.SetPalette();
};
var quake_Q = function() { };
quake_Q.__name__ = true;
quake_Q.memstr = function(src) {
	var dest = [];
	var _g = 0;
	var _g1 = src.length;
	while(_g < _g1) {
		var i = _g++;
		if(src[i] == 0) {
			break;
		}
		dest.push(String.fromCodePoint(src[i]));
	}
	return dest.join("");
};
quake_Q.strmem = function(src) {
	var buf = new ArrayBuffer(src.length);
	var dest = new Uint8Array(buf);
	var _g = 0;
	var _g1 = src.length;
	while(_g < _g1) {
		var i = _g++;
		dest[i] = HxOverrides.cca(src,i) & 255;
	}
	return buf;
};
quake_Q.atoi = function(str) {
	if(str == null) {
		return 0;
	}
	var ptr;
	var sign;
	if(HxOverrides.cca(str,0) == 45) {
		sign = -1;
		ptr = 1;
	} else {
		sign = 1;
		ptr = 0;
	}
	var c = HxOverrides.cca(str,ptr);
	var c2 = HxOverrides.cca(str,ptr + 1);
	var val = 0;
	if(c == 48 && (c2 == 120 || c2 == 88)) {
		ptr += 2;
		while(true) {
			c = HxOverrides.cca(str,ptr++);
			if(c >= 48 && c <= 57) {
				val = (val << 4) + c - 48;
			} else if(c >= 97 && c <= 102) {
				val = (val << 4) + c - 87;
			} else if(c >= 65 && c <= 70) {
				val = (val << 4) + c - 55;
			} else {
				return val * sign;
			}
		}
	}
	if(c == 39) {
		if(c2 == null) {
			return 0;
		}
		return sign * c2;
	}
	while(true) {
		c = HxOverrides.cca(str,ptr++);
		if(c == null || c <= 47 || c >= 58) {
			return val * sign;
		}
		val = val * 10 + c - 48;
	}
};
quake_Q.atof = function(str) {
	if(str == null) {
		return 0.0;
	}
	var ptr;
	var sign;
	if(HxOverrides.cca(str,0) == 45) {
		sign = -1;
		ptr = 1;
	} else {
		sign = 1;
		ptr = 0;
	}
	var c = HxOverrides.cca(str,ptr);
	var c2 = HxOverrides.cca(str,ptr + 1);
	var val;
	if(c == 48 && (c2 == 120 || c2 == 88)) {
		ptr += 2;
		val = 0.0;
		while(true) {
			c = HxOverrides.cca(str,ptr++);
			if(c >= 48 && c <= 57) {
				val = val * 16 + c - 48;
			} else if(c >= 97 && c <= 102) {
				val = val * 16 + c - 87;
			} else if(c >= 65 && c <= 70) {
				val = val * 16 + c - 55;
			} else {
				return val * sign;
			}
		}
	}
	if(c == 39) {
		if(isNaN(c2)) {
			return 0;
		}
		return sign * c2;
	}
	val = parseFloat(str);
	if(isNaN(val)) {
		return 0;
	}
	return val;
};
quake_Q.btoa = function(src) {
	var val = [];
	var len = src.length - src.length % 3;
	var i = 0;
	while(i < len) {
		var c = (src[i] << 16) + (src[i + 1] << 8) + src[i + 2];
		val.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c >> 18) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c >> 12 & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c >> 6 & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c & 63));
		i += 3;
	}
	if(src.length - len == 1) {
		var c1 = src[len];
		val.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c1 >> 2) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((c1 & 3) << 4) + "==");
	} else if(src.length - len == 2) {
		var c2 = (src[len] << 8) + src[len + 1];
		val.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c2 >> 10) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c2 >> 4 & 63) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((c2 & 15) << 2) + "=");
	}
	return val.join("");
};
var quake_S = function() { };
quake_S.__name__ = true;
quake_S.Init = function() {
	quake_Console.Print("\nSound Initialization\n");
	quake_Cmd.AddCommand("play",quake_S.Play);
	quake_Cmd.AddCommand("playvol",quake_S.PlayVol);
	quake_Cmd.AddCommand("stopsound",quake_S.StopAllSounds);
	quake_Cmd.AddCommand("soundlist",quake_S.SoundList);
	quake_S.nosound = quake_Cvar.RegisterVariable("nosound",quake_COM.CheckParm("-nosound") != null ? "1" : "0");
	quake_S.volume = quake_Cvar.RegisterVariable("volume","0.7",true);
	quake_S.precache = quake_Cvar.RegisterVariable("precache","1");
	quake_S.bgmvolume = quake_Cvar.RegisterVariable("bgmvolume","1",true);
	quake_S.ambient_level = quake_Cvar.RegisterVariable("ambient_level","0.3");
	quake_S.ambient_fade = quake_Cvar.RegisterVariable("ambient_fade","100");
	quake_S.started = true;
	quake_S.context = new AudioContext();
	var ambient_sfx = ["water1","wind2"];
	var _g = 0;
	var _g1 = ambient_sfx.length;
	while(_g < _g1) {
		var ch = [new quake__$S_Channel(quake_S.PrecacheSound("ambience/" + ambient_sfx[_g++] + ".wav",false))];
		quake_S.ambient_channels.push(ch[0]);
		quake_S.LoadSound(ch[0].sfx,(function(ch1) {
			return function(success) {
				if(!success) {
					return;
				}
				if(ch1[0].sfx.cache.loopstart == null) {
					quake_Console.Print("Sound ambience/" + ch1[0].sfx.name + ".wav not looped\n");
					return;
				}
				var nodes = { source : quake_S.context.createBufferSource(), gain0 : quake_S.context.createGain()};
				ch1[0].nodes = nodes;
				nodes.source.buffer = ch1[0].sfx.cache.data;
				nodes.source.loop = true;
				nodes.source.loopStart = ch1[0].sfx.cache.loopstart;
				nodes.source.loopEnd = nodes.source.buffer.length;
				nodes.source.connect(nodes.gain0);
				nodes.gain0.connect(quake_S.context.destination);
			};
		})(ch));
	}
	quake_Console.sfx_talk = quake_S.PrecacheSound("misc/talk.wav");
};
quake_S.PrecacheSound = function(name,load) {
	if(load == null) {
		load = true;
	}
	if(quake_S.nosound.value != 0) {
		return null;
	}
	var sfx = null;
	var _g = 0;
	var _g1 = quake_S.known_sfx;
	while(_g < _g1.length) {
		var s = _g1[_g];
		++_g;
		if(s.name == name) {
			sfx = s;
			break;
		}
	}
	if(sfx == null) {
		sfx = new quake_Sfx(name);
		quake_S.known_sfx.push(sfx);
	}
	if(load && quake_S.precache.value != 0) {
		quake_S.LoadSound(sfx,function(_) {
		});
	}
	return sfx;
};
quake_S.PickChannel = function(entnum,entchannel) {
	var i = null;
	var channel = null;
	if(entchannel != 0) {
		i = 0;
		while(i < quake_S.channels.length) {
			channel = quake_S.channels[i++];
			if(channel == null) {
				continue;
			}
			if(channel.entnum == entnum && (channel.entchannel == entchannel || entchannel == -1)) {
				channel.sfx = null;
				if(channel.nodes != null) {
					quake_S.NoteOff(channel.nodes.source);
					channel.nodes = null;
				}
				break;
			}
		}
	}
	if(entchannel == 0 || i == quake_S.channels.length) {
		i = 0;
		while(i < quake_S.channels.length) {
			channel = quake_S.channels[i++];
			if(channel == null) {
				break;
			}
			if(channel.sfx == null) {
				break;
			}
		}
	}
	if(i == quake_S.channels.length) {
		channel = new quake__$S_Channel();
		quake_S.channels.push(channel);
	}
	return channel;
};
quake_S.Spatialize = function(ch) {
	if(ch.entnum == quake_CL.state.viewentity) {
		ch.leftvol = ch.master_vol;
		ch.rightvol = ch.master_vol;
		return;
	}
	var source_0 = ch.origin[0] - quake_S.listener_origin[0];
	var source_1 = ch.origin[1] - quake_S.listener_origin[1];
	var source_2 = ch.origin[2] - quake_S.listener_origin[2];
	var dist = Math.sqrt(source_0 * source_0 + source_1 * source_1 + source_2 * source_2);
	if(dist != 0.0) {
		source_0 /= dist;
		source_1 /= dist;
		source_2 /= dist;
	}
	dist *= ch.dist_mult;
	var dot = quake_S.listener_right[0] * source_0 + quake_S.listener_right[1] * source_1 + quake_S.listener_right[2] * source_2;
	ch.rightvol = ch.master_vol * (1.0 - dist) * (1.0 + dot);
	if(ch.rightvol < 0.0) {
		ch.rightvol = 0.0;
	}
	ch.leftvol = ch.master_vol * (1.0 - dist) * (1.0 - dot);
	if(ch.leftvol < 0.0) {
		ch.leftvol = 0.0;
	}
};
quake_S.StartSound = function(entnum,entchannel,sfx,origin,vol,attenuation) {
	if(quake_S.nosound.value != 0 || sfx == null) {
		return;
	}
	var target_chan = quake_S.PickChannel(entnum,entchannel);
	target_chan.origin = new Float32Array(origin);
	target_chan.dist_mult = attenuation * 0.001;
	target_chan.master_vol = vol;
	target_chan.entnum = entnum;
	target_chan.entchannel = entchannel;
	quake_S.Spatialize(target_chan);
	if(target_chan.leftvol == 0.0 && target_chan.rightvol == 0.0) {
		return;
	}
	quake_S.LoadSound(sfx,function(success) {
		if(!success) {
			target_chan.sfx = null;
			return;
		}
		target_chan.sfx = sfx;
		target_chan.pos = 0.0;
		target_chan.end = quake_Host.realtime + sfx.cache.length;
		var nodes_source = quake_S.context.createBufferSource();
		var nodes_merger1 = quake_S.context.createChannelMerger(2);
		var nodes_splitter = quake_S.context.createChannelSplitter(2);
		var nodes_gain0 = quake_S.context.createGain();
		var nodes_gain1 = quake_S.context.createGain();
		var nodes_merger2 = quake_S.context.createChannelMerger(2);
		target_chan.nodes = { source : nodes_source, gain0 : nodes_gain0, gain1 : nodes_gain1};
		nodes_source.buffer = sfx.cache.data;
		if(sfx.cache.loopstart != null) {
			nodes_source.loop = true;
			nodes_source.loopStart = sfx.cache.loopstart;
			nodes_source.loopEnd = nodes_source.buffer.length;
		}
		nodes_source.connect(nodes_merger1);
		nodes_source.connect(nodes_merger1,0,1);
		nodes_merger1.connect(nodes_splitter);
		nodes_splitter.connect(nodes_gain0,0);
		nodes_splitter.connect(nodes_gain1,1);
		var volume = target_chan.leftvol;
		if(volume > 1.0) {
			volume = 1.0;
		}
		nodes_gain0.gain.value = volume * quake_S.volume.value;
		nodes_gain0.connect(nodes_merger2,0,0);
		volume = target_chan.rightvol;
		if(volume > 1.0) {
			volume = 1.0;
		}
		nodes_gain1.gain.value = volume * quake_S.volume.value;
		nodes_gain1.connect(nodes_merger2,0,1);
		nodes_merger2.connect(quake_S.context.destination);
		var _g = 0;
		var _g1 = quake_S.channels;
		while(_g < _g1.length) {
			var check = _g1[_g];
			++_g;
			if(check == target_chan) {
				continue;
			}
			if(check.sfx != sfx || check.pos != 0.0) {
				continue;
			}
			var skip = Math.random() * 0.1;
			if(skip >= sfx.cache.length) {
				quake_S.NoteOn(nodes_source);
				break;
			}
			target_chan.pos += skip;
			target_chan.end -= skip;
			nodes_source.start(0.0,skip,nodes_source.buffer.length - skip);
			break;
		}
		quake_S.NoteOn(nodes_source);
	});
};
quake_S.StopSound = function(entnum,entchannel) {
	if(quake_S.nosound.value != 0) {
		return;
	}
	var _g = 0;
	var _g1 = quake_S.channels;
	while(_g < _g1.length) {
		var ch = _g1[_g];
		++_g;
		if(ch == null) {
			continue;
		}
		if(ch.entnum == entnum && ch.entchannel == entchannel) {
			ch.end = 0.0;
			ch.sfx = null;
			if(ch.nodes != null) {
				quake_S.NoteOff(ch.nodes.source);
				ch.nodes = null;
			}
			return;
		}
	}
};
quake_S.NoteOff = function(node) {
	try {
		node.stop();
	} catch( _ ) {
	}
};
quake_S.NoteOn = function(node) {
	try {
		node.start();
	} catch( _ ) {
	}
};
quake_S.StopAllSounds = function() {
	if(quake_S.nosound.value != 0) {
		return;
	}
	var _g = 0;
	var _g1 = quake_S.ambient_channels;
	while(_g < _g1.length) {
		var ch = _g1[_g];
		++_g;
		ch.master_vol = 0.0;
		if(ch.nodes != null) {
			quake_S.NoteOff(ch.nodes.source);
		}
	}
	var _g2 = 0;
	var _g3 = quake_S.channels;
	while(_g2 < _g3.length) {
		var ch1 = _g3[_g2];
		++_g2;
		if(ch1 == null) {
			continue;
		}
		if(ch1.nodes != null) {
			quake_S.NoteOff(ch1.nodes.source);
		}
	}
	quake_S.channels = [];
	var _g4 = 0;
	var _g5 = quake_S.static_channels;
	while(_g4 < _g5.length) quake_S.NoteOff(_g5[_g4++].nodes.source);
	quake_S.static_channels = [];
};
quake_S.StaticSound = function(sfx,origin,vol,attenuation) {
	if(quake_S.nosound.value != 0 || sfx == null) {
		return;
	}
	quake_S.LoadSound(sfx,function(success) {
		if(!success) {
			return;
		}
		if(sfx.cache.loopstart == null) {
			quake_Console.Print("Sound " + sfx.name + " not looped\n");
			return;
		}
		var ss = new quake__$S_Channel(sfx);
		ss.origin = new Float32Array(origin);
		ss.master_vol = vol;
		ss.dist_mult = attenuation * 0.000015625;
		ss.end = quake_Host.realtime + sfx.cache.length;
		quake_S.static_channels.push(ss);
		var nodes_source = quake_S.context.createBufferSource();
		var nodes_merger1 = quake_S.context.createChannelMerger(2);
		var nodes_splitter = quake_S.context.createChannelSplitter(2);
		var nodes_gain0 = quake_S.context.createGain();
		var nodes_gain1 = quake_S.context.createGain();
		var nodes_merger2 = quake_S.context.createChannelMerger(2);
		ss.nodes = { source : nodes_source, gain0 : nodes_gain0, gain1 : nodes_gain1};
		nodes_source.buffer = sfx.cache.data;
		nodes_source.loop = true;
		nodes_source.loopStart = sfx.cache.loopstart;
		nodes_source.loopEnd = nodes_source.buffer.length;
		nodes_source.connect(nodes_merger1);
		nodes_source.connect(nodes_merger1,0,1);
		nodes_merger1.connect(nodes_splitter);
		nodes_splitter.connect(nodes_gain0,0);
		nodes_splitter.connect(nodes_gain1,1);
		nodes_gain0.connect(nodes_merger2,0,0);
		nodes_gain1.connect(nodes_merger2,0,1);
		nodes_merger2.connect(quake_S.context.destination);
	});
};
quake_S.SoundList = function() {
	var total = 0;
	var _g = 0;
	var _g1 = quake_S.known_sfx;
	while(_g < _g1.length) {
		var sfx = _g1[_g];
		++_g;
		var sc = sfx.cache;
		if(sc == null) {
			continue;
		}
		var size = sc.size == null ? "null" : "" + sc.size;
		total += sc.size;
		while(size.length <= 5) size = " " + size;
		if(sc.loopstart != null) {
			size = "L" + size;
		} else {
			size = " " + size;
		}
		quake_Console.Print(size + " : " + sfx.name + "\n");
	}
	quake_Console.Print("Total resident: " + total + "\n");
};
quake_S.UpdateAmbientSounds = function() {
	if(quake_CL.state.worldmodel == null) {
		return;
	}
	var l = quake_Mod_$Brush.PointInLeaf(quake_S.listener_origin,quake_CL.state.worldmodel);
	if(l == null || quake_S.ambient_level.value == 0) {
		var _g = 0;
		var _g1 = quake_S.ambient_channels;
		while(_g < _g1.length) {
			var ch = _g1[_g];
			++_g;
			ch.master_vol = 0.0;
			if(ch.nodes != null) {
				quake_S.NoteOff(ch.nodes.source);
			}
		}
		return;
	}
	var _g2 = 0;
	var _g11 = quake_S.ambient_channels.length;
	while(_g2 < _g11) {
		var i = _g2++;
		var ch1 = quake_S.ambient_channels[i];
		if(ch1.nodes == null) {
			continue;
		}
		var vol = quake_S.ambient_level.value * l.ambient_level[i];
		if(vol < 8.0) {
			vol = 0.0;
		}
		vol /= 255.0;
		if(ch1.master_vol < vol) {
			ch1.master_vol += quake_Host.frametime * quake_S.ambient_fade.value / 255.0;
			if(ch1.master_vol > vol) {
				ch1.master_vol = vol;
			}
		} else if(ch1.master_vol > vol) {
			ch1.master_vol -= quake_Host.frametime * quake_S.ambient_fade.value / 255.0;
			if(ch1.master_vol < vol) {
				ch1.master_vol = vol;
			}
		}
		if(ch1.master_vol == 0.0) {
			quake_S.NoteOff(ch1.nodes.source);
			continue;
		}
		if(ch1.master_vol > 1.0) {
			ch1.master_vol = 1.0;
		}
		ch1.nodes.gain0.gain.value = ch1.master_vol * quake_S.volume.value;
		quake_S.NoteOn(ch1.nodes.source);
	}
};
quake_S.UpdateDynamicSounds = function() {
	var _g = 0;
	var _g1 = quake_S.channels;
	while(_g < _g1.length) {
		var ch = _g1[_g];
		++_g;
		if(ch == null) {
			continue;
		}
		if(ch.sfx == null) {
			continue;
		}
		if(quake_Host.realtime >= ch.end) {
			var sc = ch.sfx.cache;
			if(sc.loopstart != null) {
				ch.end = quake_Host.realtime + sc.length - sc.loopstart;
			} else {
				ch.sfx = null;
				ch.nodes = null;
				continue;
			}
		}
		quake_S.Spatialize(ch);
		if(ch.leftvol > 1.0) {
			ch.leftvol = 1.0;
		}
		if(ch.rightvol > 1.0) {
			ch.rightvol = 1.0;
		}
		ch.nodes.gain0.gain.value = ch.leftvol * quake_S.volume.value;
		ch.nodes.gain1.gain.value = ch.rightvol * quake_S.volume.value;
	}
};
quake_S.UpdateStaticSounds = function() {
	var _g = 0;
	var _g1 = quake_S.static_channels;
	while(_g < _g1.length) quake_S.Spatialize(_g1[_g++]);
	var _g2 = 0;
	var _g3 = quake_S.static_channels.length;
	while(_g2 < _g3) {
		var i = _g2++;
		var ch = quake_S.static_channels[i];
		if(ch.leftvol == 0.0 && ch.rightvol == 0.0) {
			continue;
		}
		var sfx = ch.sfx;
		var _g21 = i + 1;
		var _g31 = quake_S.static_channels.length;
		while(_g21 < _g31) {
			var ch2 = quake_S.static_channels[_g21++];
			if(sfx == ch2.sfx) {
				ch.leftvol += ch2.leftvol;
				ch.rightvol += ch2.rightvol;
				ch2.leftvol = 0.0;
				ch2.rightvol = 0.0;
			}
		}
	}
	var _g4 = 0;
	var _g5 = quake_S.static_channels;
	while(_g4 < _g5.length) {
		var ch1 = _g5[_g4];
		++_g4;
		if(ch1.leftvol == 0.0 && ch1.rightvol == 0.0) {
			quake_S.NoteOff(ch1.nodes.source);
			continue;
		}
		if(ch1.leftvol > 1.0) {
			ch1.leftvol = 1.0;
		}
		if(ch1.rightvol > 1.0) {
			ch1.rightvol = 1.0;
		}
		ch1.nodes.gain0.gain.value = ch1.leftvol * quake_S.volume.value;
		ch1.nodes.gain1.gain.value = ch1.rightvol * quake_S.volume.value;
		quake_S.NoteOn(ch1.nodes.source);
	}
};
quake_S.Update = function(origin,forward,right,up) {
	if(quake_S.nosound.value != 0) {
		return;
	}
	quake_S.listener_origin[0] = origin[0];
	quake_S.listener_origin[1] = origin[1];
	quake_S.listener_origin[2] = origin[2];
	quake_S.listener_forward[0] = forward[0];
	quake_S.listener_forward[1] = forward[1];
	quake_S.listener_forward[2] = forward[2];
	quake_S.listener_right[0] = right[0];
	quake_S.listener_right[1] = right[1];
	quake_S.listener_right[2] = right[2];
	quake_S.listener_up[0] = up[0];
	quake_S.listener_up[1] = up[1];
	quake_S.listener_up[2] = up[2];
	if(quake_S.volume.value < 0.0) {
		quake_S.volume.setValue(0.0);
	} else if(quake_S.volume.value > 1.0) {
		quake_S.volume.setValue(1.0);
	}
	quake_S.UpdateAmbientSounds();
	quake_S.UpdateDynamicSounds();
	quake_S.UpdateStaticSounds();
};
quake_S.Play = function() {
	if(quake_S.nosound.value != 0) {
		return;
	}
	var _g = 1;
	var _g1 = quake_Cmd.argv.length;
	while(_g < _g1) {
		var sfx = quake_S.PrecacheSound(quake_COM.DefaultExtension(quake_Cmd.argv[_g++],".wav"));
		if(sfx != null) {
			quake_S.StartSound(quake_CL.state.viewentity,0,sfx,quake_S.listener_origin,1.0,1.0);
		}
	}
};
quake_S.PlayVol = function() {
	if(quake_S.nosound.value != 0) {
		return;
	}
	var i = 1;
	while(i < quake_Cmd.argv.length) {
		var sfx = quake_S.PrecacheSound(quake_COM.DefaultExtension(quake_Cmd.argv[i],".wav"));
		if(sfx != null) {
			quake_S.StartSound(quake_CL.state.viewentity,0,sfx,quake_S.listener_origin,quake_Q.atof(quake_Cmd.argv[i + 1]),1.0);
		}
		i += 2;
	}
};
quake_S.LoadSound = function(s,cb) {
	if(quake_S.nosound.value != 0) {
		cb(false);
		return;
	}
	if(s.cache != null) {
		cb(true);
		return;
	}
	var sc = new quake__$S_SfxCache();
	var data = quake_COM.LoadFile("sound/" + s.name);
	if(data == null) {
		quake_Console.Print("Couldn't load sound/" + s.name + "\n");
		cb(false);
		return;
	}
	var view = new DataView(data);
	if(view.getUint32(0,true) != 1179011410 || view.getUint32(8,true) != 1163280727) {
		quake_Console.Print("Missing RIFF/WAVE chunks\n");
		cb(false);
		return;
	}
	var p = 12;
	var fmt = null;
	var dataofs = null;
	var datalen = null;
	var cue = null;
	var loopstart = null;
	var samples = null;
	while(p < data.byteLength) {
		switch(view.getUint32(p,true)) {
		case 543520099:
			cue = true;
			loopstart = view.getUint32(p + 32,true);
			break;
		case 544501094:
			if(view.getInt16(p + 8,true) != 1) {
				quake_Console.Print("Microsoft PCM format only\n");
				cb(false);
				return;
			}
			fmt = { channels : view.getUint16(p + 10,true), samplesPerSec : view.getUint32(p + 12,true), avgBytesPerSec : view.getUint32(p + 16,true), blockAlign : view.getUint16(p + 20,true), bitsPerSample : view.getUint16(p + 22,true)};
			break;
		case 1414744396:
			if(cue) {
				cue = false;
				if(view.getUint32(p + 28,true) == 1802658157) {
					samples = loopstart + view.getUint32(p + 24,true);
				}
			}
			break;
		case 1635017060:
			dataofs = p + 8;
			datalen = view.getUint32(p + 4,true);
			break;
		}
		p += view.getUint32(p + 4,true) + 8;
		if((p & 1) != 0) {
			++p;
		}
	}
	if(fmt == null) {
		quake_Console.Print("Missing fmt chunk\n");
		cb(false);
		return;
	}
	if(dataofs == null) {
		quake_Console.Print("Missing data chunk\n");
		cb(false);
		return;
	}
	if(loopstart != null) {
		sc.loopstart = loopstart * fmt.blockAlign / fmt.samplesPerSec;
	}
	if(samples != null) {
		sc.length = samples / fmt.samplesPerSec;
	} else {
		sc.length = datalen / fmt.avgBytesPerSec;
	}
	sc.size = datalen + 44;
	if((sc.size & 1) != 0) {
		++sc.size;
	}
	var out = new ArrayBuffer(sc.size);
	view = new DataView(out);
	view.setUint32(0,1179011410,true);
	view.setUint32(4,sc.size - 8,true);
	view.setUint32(8,1163280727,true);
	view.setUint32(12,544501094,true);
	view.setUint32(16,16,true);
	view.setUint16(20,1,true);
	view.setUint16(22,fmt.channels,true);
	view.setUint32(24,fmt.samplesPerSec,true);
	view.setUint32(28,fmt.avgBytesPerSec,true);
	view.setUint16(32,fmt.blockAlign,true);
	view.setUint16(34,fmt.bitsPerSample,true);
	view.setUint32(36,1635017060,true);
	view.setUint32(40,datalen,true);
	new Uint8Array(out,44,datalen).set(new Uint8Array(data,dataofs,datalen));
	quake_S.context.decodeAudioData(out,function(data1) {
		sc.data = data1;
		s.cache = sc;
		cb(true);
		return;
	});
};
var quake__$S_Channel = function(s) {
	this.sfx = s;
	this.end = 0.0;
	this.master_vol = 0.0;
};
quake__$S_Channel.__name__ = true;
var quake__$S_SfxCache = function() {
};
quake__$S_SfxCache.__name__ = true;
var quake__$Vec_Vec_$Impl_$ = {};
quake__$Vec_Vec_$Impl_$.__name__ = true;
quake__$Vec_Vec_$Impl_$.Perpendicular = function(v) {
	var pos = 0;
	var minelem = 1.0;
	if(Math.abs(v[0]) < 1.0) {
		pos = 0;
		minelem = Math.abs(v[0]);
	}
	if(Math.abs(v[1]) < minelem) {
		pos = 1;
		minelem = Math.abs(v[1]);
	}
	if(Math.abs(v[2]) < minelem) {
		pos = 2;
		minelem = Math.abs(v[2]);
	}
	var tempvec = [0.0,0.0,0.0];
	tempvec[pos] = 1.0;
	var inv_denom = 1.0 / (v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
	var d = (tempvec[0] * v[0] + tempvec[1] * v[1] + tempvec[2] * v[2]) * inv_denom;
	var v1 = new Float32Array(3);
	v1[0] = tempvec[0] - d * v[0] * inv_denom;
	v1[1] = tempvec[1] - d * v[1] * inv_denom;
	v1[2] = tempvec[2] - d * v[2] * inv_denom;
	quake__$Vec_Vec_$Impl_$.Normalize(v1);
	return v1;
};
quake__$Vec_Vec_$Impl_$.RotatePointAroundVector = function(dir,point,degrees,out) {
	var r = quake__$Vec_Vec_$Impl_$.Perpendicular(dir);
	var up = quake__$Vec_Vec_$Impl_$.CrossProduct(r,dir);
	var m = [[r[0],up[0],dir[0]],[r[1],up[1],dir[1]],[r[2],up[2],dir[2]]];
	var s = Math.sin(degrees * Math.PI / 180.0);
	var c = Math.cos(degrees * Math.PI / 180.0);
	var rot = quake__$Vec_Vec_$Impl_$.ConcatRotations(quake__$Vec_Vec_$Impl_$.ConcatRotations(m,[[c,s,0],[-s,c,0],[0.0,0.0,1.0]]),[[m[0][0],m[1][0],m[2][0]],[m[0][1],m[1][1],m[2][1]],[m[0][2],m[1][2],m[2][2]]]);
	out[0] = rot[0][0] * point[0] + rot[0][1] * point[1] + rot[0][2] * point[2];
	out[1] = rot[1][0] * point[0] + rot[1][1] * point[1] + rot[1][2] * point[2];
	out[2] = rot[2][0] * point[0] + rot[2][1] * point[1] + rot[2][2] * point[2];
	return out;
};
quake__$Vec_Vec_$Impl_$.Anglemod = function(a) {
	return (a % 360.0 + 360.0) % 360.0;
};
quake__$Vec_Vec_$Impl_$.BoxOnPlaneSide = function(emins,emaxs,p) {
	if(p.type <= 2) {
		if(p.dist <= emins[p.type]) {
			return 1;
		}
		if(p.dist >= emaxs[p.type]) {
			return 2;
		}
		return 3;
	}
	var dist1 = null;
	var dist2 = null;
	switch(p.signbits) {
	case 0:
		dist1 = p.normal[0] * emaxs[0] + p.normal[1] * emaxs[1] + p.normal[2] * emaxs[2];
		dist2 = p.normal[0] * emins[0] + p.normal[1] * emins[1] + p.normal[2] * emins[2];
		break;
	case 1:
		dist1 = p.normal[0] * emins[0] + p.normal[1] * emaxs[1] + p.normal[2] * emaxs[2];
		dist2 = p.normal[0] * emaxs[0] + p.normal[1] * emins[1] + p.normal[2] * emins[2];
		break;
	case 2:
		dist1 = p.normal[0] * emaxs[0] + p.normal[1] * emins[1] + p.normal[2] * emaxs[2];
		dist2 = p.normal[0] * emins[0] + p.normal[1] * emaxs[1] + p.normal[2] * emins[2];
		break;
	case 3:
		dist1 = p.normal[0] * emins[0] + p.normal[1] * emins[1] + p.normal[2] * emaxs[2];
		dist2 = p.normal[0] * emaxs[0] + p.normal[1] * emaxs[1] + p.normal[2] * emins[2];
		break;
	case 4:
		dist1 = p.normal[0] * emaxs[0] + p.normal[1] * emaxs[1] + p.normal[2] * emins[2];
		dist2 = p.normal[0] * emins[0] + p.normal[1] * emins[1] + p.normal[2] * emaxs[2];
		break;
	case 5:
		dist1 = p.normal[0] * emins[0] + p.normal[1] * emaxs[1] + p.normal[2] * emins[2];
		dist2 = p.normal[0] * emaxs[0] + p.normal[1] * emins[1] + p.normal[2] * emaxs[2];
		break;
	case 6:
		dist1 = p.normal[0] * emaxs[0] + p.normal[1] * emins[1] + p.normal[2] * emins[2];
		dist2 = p.normal[0] * emins[0] + p.normal[1] * emaxs[1] + p.normal[2] * emaxs[2];
		break;
	case 7:
		dist1 = p.normal[0] * emins[0] + p.normal[1] * emins[1] + p.normal[2] * emins[2];
		dist2 = p.normal[0] * emaxs[0] + p.normal[1] * emaxs[1] + p.normal[2] * emaxs[2];
		break;
	default:
		quake_Sys.Error("Vec.BoxOnPlaneSide: Bad signbits");
	}
	var sides = 0;
	if(dist1 >= p.dist) {
		sides = 1;
	}
	if(dist2 < p.dist) {
		sides += 2;
	}
	return sides;
};
quake__$Vec_Vec_$Impl_$.AngleVectors = function(angles,forward,right,up) {
	var angle = angles[0] * Math.PI / 180.0;
	var sp = Math.sin(angle);
	var cp = Math.cos(angle);
	angle = angles[1] * Math.PI / 180.0;
	var sy = Math.sin(angle);
	var cy = Math.cos(angle);
	angle = angles[2] * Math.PI / 180.0;
	var sr = Math.sin(angle);
	var cr = Math.cos(angle);
	if(forward != null) {
		forward[0] = cp * cy;
		forward[1] = cp * sy;
		forward[2] = -sp;
	}
	if(right != null) {
		right[0] = cr * sy - sr * sp * cy;
		right[1] = -sr * sp * sy - cr * cy;
		right[2] = -sr * cp;
	}
	if(up != null) {
		up[0] = cr * sp * cy + sr * sy;
		up[1] = cr * sp * sy - sr * cy;
		up[2] = cr * cp;
	}
};
quake__$Vec_Vec_$Impl_$.CrossProduct = function(v1,v2) {
	var v = new Float32Array(3);
	v[0] = v1[1] * v2[2] - v1[2] * v2[1];
	v[1] = v1[2] * v2[0] - v1[0] * v2[2];
	v[2] = v1[0] * v2[1] - v1[1] * v2[0];
	return v;
};
quake__$Vec_Vec_$Impl_$.Normalize = function(v) {
	var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
	if(length == 0.0) {
		v[2] = 0.0;
		v[1] = 0.0;
		v[0] = 0.0;
		return 0.0;
	}
	v[0] /= length;
	v[1] /= length;
	v[2] /= length;
	return length;
};
quake__$Vec_Vec_$Impl_$.ConcatRotations = function(m1,m2) {
	return [[m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0] + m1[0][2] * m2[2][0],m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1] + m1[0][2] * m2[2][1],m1[0][0] * m2[0][2] + m1[0][1] * m2[1][2] + m1[0][2] * m2[2][2]],[m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0] + m1[1][2] * m2[2][0],m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1] + m1[1][2] * m2[2][1],m1[1][0] * m2[0][2] + m1[1][1] * m2[1][2] + m1[1][2] * m2[2][2]],[m1[2][0] * m2[0][0] + m1[2][1] * m2[1][0] + m1[2][2] * m2[2][0],m1[2][0] * m2[0][1] + m1[2][1] * m2[1][1] + m1[2][2] * m2[2][1],m1[2][0] * m2[0][2] + m1[2][1] * m2[1][2] + m1[2][2] * m2[2][2]]];
};
var quake__$PR_PRStackItem = function(s,f) {
	this.stmt = s;
	this.func = f;
};
quake__$PR_PRStackItem.__name__ = true;
var quake_Sys = function() { };
quake_Sys.__name__ = true;
quake_Sys.clearEvents = function() {
	window.onbeforeunload = null;
	window.oncontextmenu = null;
	window.onfocus = null;
	window.onkeydown = null;
	window.onkeyup = null;
	window.onmousedown = null;
	window.onmouseup = null;
	window.onunload = null;
	window.onwheel = null;
};
quake_Sys.Quit = function() {
	if(quake_Sys.frame != null) {
		window.clearInterval(quake_Sys.frame);
	}
	quake_Sys.clearEvents();
	quake_Host.Shutdown();
	window.document.body.style.cursor = "auto";
	quake_VID.mainwindow.style.display = "none";
	if(quake_COM.registered.value != 0) {
		window.document.getElementById("end2").style.display = "inline";
	} else {
		window.document.getElementById("end1").style.display = "inline";
	}
	throw new Error();
};
quake_Sys.Error = function(text) {
	if(quake_Sys.frame != null) {
		window.clearInterval(quake_Sys.frame);
	}
	quake_Sys.clearEvents();
	if(quake_Host.initialized) {
		quake_Host.Shutdown();
	}
	window.document.body.style.cursor = "auto";
	var i = quake_Console.text.length - 25;
	if(i < 0) {
		i = 0;
	}
	if(window.console != null) {
		while(i < quake_Console.text.length) window.console.log(quake_Console.text[i++].text);
	}
	window.alert(text);
	throw new Error(text);
};
quake_Sys.main = function() {
	window.onload = function() {
		var s = window.document.location.search;
		var cmdline = decodeURIComponent(s);
		var location = window.document.location;
		var argv = [location.href.substring(0,location.href.length - location.search.length)];
		if(HxOverrides.cca(cmdline,0) == 63) {
			var text = "";
			var quotes = false;
			var _g = 1;
			var _g1 = cmdline.length;
			while(_g < _g1) {
				var i = _g++;
				var c = HxOverrides.cca(cmdline,i);
				if(c < 32 || c > 127) {
					continue;
				}
				if(c == 34) {
					quotes = !quotes;
					continue;
				}
				if(quotes == false && c == 32) {
					if(text.length == 0) {
						continue;
					}
					argv.push(text);
					text = "";
					continue;
				}
				text += cmdline.charAt(i);
			}
			if(text.length != 0) {
				argv.push(text);
			}
		}
		quake_COM.InitArgv(argv);
		var elem = window.document.documentElement;
		quake_VID.width = elem.clientWidth <= 320 ? 320 : elem.clientWidth;
		quake_VID.height = elem.clientHeight <= 200 ? 200 : elem.clientHeight;
		quake_Sys.scantokey = new haxe_ds_IntMap();
		quake_Sys.scantokey.h[8] = 127;
		quake_Sys.scantokey.h[9] = 9;
		quake_Sys.scantokey.h[13] = 13;
		quake_Sys.scantokey.h[16] = 134;
		quake_Sys.scantokey.h[17] = 133;
		quake_Sys.scantokey.h[18] = 132;
		quake_Sys.scantokey.h[19] = 255;
		quake_Sys.scantokey.h[27] = 27;
		quake_Sys.scantokey.h[32] = 32;
		var v = 150;
		quake_Sys.scantokey.h[105] = v;
		quake_Sys.scantokey.h[33] = v;
		var v1 = 149;
		quake_Sys.scantokey.h[99] = v1;
		quake_Sys.scantokey.h[34] = v1;
		var v2 = 152;
		quake_Sys.scantokey.h[97] = v2;
		quake_Sys.scantokey.h[35] = v2;
		var v3 = 151;
		quake_Sys.scantokey.h[103] = v3;
		quake_Sys.scantokey.h[36] = v3;
		var v4 = 130;
		quake_Sys.scantokey.h[100] = v4;
		quake_Sys.scantokey.h[37] = v4;
		var v5 = 128;
		quake_Sys.scantokey.h[104] = v5;
		quake_Sys.scantokey.h[38] = v5;
		var v6 = 131;
		quake_Sys.scantokey.h[102] = v6;
		quake_Sys.scantokey.h[39] = v6;
		var v7 = 129;
		quake_Sys.scantokey.h[98] = v7;
		quake_Sys.scantokey.h[40] = v7;
		var v8 = 147;
		quake_Sys.scantokey.h[96] = v8;
		quake_Sys.scantokey.h[45] = v8;
		var v9 = 148;
		quake_Sys.scantokey.h[110] = v9;
		quake_Sys.scantokey.h[46] = v9;
		quake_Sys.scantokey.h[48] = 48;
		quake_Sys.scantokey.h[49] = 49;
		quake_Sys.scantokey.h[50] = 50;
		quake_Sys.scantokey.h[51] = 51;
		quake_Sys.scantokey.h[52] = 52;
		quake_Sys.scantokey.h[53] = 53;
		quake_Sys.scantokey.h[54] = 54;
		quake_Sys.scantokey.h[55] = 55;
		quake_Sys.scantokey.h[56] = 56;
		quake_Sys.scantokey.h[57] = 57;
		quake_Sys.scantokey.h[186] = 59;
		quake_Sys.scantokey.h[59] = 59;
		quake_Sys.scantokey.h[187] = 61;
		quake_Sys.scantokey.h[61] = 61;
		quake_Sys.scantokey.h[65] = 97;
		quake_Sys.scantokey.h[66] = 98;
		quake_Sys.scantokey.h[67] = 99;
		quake_Sys.scantokey.h[68] = 100;
		quake_Sys.scantokey.h[69] = 101;
		quake_Sys.scantokey.h[70] = 102;
		quake_Sys.scantokey.h[71] = 103;
		quake_Sys.scantokey.h[72] = 104;
		quake_Sys.scantokey.h[73] = 105;
		quake_Sys.scantokey.h[74] = 106;
		quake_Sys.scantokey.h[75] = 107;
		quake_Sys.scantokey.h[76] = 108;
		quake_Sys.scantokey.h[77] = 109;
		quake_Sys.scantokey.h[78] = 110;
		quake_Sys.scantokey.h[79] = 111;
		quake_Sys.scantokey.h[80] = 112;
		quake_Sys.scantokey.h[81] = 113;
		quake_Sys.scantokey.h[82] = 114;
		quake_Sys.scantokey.h[83] = 115;
		quake_Sys.scantokey.h[84] = 116;
		quake_Sys.scantokey.h[85] = 117;
		quake_Sys.scantokey.h[86] = 118;
		quake_Sys.scantokey.h[87] = 119;
		quake_Sys.scantokey.h[88] = 120;
		quake_Sys.scantokey.h[89] = 121;
		quake_Sys.scantokey.h[90] = 122;
		quake_Sys.scantokey.h[106] = 42;
		quake_Sys.scantokey.h[107] = 43;
		quake_Sys.scantokey.h[189] = 45;
		var v10 = 45;
		quake_Sys.scantokey.h[173] = v10;
		quake_Sys.scantokey.h[109] = v10;
		quake_Sys.scantokey.h[191] = 47;
		quake_Sys.scantokey.h[111] = 47;
		quake_Sys.scantokey.h[112] = 0 + 135;
		quake_Sys.scantokey.h[113] = 1 + 135;
		quake_Sys.scantokey.h[114] = 2 + 135;
		quake_Sys.scantokey.h[115] = 3 + 135;
		quake_Sys.scantokey.h[116] = 4 + 135;
		quake_Sys.scantokey.h[117] = 5 + 135;
		quake_Sys.scantokey.h[118] = 6 + 135;
		quake_Sys.scantokey.h[119] = 7 + 135;
		quake_Sys.scantokey.h[120] = 8 + 135;
		quake_Sys.scantokey.h[121] = 9 + 135;
		quake_Sys.scantokey.h[122] = 10 + 135;
		quake_Sys.scantokey.h[123] = 11 + 135;
		quake_Sys.scantokey.h[188] = 44;
		quake_Sys.scantokey.h[190] = 46;
		quake_Sys.scantokey.h[192] = 96;
		quake_Sys.scantokey.h[219] = 91;
		quake_Sys.scantokey.h[220] = 92;
		quake_Sys.scantokey.h[221] = 93;
		quake_Sys.scantokey.h[222] = 39;
		quake_Sys.oldtime = new Date().getTime() * 0.001;
		console.log("src/quake/Sys.hx:45:","Host.Init\n");
		quake_Host.Init();
		window.onbeforeunload = quake_Sys.onbeforeunload;
		window.oncontextmenu = quake_Sys.oncontextmenu;
		window.onfocus = quake_Sys.onfocus;
		window.onkeydown = quake_Sys.onkeydown;
		window.onkeyup = quake_Sys.onkeyup;
		window.onmousedown = quake_Sys.onmousedown;
		window.onmouseup = quake_Sys.onmouseup;
		window.onunload = quake_Sys.onunload;
		window.onwheel = quake_Sys.onwheel;
		quake_Sys.frame = window.setInterval(quake_Host.Frame,16);
	};
};
quake_Sys.onbeforeunload = function(_) {
	return "Are you sure you want to quit?";
};
quake_Sys.oncontextmenu = function(e) {
	e.preventDefault();
};
quake_Sys.onfocus = function() {
	var _g = 0;
	while(_g < 256) {
		var i = _g++;
		quake_Key.Event(i,false);
		quake_Key.down[i] = false;
	}
};
quake_Sys.onkeydown = function(e) {
	var key = quake_Sys.scantokey.h[e.keyCode];
	if(key == null) {
		return;
	}
	quake_Key.Event(key,true);
	e.preventDefault();
};
quake_Sys.onkeyup = function(e) {
	var key = quake_Sys.scantokey.h[e.keyCode];
	if(key == null) {
		return;
	}
	quake_Key.Event(key,false);
	e.preventDefault();
};
quake_Sys.onmousedown = function(e) {
	var key;
	switch(e.which) {
	case 1:
		key = 200;
		break;
	case 2:
		key = 202;
		break;
	case 3:
		key = 201;
		break;
	default:
		return;
	}
	quake_Key.Event(key,true);
	e.preventDefault();
};
quake_Sys.onmouseup = function(e) {
	var key;
	switch(e.which) {
	case 1:
		key = 200;
		break;
	case 2:
		key = 202;
		break;
	case 3:
		key = 201;
		break;
	default:
		return;
	}
	quake_Key.Event(key,false);
	e.preventDefault();
};
quake_Sys.onunload = function() {
	quake_Host.Shutdown();
};
quake_Sys.onwheel = function(e) {
	var key = e.deltaY < 0 ? 239 : 240;
	quake_Key.Event(key,true);
	quake_Key.Event(key,false);
	e.preventDefault();
};
var quake_SCR = function() { };
quake_SCR.__name__ = true;
quake_SCR.Init = function() {
	quake_SCR.fov = quake_Cvar.RegisterVariable("fov","90");
	quake_SCR.viewsize = quake_Cvar.RegisterVariable("viewsize","100",true);
	quake_SCR.conspeed = quake_Cvar.RegisterVariable("scr_conspeed","300");
	quake_SCR.showturtle = quake_Cvar.RegisterVariable("showturtle","0");
	quake_SCR.showpause = quake_Cvar.RegisterVariable("showpause","1");
	quake_SCR.centertime = quake_Cvar.RegisterVariable("scr_centertime","2");
	quake_SCR.printspeed = quake_Cvar.RegisterVariable("scr_printspeed","8");
	quake_Cmd.AddCommand("screenshot",quake_SCR.ScreenShot_f);
	quake_Cmd.AddCommand("sizeup",quake_SCR.SizeUp_f);
	quake_Cmd.AddCommand("sizedown",quake_SCR.SizeDown_f);
	quake_SCR.net = new quake_DrawPic(quake_W.GetLumpName("NET"));
	quake_SCR.turtle = new quake_DrawPic(quake_W.GetLumpName("TURTLE"));
	quake_SCR.pause = quake_Draw.CachePic("pause");
};
quake_SCR.CenterPrint = function(str) {
	quake_SCR.centerstring = [];
	var start = 0;
	var i = 0;
	while(i < str.length) {
		var next;
		if(HxOverrides.cca(str,i) == 10) {
			next = i + 1;
		} else if(i - start >= 40) {
			next = i;
		} else {
			++i;
			continue;
		}
		quake_SCR.centerstring.push(str.substring(start,i));
		start = next;
		++i;
	}
	quake_SCR.centerstring.push(str.substring(start,i));
	quake_SCR.centertime_off = quake_SCR.centertime.value;
	quake_SCR.centertime_start = quake_CL.state.time;
};
quake_SCR.BeginLoadingPlaque = function() {
	quake_S.StopAllSounds();
	if(quake_CL.cls.state != 2 || quake_CL.cls.signon != 4) {
		return;
	}
	quake_SCR.centertime_off = 0.0;
	quake_SCR.con_current = 0;
	quake_SCR.disabled_for_loading = true;
	quake_SCR.disabled_time = quake_Host.realtime + 60.0;
};
quake_SCR.EndLoadingPlaque = function() {
	quake_SCR.disabled_for_loading = false;
	quake_Console.ClearNotify();
};
quake_SCR.UpdateScreen = function() {
	if(quake_SCR.disabled_for_loading) {
		if(quake_Host.realtime <= quake_SCR.disabled_time) {
			return;
		}
		quake_SCR.disabled_for_loading = false;
		quake_Console.Print("load failed.\n");
	}
	var elem = window.document.documentElement;
	var width = elem.clientWidth <= 320 ? 320 : elem.clientWidth;
	var height = elem.clientHeight <= 200 ? 200 : elem.clientHeight;
	var pixelRatio = window.devicePixelRatio >= 1.0 ? window.devicePixelRatio : 1.0;
	if(quake_VID.width != width || quake_VID.height != height || quake_SCR.devicePixelRatio != pixelRatio || quake_Host.framecount == 0) {
		quake_VID.width = width;
		quake_VID.height = height;
		quake_VID.mainwindow.width = width * pixelRatio | 0;
		quake_VID.mainwindow.height = height * pixelRatio | 0;
		quake_VID.mainwindow.style.width = width + "px";
		quake_VID.mainwindow.style.height = height + "px";
		quake_SCR.devicePixelRatio = pixelRatio;
		quake_SCR.recalc_refdef = true;
	}
	if(quake_SCR.oldfov != quake_SCR.fov.value) {
		quake_SCR.oldfov = quake_SCR.fov.value;
		quake_SCR.recalc_refdef = true;
	}
	if(quake_SCR.oldscreensize != quake_SCR.viewsize.value) {
		quake_SCR.oldscreensize = quake_SCR.viewsize.value;
		quake_SCR.recalc_refdef = true;
	}
	if(quake_SCR.recalc_refdef) {
		quake_SCR.CalcRefdef();
	}
	quake_SCR.SetUpToDrawConsole();
	quake_V.RenderView();
	quake_GL.Set2D();
	if(quake_Render.dowarp) {
		quake_Render.WarpScreen();
	}
	if(!quake_Console.forcedup) {
		quake_Render.PolyBlend();
	}
	if(quake_CL.cls.state == 1) {
		quake_SCR.DrawConsole();
	} else if(quake_CL.state.intermission == 1 && quake_Key.dest == 0) {
		quake_Sbar.IntermissionOverlay();
	} else if(quake_CL.state.intermission == 2 && quake_Key.dest == 0) {
		quake_Draw.Pic(quake_VID.width - quake_Sbar.finale.width >> 1,16,quake_Sbar.finale);
		quake_SCR.DrawCenterString();
	} else if(quake_CL.state.intermission == 3 && quake_Key.dest == 0) {
		quake_SCR.DrawCenterString();
	} else {
		if(quake_V.crosshair.value != 0) {
			quake_Draw.Character(quake_Render.refdef.vrect.x + (quake_Render.refdef.vrect.width >> 1) + quake_V.crossx.value | 0,quake_Render.refdef.vrect.y + (quake_Render.refdef.vrect.height >> 1) + quake_V.crossy.value | 0,43);
		}
		quake_SCR.DrawNet();
		quake_SCR.DrawTurtle();
		quake_SCR.DrawPause();
		quake_SCR.DrawCenterString();
		quake_Sbar.DrawSbar();
		quake_SCR.DrawConsole();
		quake_Menu.DrawMenu();
	}
	quake_GL.gl.disable(3042);
	if(quake_SCR.screenshot) {
		quake_SCR.screenshot = false;
		quake_GL.gl.finish();
		window.open(quake_VID.mainwindow.toDataURL("image/jpeg"));
	}
};
quake_SCR.DrawCenterString = function() {
	quake_SCR.centertime_off -= quake_Host.frametime;
	if(quake_SCR.centertime_off <= 0.0 && quake_CL.state.intermission == 0 || quake_Key.dest != 0) {
		return;
	}
	var y = quake_SCR.centerstring.length <= 4 ? Math.floor(quake_VID.height * 0.35) : 48;
	if(quake_CL.state.intermission != 0) {
		var remaining = Math.floor(quake_SCR.printspeed.value * (quake_CL.state.time - quake_SCR.centertime_start));
		var _g = 0;
		var _g1 = quake_SCR.centerstring;
		while(_g < _g1.length) {
			var str = _g1[_g];
			++_g;
			var x = quake_VID.width - (str.length << 3) >> 1;
			var _g2 = 0;
			var _g11 = str.length;
			while(_g2 < _g11) {
				quake_Draw.Character(x,y,HxOverrides.cca(str,_g2++));
				if(remaining-- == 0) {
					return;
				}
				x += 8;
			}
			y += 8;
		}
		return;
	}
	var _g3 = 0;
	var _g12 = quake_SCR.centerstring;
	while(_g3 < _g12.length) {
		var s = _g12[_g3];
		++_g3;
		quake_Draw.String(quake_VID.width - (s.length << 3) >> 1,y,s);
		y += 8;
	}
};
quake_SCR.CalcRefdef = function() {
	quake_SCR.recalc_refdef = false;
	if(quake_SCR.viewsize.value < 30) {
		quake_SCR.viewsize.set("30");
	} else if(quake_SCR.viewsize.value > 120) {
		quake_SCR.viewsize.set("120");
	}
	var size;
	var full = false;
	if(quake_CL.state.intermission != 0) {
		full = true;
		size = 1.0;
		quake_Sbar.lines = 0;
	} else {
		size = quake_SCR.viewsize.value;
		if(size >= 120.0) {
			quake_Sbar.lines = 0;
		} else if(size >= 110.0) {
			quake_Sbar.lines = 24;
		} else {
			quake_Sbar.lines = 48;
		}
		if(size >= 100.0) {
			full = true;
			size = 100.0;
		}
		size *= 0.01;
	}
	var vrect = quake_Render.refdef.vrect;
	vrect.width = Math.floor(quake_VID.width * size);
	if(vrect.width < 96) {
		size = 96.0 / vrect.width;
		vrect.width = 96;
	}
	vrect.height = Math.floor(quake_VID.height * size);
	if(vrect.height > quake_VID.height - quake_Sbar.lines) {
		vrect.height = quake_VID.height - quake_Sbar.lines;
	}
	vrect.x = quake_VID.width - vrect.width >> 1;
	if(full) {
		vrect.y = 0;
	} else {
		vrect.y = quake_VID.height - quake_Sbar.lines - vrect.height >> 1;
	}
	if(quake_SCR.fov.value < 10) {
		quake_SCR.fov.set("10");
	} else if(quake_SCR.fov.value > 170) {
		quake_SCR.fov.set("170");
	}
	if(vrect.width * 0.75 <= vrect.height) {
		quake_Render.refdef.fov_x = quake_SCR.fov.value;
		quake_Render.refdef.fov_y = Math.atan(vrect.height / (vrect.width / Math.tan(quake_SCR.fov.value * Math.PI / 360.0))) * 360.0 / Math.PI;
	} else {
		quake_Render.refdef.fov_x = Math.atan(vrect.width / (vrect.height / Math.tan(quake_SCR.fov.value * 0.82 * Math.PI / 360.0))) * 360.0 / Math.PI;
		quake_Render.refdef.fov_y = quake_SCR.fov.value * 0.82;
	}
	var ymax = 4.0 * Math.tan(quake_Render.refdef.fov_y * Math.PI / 360.0);
	quake_Render.perspective[0] = 4.0 / (ymax * quake_Render.refdef.vrect.width / quake_Render.refdef.vrect.height);
	quake_Render.perspective[5] = 4.0 / ymax;
	quake_GL.ortho[0] = 2.0 / quake_VID.width;
	quake_GL.ortho[5] = -2.0 / quake_VID.height;
	quake_Render.warpwidth = vrect.width * quake_SCR.devicePixelRatio | 0;
	quake_Render.warpheight = vrect.height * quake_SCR.devicePixelRatio | 0;
	if(quake_Render.warpwidth > 2048) {
		quake_Render.warpwidth = 2048;
	}
	if(quake_Render.warpheight > 2048) {
		quake_Render.warpheight = 2048;
	}
	if(quake_Render.oldwarpwidth != quake_Render.warpwidth || quake_Render.oldwarpheight != quake_Render.warpheight) {
		quake_Render.oldwarpwidth = quake_Render.warpwidth;
		quake_Render.oldwarpheight = quake_Render.warpheight;
		quake_GL.Bind(0,quake_Render.warptexture);
		quake_GL.gl.texImage2D(3553,0,6408,quake_Render.warpwidth,quake_Render.warpheight,0,6408,5121,null);
		quake_GL.gl.bindRenderbuffer(36161,quake_Render.warprenderbuffer);
		quake_GL.gl.renderbufferStorage(36161,33189,quake_Render.warpwidth,quake_Render.warpheight);
		quake_GL.gl.bindRenderbuffer(36161,null);
	}
};
quake_SCR.SizeUp_f = function() {
	quake_SCR.viewsize.setValue(quake_SCR.viewsize.value + 10);
	quake_SCR.recalc_refdef = true;
};
quake_SCR.SizeDown_f = function() {
	quake_SCR.viewsize.setValue(quake_SCR.viewsize.value - 10);
	quake_SCR.recalc_refdef = true;
};
quake_SCR.DrawTurtle = function() {
	if(quake_SCR.showturtle.value == 0) {
		return;
	}
	if(quake_Host.frametime < 0.1) {
		quake_SCR.count = 0;
		return;
	}
	if(++quake_SCR.count >= 3) {
		quake_Draw.Pic(quake_Render.refdef.vrect.x,quake_Render.refdef.vrect.y,quake_SCR.turtle);
	}
};
quake_SCR.DrawNet = function() {
	if(quake_Host.realtime - quake_CL.state.last_received_message >= 0.3 && !quake_CL.cls.demoplayback) {
		quake_Draw.Pic(quake_Render.refdef.vrect.x,quake_Render.refdef.vrect.y,quake_SCR.net);
	}
};
quake_SCR.DrawPause = function() {
	if(quake_SCR.showpause.value != 0 && quake_CL.state.paused) {
		quake_Draw.Pic(quake_VID.width - quake_SCR.pause.width >> 1,quake_VID.height - 48 - quake_SCR.pause.height >> 1,quake_SCR.pause);
	}
};
quake_SCR.SetUpToDrawConsole = function() {
	quake_Console.forcedup = quake_CL.state.worldmodel == null || quake_CL.cls.signon != 4;
	if(quake_Console.forcedup) {
		quake_SCR.con_current = 200;
		return;
	}
	var conlines = quake_Key.dest == 1 ? 100 : 0;
	if(conlines < quake_SCR.con_current) {
		quake_SCR.con_current -= quake_SCR.conspeed.value * quake_Host.frametime | 0;
		if(conlines > quake_SCR.con_current) {
			quake_SCR.con_current = conlines;
		}
	} else if(conlines > quake_SCR.con_current) {
		quake_SCR.con_current += quake_SCR.conspeed.value * quake_Host.frametime | 0;
		if(conlines < quake_SCR.con_current) {
			quake_SCR.con_current = conlines;
		}
	}
};
quake_SCR.DrawConsole = function() {
	if(quake_SCR.con_current > 0) {
		quake_Console.DrawConsole(quake_SCR.con_current);
		return;
	}
	if(quake_Key.dest == 0 || quake_Key.dest == 2) {
		quake_Console.DrawNotify();
	}
};
quake_SCR.ScreenShot_f = function() {
	quake_SCR.screenshot = true;
};
var quake__$SV_ServerState = function() {
	this.signon = new quake_MSG(8192);
	this.reliable_datagram = new quake_MSG(1024);
	this.datagram = new quake_MSG(1024);
	this.num_edicts = 0;
};
quake__$SV_ServerState.__name__ = true;
var quake__$SV_ServerStatic = function() {
};
quake__$SV_ServerStatic.__name__ = true;
var quake_SV = function() { };
quake_SV.__name__ = true;
quake_SV.Init = function() {
	quake_SV.maxvelocity = quake_Cvar.RegisterVariable("sv_maxvelocity","2000");
	quake_SV.gravity = quake_Cvar.RegisterVariable("sv_gravity","800",false,true);
	quake_SV.friction = quake_Cvar.RegisterVariable("sv_friction","4",false,true);
	quake_SV.edgefriction = quake_Cvar.RegisterVariable("edgefriction","2");
	quake_SV.stopspeed = quake_Cvar.RegisterVariable("sv_stopspeed","100");
	quake_SV.maxspeed = quake_Cvar.RegisterVariable("sv_maxspeed","320",false,true);
	quake_SV.accelerate = quake_Cvar.RegisterVariable("sv_accelerate","10");
	quake_SV.idealpitchscale = quake_Cvar.RegisterVariable("sv_idealpitchscale","0.8");
	quake_SV.aim = quake_Cvar.RegisterVariable("sv_aim","0.93");
	quake_SV.nostep = quake_Cvar.RegisterVariable("sv_nostep","0");
	quake_SV.nop = new quake_MSG(4,1);
	new Uint8Array(quake_SV.nop.data)[0] = 1;
	quake_SV.reconnect = new quake_MSG(128);
	quake_SV.reconnect.WriteByte(9);
	quake_SV.reconnect.WriteString("reconnect\n");
	quake_SV.InitBoxHull();
};
quake_SV.StartParticle = function(org,dir,color,count) {
	var datagram = quake_SV.server.datagram;
	if(datagram.cursize >= 1009) {
		return;
	}
	datagram.WriteByte(18);
	datagram.WriteShort(org[0] * 8 | 0);
	datagram.WriteShort(org[1] * 8 | 0);
	datagram.WriteShort(org[2] * 8 | 0);
	var v = dir[0] * 16.0 | 0;
	if(v > 127) {
		v = 127;
	} else if(v < -128) {
		v = -128;
	}
	datagram.WriteChar(v);
	var v1 = dir[1] * 16.0 | 0;
	if(v1 > 127) {
		v1 = 127;
	} else if(v1 < -128) {
		v1 = -128;
	}
	datagram.WriteChar(v1);
	var v2 = dir[2] * 16.0 | 0;
	if(v2 > 127) {
		v2 = 127;
	} else if(v2 < -128) {
		v2 = -128;
	}
	datagram.WriteChar(v2);
	datagram.WriteByte(count);
	datagram.WriteByte(color);
};
quake_SV.StartSound = function(entity,channel,sample,volume,attenuation) {
	if(volume < 0 || volume > 255) {
		quake_Sys.Error("SV.StartSound: volume = " + volume);
	}
	if(attenuation < 0.0 || attenuation > 4.0) {
		quake_Sys.Error("SV.StartSound: attenuation = " + attenuation);
	}
	if(channel < 0 || channel > 7) {
		quake_Sys.Error("SV.StartSound: channel = " + channel);
	}
	var datagram = quake_SV.server.datagram;
	if(datagram.cursize >= 1009) {
		return;
	}
	var i = 1;
	while(i < quake_SV.server.sound_precache.length) {
		if(sample == quake_SV.server.sound_precache[i]) {
			break;
		}
		++i;
	}
	if(i >= quake_SV.server.sound_precache.length) {
		quake_Console.Print("SV.StartSound: " + sample + " not precached\n");
		return;
	}
	var field_mask = 0;
	if(volume != 255) {
		field_mask = 1;
	}
	if(attenuation != 1.0) {
		field_mask += 2;
	}
	datagram.WriteByte(6);
	datagram.WriteByte(field_mask);
	if((field_mask & 1) != 0) {
		datagram.WriteByte(volume);
	}
	if((field_mask & 2) != 0) {
		datagram.WriteByte(Math.floor(attenuation * 64.0));
	}
	datagram.WriteShort((entity.num << 3) + channel);
	datagram.WriteByte(i);
	datagram.WriteShort((entity.v.origin[0] + 0.5 * (entity.v.mins[0] + entity.v.maxs[0])) * 8 | 0);
	datagram.WriteShort((entity.v.origin[1] + 0.5 * (entity.v.mins[1] + entity.v.maxs[1])) * 8 | 0);
	datagram.WriteShort((entity.v.origin[2] + 0.5 * (entity.v.mins[2] + entity.v.maxs[2])) * 8 | 0);
};
quake_SV.SendServerinfo = function(client) {
	var message = client.message;
	message.WriteByte(8);
	message.WriteString("\x02" + "\nVERSION 1.09 SERVER (" + quake_PR.crc + " CRC)\n");
	message.WriteByte(11);
	message.WriteLong(15);
	message.WriteByte(quake_SV.svs.maxclients);
	message.WriteByte(quake_Host.coop.value == 0 && quake_Host.deathmatch.value != 0 ? 1 : 0);
	message.WriteString(quake_PR.GetString(quake_SV.server.edicts[0].v.ints[99]));
	var _g = 1;
	var _g1 = quake_SV.server.model_precache.length;
	while(_g < _g1) message.WriteString(quake_SV.server.model_precache[_g++]);
	message.WriteByte(0);
	var _g2 = 1;
	var _g3 = quake_SV.server.sound_precache.length;
	while(_g2 < _g3) message.WriteString(quake_SV.server.sound_precache[_g2++]);
	message.WriteByte(0);
	message.WriteByte(32);
	message.WriteByte(quake_SV.server.edicts[0].v.floats[100] | 0);
	message.WriteByte(quake_SV.server.edicts[0].v.floats[100] | 0);
	message.WriteByte(5);
	message.WriteShort(client.edict.num);
	message.WriteByte(25);
	message.WriteByte(1);
	client.sendsignon = true;
	client.spawned = false;
};
quake_SV.ConnectClient = function(clientnum) {
	var client = quake_SV.svs.clients[clientnum];
	var spawn_parms = null;
	if(quake_SV.server.loadgame) {
		spawn_parms = [];
		if(client.spawn_parms == null) {
			client.spawn_parms = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];
		}
		spawn_parms[0] = client.spawn_parms[0];
		spawn_parms[1] = client.spawn_parms[1];
		spawn_parms[2] = client.spawn_parms[2];
		spawn_parms[3] = client.spawn_parms[3];
		spawn_parms[4] = client.spawn_parms[4];
		spawn_parms[5] = client.spawn_parms[5];
		spawn_parms[6] = client.spawn_parms[6];
		spawn_parms[7] = client.spawn_parms[7];
		spawn_parms[8] = client.spawn_parms[8];
		spawn_parms[9] = client.spawn_parms[9];
		spawn_parms[10] = client.spawn_parms[10];
		spawn_parms[11] = client.spawn_parms[11];
		spawn_parms[12] = client.spawn_parms[12];
		spawn_parms[13] = client.spawn_parms[13];
		spawn_parms[14] = client.spawn_parms[14];
		spawn_parms[15] = client.spawn_parms[15];
	}
	quake_Console.DPrint("Client " + client.netconnection.address + " connected\n");
	client.active = true;
	client.dropasap = false;
	client.last_message = 0.0;
	client.cmd = new quake_ClientCmd();
	client.wishdir = new Float32Array(3);
	client.message.cursize = 0;
	client.edict = quake_SV.server.edicts[clientnum + 1];
	client.edict.v.ints[74] = quake_PR.netnames + (clientnum << 5);
	quake_SV.SetClientName(client,"unconnected");
	client.colors = 0;
	client.ping_times = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];
	client.num_pings = 0;
	if(!quake_SV.server.loadgame) {
		client.spawn_parms = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];
	}
	client.old_frags = 0;
	if(quake_SV.server.loadgame) {
		client.spawn_parms[0] = spawn_parms[0];
		client.spawn_parms[1] = spawn_parms[1];
		client.spawn_parms[2] = spawn_parms[2];
		client.spawn_parms[3] = spawn_parms[3];
		client.spawn_parms[4] = spawn_parms[4];
		client.spawn_parms[5] = spawn_parms[5];
		client.spawn_parms[6] = spawn_parms[6];
		client.spawn_parms[7] = spawn_parms[7];
		client.spawn_parms[8] = spawn_parms[8];
		client.spawn_parms[9] = spawn_parms[9];
		client.spawn_parms[10] = spawn_parms[10];
		client.spawn_parms[11] = spawn_parms[11];
		client.spawn_parms[12] = spawn_parms[12];
		client.spawn_parms[13] = spawn_parms[13];
		client.spawn_parms[14] = spawn_parms[14];
		client.spawn_parms[15] = spawn_parms[15];
	} else {
		quake_PR.ExecuteProgram(quake_PR.globals.ints[90]);
		var _this = quake_PR.globals;
		client.spawn_parms = [_this.floats[43],_this.floats[44],_this.floats[45],_this.floats[46],_this.floats[47],_this.floats[48],_this.floats[49],_this.floats[50],_this.floats[51],_this.floats[52],_this.floats[53],_this.floats[54],_this.floats[55],_this.floats[56],_this.floats[57],_this.floats[58]];
	}
	quake_SV.SendServerinfo(client);
};
quake_SV.CheckForNewClients = function() {
	while(true) {
		var ret = quake_NET.CheckNewConnections();
		if(ret == null) {
			return;
		}
		var i = 0;
		while(i < quake_SV.svs.maxclients) {
			if(!quake_SV.svs.clients[i].active) {
				break;
			}
			++i;
		}
		if(i == quake_SV.svs.maxclients) {
			quake_Sys.Error("SV.CheckForNewClients: no free clients");
		}
		quake_SV.svs.clients[i].netconnection = ret;
		quake_SV.ConnectClient(i);
		quake_NET.activeconnections++;
	}
};
quake_SV.AddToFatPVS = function(org,node) {
	while(true) {
		if(node.contents < 0) {
			if(node.contents != -2) {
				var pvs = quake_Mod_$Brush.LeafPVS(node,quake_SV.server.worldmodel);
				var _g = 0;
				var _g1 = quake_SV.fatbytes;
				while(_g < _g1) {
					var i = _g++;
					quake_SV.fatpvs[i] |= pvs[i];
				}
			}
			return;
		}
		var normal = node.plane.normal;
		var d = org[0] * normal[0] + org[1] * normal[1] + org[2] * normal[2] - node.plane.dist;
		if(d > 8.0) {
			node = node.child0;
		} else {
			if(d >= -8.0) {
				quake_SV.AddToFatPVS(org,node.child0);
			}
			node = node.child1;
		}
	}
};
quake_SV.FatPVS = function(org) {
	quake_SV.fatbytes = quake_SV.server.worldmodel.leafs.length + 31 >> 3;
	var _g = 0;
	var _g1 = quake_SV.fatbytes;
	while(_g < _g1) quake_SV.fatpvs[_g++] = 0;
	quake_SV.AddToFatPVS(org,quake_SV.server.worldmodel.nodes[0]);
};
quake_SV.WriteEntitiesToClient = function(clent,msg) {
	var v1 = clent.v.origin;
	var v2 = clent.v.view_ofs;
	var v = new Float32Array(3);
	v[0] = v1[0] + v2[0];
	v[1] = v1[1] + v2[1];
	v[2] = v1[2] + v2[2];
	quake_SV.FatPVS(v);
	var pvs = quake_SV.fatpvs;
	var _g = 1;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var e = _g++;
		var ent = quake_SV.server.edicts[e];
		if(ent != clent) {
			if(ent.v.floats[0] == 0.0 || quake_PR.strings[ent.v.ints[29]] == 0) {
				continue;
			}
			var i = 0;
			while(i < ent.leafnums.length) {
				if((pvs[ent.leafnums[i] >> 3] & 1 << (ent.leafnums[i] & 7)) != 0) {
					break;
				}
				++i;
			}
			if(i == ent.leafnums.length) {
				continue;
			}
		}
		if(msg.data.byteLength - msg.cursize < 16) {
			quake_Console.Print("packet overflow\n");
			return;
		}
		var bits = 0;
		var miss = ent.v.origin[0] - ent.baseline.origin[0];
		if(miss < -0.1 || miss > 0.1) {
			bits = 2;
		}
		var miss1 = ent.v.origin[1] - ent.baseline.origin[1];
		if(miss1 < -0.1 || miss1 > 0.1) {
			bits += 4;
		}
		var miss2 = ent.v.origin[2] - ent.baseline.origin[2];
		if(miss2 < -0.1 || miss2 > 0.1) {
			bits += 8;
		}
		if(ent.v.angles[0] != ent.baseline.angles[0]) {
			bits += 256;
		}
		if(ent.v.angles[1] != ent.baseline.angles[1]) {
			bits += 16;
		}
		if(ent.v.angles[2] != ent.baseline.angles[2]) {
			bits += 512;
		}
		if(ent.v.floats[8] == 4) {
			bits += 32;
		}
		if(ent.baseline.colormap != ent.v.floats[77]) {
			bits += 2048;
		}
		if(ent.baseline.skin != ent.v.floats[31]) {
			bits += 4096;
		}
		if(ent.baseline.frame != ent.v.floats[30]) {
			bits += 64;
		}
		if(ent.baseline.effects != ent.v.floats[32]) {
			bits += 8192;
		}
		if(ent.baseline.modelindex != ent.v.floats[0]) {
			bits += 1024;
		}
		if(e >= 256) {
			bits += 16384;
		}
		if(bits >= 256) {
			bits += 1;
		}
		msg.WriteByte(bits + 128);
		if((bits & 1) != 0) {
			msg.WriteByte(bits >> 8);
		}
		if((bits & 16384) != 0) {
			msg.WriteShort(e);
		} else {
			msg.WriteByte(e);
		}
		if((bits & 1024) != 0) {
			msg.WriteByte(ent.v.floats[0] | 0);
		}
		if((bits & 64) != 0) {
			msg.WriteByte(ent.v.floats[30] | 0);
		}
		if((bits & 2048) != 0) {
			msg.WriteByte(ent.v.floats[77] | 0);
		}
		if((bits & 4096) != 0) {
			msg.WriteByte(ent.v.floats[31] | 0);
		}
		if((bits & 8192) != 0) {
			msg.WriteByte(ent.v.floats[32] | 0);
		}
		if((bits & 2) != 0) {
			msg.WriteShort(ent.v.origin[0] * 8 | 0);
		}
		if((bits & 256) != 0) {
			msg.WriteByte((ent.v.angles[0] * 256 / 360 | 0) & 255);
		}
		if((bits & 4) != 0) {
			msg.WriteShort(ent.v.origin[1] * 8 | 0);
		}
		if((bits & 16) != 0) {
			msg.WriteByte((ent.v.angles[1] * 256 / 360 | 0) & 255);
		}
		if((bits & 8) != 0) {
			msg.WriteShort(ent.v.origin[2] * 8 | 0);
		}
		if((bits & 512) != 0) {
			msg.WriteByte((ent.v.angles[2] * 256 / 360 | 0) & 255);
		}
	}
};
quake_SV.WriteClientdataToMessage = function(ent,msg) {
	if(ent.v.floats[92] != 0.0 || ent.v.floats[93] != 0.0) {
		var other = quake_SV.server.edicts[ent.v.ints[94]];
		msg.WriteByte(19);
		msg.WriteByte(ent.v.floats[93] | 0);
		msg.WriteByte(ent.v.floats[92] | 0);
		msg.WriteShort((other.v.origin[0] + 0.5 * (other.v.mins[0] + other.v.maxs[0])) * 8 | 0);
		msg.WriteShort((other.v.origin[1] + 0.5 * (other.v.mins[1] + other.v.maxs[1])) * 8 | 0);
		msg.WriteShort((other.v.origin[2] + 0.5 * (other.v.mins[2] + other.v.maxs[2])) * 8 | 0);
		ent.v.floats[92] = 0.0;
		ent.v.floats[93] = 0.0;
	}
	quake_SV.SetIdealPitch();
	if(ent.v.floats[69] != 0.0) {
		msg.WriteByte(10);
		msg.WriteByte((ent.v.angles[0] * 256 / 360 | 0) & 255);
		msg.WriteByte((ent.v.angles[1] * 256 / 360 | 0) & 255);
		msg.WriteByte((ent.v.angles[2] * 256 / 360 | 0) & 255);
		ent.v.floats[69] = 0.0;
	}
	var bits = 512 + 16384;
	if(ent.v.view_ofs[2] != 22) {
		bits = bits + 1;
	}
	if(ent.v.floats[73] != 0.0) {
		bits = bits + 2;
	}
	var val = quake_EdictVars.items2_ofs;
	var items;
	if(val != null) {
		if(ent.v.floats[val] != 0.0) {
			items = (ent.v.floats[58] | 0 | 0) + ((ent.v.floats[val] | 0) << 23);
		} else {
			items = (ent.v.floats[58] | 0 | 0) + ((quake_PR.globals.floats[38] | 0) << 28);
		}
	} else {
		items = (ent.v.floats[58] | 0 | 0) + ((quake_PR.globals.floats[38] | 0) << 28);
	}
	if(((ent.v.floats[76] | 0) & 512) != 0) {
		bits = bits + 1024;
	}
	if(ent.v.floats[83] >= 2.0) {
		bits = bits + 2048;
	}
	if(ent.v.punchangle[0] != 0.0) {
		bits = bits + 4;
	}
	if(ent.v.velocity[0] != 0.0) {
		bits = bits + 32;
	}
	if(ent.v.punchangle[1] != 0.0) {
		bits = bits + 8;
	}
	if(ent.v.velocity[1] != 0.0) {
		bits = bits + 64;
	}
	if(ent.v.punchangle[2] != 0.0) {
		bits = bits + 16;
	}
	if(ent.v.velocity[2] != 0.0) {
		bits = bits + 128;
	}
	if(ent.v.floats[52] != 0.0) {
		bits = bits + 4096;
	}
	if(ent.v.floats[82] != 0.0) {
		bits = bits + 8192;
	}
	msg.WriteByte(15);
	msg.WriteShort(bits);
	if((bits & 1) != 0) {
		msg.WriteChar(ent.v.view_ofs[2] | 0);
	}
	if((bits & 2) != 0) {
		msg.WriteChar(ent.v.floats[73] | 0);
	}
	if((bits & 4) != 0) {
		msg.WriteChar(ent.v.punchangle[0] | 0);
	}
	if((bits & 32) != 0) {
		msg.WriteChar(ent.v.velocity[0] * 0.0625 | 0);
	}
	if((bits & 8) != 0) {
		msg.WriteChar(ent.v.punchangle[1] | 0);
	}
	if((bits & 64) != 0) {
		msg.WriteChar(ent.v.velocity[1] * 0.0625 | 0);
	}
	if((bits & 16) != 0) {
		msg.WriteChar(ent.v.punchangle[2] | 0);
	}
	if((bits & 128) != 0) {
		msg.WriteChar(ent.v.velocity[2] * 0.0625 | 0);
	}
	msg.WriteLong(items);
	if((bits & 4096) != 0) {
		msg.WriteByte(ent.v.floats[52] | 0);
	}
	if((bits & 8192) != 0) {
		msg.WriteByte(ent.v.floats[82] | 0);
	}
	msg.WriteByte(quake_SV.ModelIndex(quake_PR.GetString(ent.v.ints[51])));
	msg.WriteShort(ent.v.floats[48] | 0);
	msg.WriteByte(ent.v.floats[53] | 0);
	msg.WriteByte(ent.v.floats[54] | 0);
	msg.WriteByte(ent.v.floats[55] | 0);
	msg.WriteByte(ent.v.floats[56] | 0);
	msg.WriteByte(ent.v.floats[57] | 0);
	if(quake_COM.standard_quake) {
		msg.WriteByte(ent.v.floats[50] | 0);
	} else {
		var weapon = ent.v.floats[50] | 0;
		var _g = 0;
		while(_g < 32) {
			var i = _g++;
			if((weapon & 1 << i) != 0) {
				msg.WriteByte(i);
				break;
			}
		}
	}
};
quake_SV.SendClientDatagram = function() {
	var client = quake_Host.client;
	var msg = quake_SV.clientdatagram;
	msg.cursize = 0;
	msg.WriteByte(7);
	msg.WriteFloat(quake_SV.server.time);
	quake_SV.WriteClientdataToMessage(client.edict,msg);
	quake_SV.WriteEntitiesToClient(client.edict,msg);
	if(msg.cursize + quake_SV.server.datagram.cursize < msg.data.byteLength) {
		msg.Write(new Uint8Array(quake_SV.server.datagram.data),quake_SV.server.datagram.cursize);
	}
	if(quake_NET.SendUnreliableMessage(client.netconnection,msg) == -1) {
		quake_Host.DropClient(true);
		return false;
	}
	return true;
};
quake_SV.UpdateToReliableMessages = function() {
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var i = _g++;
		quake_Host.client = quake_SV.svs.clients[i];
		var frags = quake_Host.client.edict.v.floats[49] | 0;
		quake_Host.client.edict.v.floats[49] = frags;
		if(quake_Host.client.old_frags == frags) {
			continue;
		}
		var _g2 = 0;
		var _g11 = quake_SV.svs.maxclients;
		while(_g2 < _g11) {
			var client = quake_SV.svs.clients[_g2++];
			if(!client.active) {
				continue;
			}
			client.message.WriteByte(14);
			client.message.WriteByte(i);
			client.message.WriteShort(frags);
		}
		quake_Host.client.old_frags = frags;
	}
	var _g21 = 0;
	var _g3 = quake_SV.svs.maxclients;
	while(_g21 < _g3) {
		var client1 = quake_SV.svs.clients[_g21++];
		if(client1.active) {
			client1.message.Write(new Uint8Array(quake_SV.server.reliable_datagram.data),quake_SV.server.reliable_datagram.cursize);
		}
	}
	quake_SV.server.reliable_datagram.cursize = 0;
};
quake_SV.SendClientMessages = function() {
	quake_SV.UpdateToReliableMessages();
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var client = quake_Host.client = quake_SV.svs.clients[_g++];
		if(!client.active) {
			continue;
		}
		if(client.spawned) {
			if(!quake_SV.SendClientDatagram()) {
				continue;
			}
		} else if(!client.sendsignon) {
			if(quake_Host.realtime - client.last_message > 5.0) {
				if(quake_NET.SendUnreliableMessage(client.netconnection,quake_SV.nop) == -1) {
					quake_Host.DropClient(true);
				}
				client.last_message = quake_Host.realtime;
			}
			continue;
		}
		if(client.message.overflowed) {
			quake_Host.DropClient(true);
			client.message.overflowed = false;
			continue;
		}
		if(client.dropasap) {
			if(quake_NET.CanSendMessage(client.netconnection)) {
				quake_Host.DropClient(false);
			}
		} else if(client.message.cursize != 0) {
			if(!quake_NET.CanSendMessage(client.netconnection)) {
				continue;
			}
			if(quake_NET.SendMessage(client.netconnection,client.message) == -1) {
				quake_Host.DropClient(true);
			}
			client.message.cursize = 0;
			client.last_message = quake_Host.realtime;
			client.sendsignon = false;
		}
	}
	var _g2 = 1;
	var _g3 = quake_SV.server.num_edicts;
	while(_g2 < _g3) {
		var i = _g2++;
		quake_SV.server.edicts[i].v.floats[32] = (quake_SV.server.edicts[i].v.floats[32] | 0) & ~2;
	}
};
quake_SV.ModelIndex = function(name) {
	if(name == null) {
		return 0;
	}
	if(name.length == 0) {
		return 0;
	}
	var _g = 0;
	var _g1 = quake_SV.server.model_precache.length;
	while(_g < _g1) {
		var i = _g++;
		if(quake_SV.server.model_precache[i] == name) {
			return i;
		}
	}
	quake_Sys.Error("SV.ModelIndex: model " + name + " not precached");
	return 0;
};
quake_SV.CreateBaseline = function() {
	var player = quake_SV.ModelIndex("progs/player.mdl");
	var signon = quake_SV.server.signon;
	var _g = 0;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var i = _g++;
		var svent = quake_SV.server.edicts[i];
		if(svent.free) {
			continue;
		}
		if(i > quake_SV.svs.maxclients && svent.v.floats[0] == 0) {
			continue;
		}
		var baseline = svent.baseline;
		var this1 = baseline.origin;
		var y = svent.v.origin[1];
		var z = svent.v.origin[2];
		this1[0] = svent.v.origin[0];
		this1[1] = y;
		this1[2] = z;
		var this2 = baseline.angles;
		var y1 = svent.v.angles[1];
		var z1 = svent.v.angles[2];
		this2[0] = svent.v.angles[0];
		this2[1] = y1;
		this2[2] = z1;
		baseline.frame = svent.v.floats[30] | 0;
		baseline.skin = svent.v.floats[31] | 0;
		if(i > 0 && i <= quake_SV.svs.maxclients) {
			baseline.colormap = i;
			baseline.modelindex = player;
		} else {
			baseline.colormap = 0;
			baseline.modelindex = quake_SV.ModelIndex(quake_PR.GetString(svent.v.ints[29]));
		}
		signon.WriteByte(22);
		signon.WriteShort(i);
		signon.WriteByte(baseline.modelindex);
		signon.WriteByte(baseline.frame);
		signon.WriteByte(baseline.colormap);
		signon.WriteByte(baseline.skin);
		signon.WriteShort(baseline.origin[0] * 8 | 0);
		signon.WriteByte((baseline.angles[0] * 256 / 360 | 0) & 255);
		signon.WriteShort(baseline.origin[1] * 8 | 0);
		signon.WriteByte((baseline.angles[1] * 256 / 360 | 0) & 255);
		signon.WriteShort(baseline.origin[2] * 8 | 0);
		signon.WriteByte((baseline.angles[2] * 256 / 360 | 0) & 255);
	}
};
quake_SV.SaveSpawnparms = function() {
	quake_SV.svs.serverflags = quake_PR.globals.floats[38] | 0;
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		quake_Host.client = quake_SV.svs.clients[_g++];
		if(!quake_Host.client.active) {
			continue;
		}
		quake_PR.globals.ints[28] = quake_Host.client.edict.num;
		quake_PR.ExecuteProgram(quake_PR.globals.ints[91]);
		var _this = quake_PR.globals;
		quake_Host.client.spawn_parms = [_this.floats[43],_this.floats[44],_this.floats[45],_this.floats[46],_this.floats[47],_this.floats[48],_this.floats[49],_this.floats[50],_this.floats[51],_this.floats[52],_this.floats[53],_this.floats[54],_this.floats[55],_this.floats[56],_this.floats[57],_this.floats[58]];
	}
};
quake_SV.SpawnServer = function(map) {
	if(quake_NET.hostname.string.length == 0) {
		quake_NET.hostname.set("UNNAMED");
	}
	quake_SCR.centertime_off = 0.0;
	quake_Console.DPrint("SpawnServer: " + map + "\n");
	quake_SV.svs.changelevel_issued = false;
	if(quake_SV.server.active) {
		quake_NET.SendToAll(quake_SV.reconnect);
		quake_Cmd.ExecuteString("reconnect\n");
	}
	if(quake_Host.coop.value != 0) {
		quake_Host.deathmatch.setValue(0);
	}
	quake_Host.current_skill = Math.floor(quake_Host.skill.value + 0.5);
	if(quake_Host.current_skill < 0) {
		quake_Host.current_skill = 0;
	} else if(quake_Host.current_skill > 3) {
		quake_Host.current_skill = 3;
	}
	quake_Host.skill.setValue(quake_Host.current_skill);
	quake_Console.DPrint("Clearing memory\n");
	quake_Mod.ClearAll();
	quake_PR.LoadProgs();
	quake_SV.server.edicts = [];
	var _g = 0;
	while(_g < 2048) quake_SV.server.edicts.push(new quake_Edict(_g++));
	quake_SV.server.datagram.cursize = 0;
	quake_SV.server.reliable_datagram.cursize = 0;
	quake_SV.server.signon.cursize = 0;
	quake_SV.server.num_edicts = quake_SV.svs.maxclients + 1;
	var _g1 = 0;
	var _g2 = quake_SV.svs.maxclients;
	while(_g1 < _g2) {
		var i = _g1++;
		quake_SV.svs.clients[i].edict = quake_SV.server.edicts[i + 1];
	}
	quake_SV.server.loading = true;
	quake_SV.server.paused = false;
	quake_SV.server.loadgame = false;
	quake_SV.server.time = 1.0;
	quake_SV.server.lastcheck = 0;
	quake_SV.server.lastchecktime = 0.0;
	quake_SV.server.modelname = "maps/" + map + ".bsp";
	var tmp = quake_Mod.LoadModel(quake_Mod.FindName(quake_SV.server.modelname),false);
	quake_SV.server.worldmodel = tmp;
	if(quake_SV.server.worldmodel == null) {
		quake_Console.Print("Couldn't spawn server " + quake_SV.server.modelname + "\n");
		quake_SV.server.active = false;
		return;
	}
	quake_SV.server.models = [];
	quake_SV.server.models[1] = quake_SV.server.worldmodel;
	quake_SV.areanodes = [];
	quake_SV.CreateAreaNode(0,quake_SV.server.worldmodel.mins,quake_SV.server.worldmodel.maxs);
	quake_SV.server.sound_precache = [""];
	quake_SV.server.model_precache = ["",quake_SV.server.modelname];
	var _g3 = 1;
	var _g4 = quake_SV.server.worldmodel.submodels.length + 1;
	while(_g3 < _g4) {
		var i1 = _g3++;
		quake_SV.server.model_precache[i1 + 1] = "*" + i1;
		quake_SV.server.models[i1 + 1] = quake_Mod.LoadModel(quake_Mod.FindName("*" + i1),false);
	}
	quake_SV.server.lightstyles = [];
	var _g5 = 0;
	while(_g5 < 64) {
		++_g5;
		quake_SV.server.lightstyles.push("");
	}
	var ent = quake_SV.server.edicts[0];
	var _this = ent.v;
	var value = quake_PR.NewString(quake_SV.server.modelname,64);
	_this.ints[29] = value;
	ent.v.floats[0] = 1.0;
	ent.v.floats[9] = 4;
	ent.v.floats[8] = 7;
	if(quake_Host.coop.value != 0) {
		quake_PR.globals.floats[36] = quake_Host.coop.value;
	} else {
		quake_PR.globals.floats[35] = quake_Host.deathmatch.value;
	}
	var _this1 = quake_PR.globals;
	var value1 = quake_PR.NewString(map,64);
	_this1.ints[34] = value1;
	quake_PR.globals.floats[38] = quake_SV.svs.serverflags;
	quake_ED.LoadFromFile(quake_SV.server.worldmodel.entities);
	quake_SV.server.active = true;
	quake_SV.server.loading = false;
	quake_Host.frametime = 0.1;
	quake_SV.Physics();
	quake_SV.Physics();
	quake_SV.CreateBaseline();
	var _g6 = 0;
	var _g7 = quake_SV.svs.maxclients;
	while(_g6 < _g7) {
		var i2 = _g6++;
		quake_Host.client = quake_SV.svs.clients[i2];
		if(!quake_Host.client.active) {
			continue;
		}
		quake_Host.client.edict.v.ints[74] = quake_PR.netnames + (i2 << 5);
		quake_SV.SendServerinfo(quake_Host.client);
	}
	quake_Console.DPrint("Server spawned.\n");
};
quake_SV.SetClientName = function(client,name) {
	var ofs = quake_PR.netnames + (client.num << 5);
	var i = 0;
	while(i < name.length) {
		quake_PR.strings[ofs + i] = HxOverrides.cca(name,i);
		++i;
	}
	quake_PR.strings[ofs + i] = 0;
};
quake_SV.CheckBottom = function(ent) {
	var mins_0 = ent.v.origin[0] + ent.v.mins[0];
	var mins_1 = ent.v.origin[1] + ent.v.mins[1];
	var mins_2 = ent.v.origin[2] + ent.v.mins[2];
	var maxs_0 = ent.v.origin[0] + ent.v.maxs[0];
	var maxs_1 = ent.v.origin[1] + ent.v.maxs[1];
	while(true) {
		var v = new Float32Array(3);
		v[0] = mins_0;
		v[1] = mins_1;
		v[2] = mins_2 - 1.0;
		if(quake_SV.PointContents(v) != -2) {
			break;
		}
		var v1 = new Float32Array(3);
		v1[0] = mins_0;
		v1[1] = maxs_1;
		v1[2] = mins_2 - 1.0;
		if(quake_SV.PointContents(v1) != -2) {
			break;
		}
		var v2 = new Float32Array(3);
		v2[0] = maxs_0;
		v2[1] = mins_1;
		v2[2] = mins_2 - 1.0;
		if(quake_SV.PointContents(v2) != -2) {
			break;
		}
		var v3 = new Float32Array(3);
		v3[0] = maxs_0;
		v3[1] = maxs_1;
		v3[2] = mins_2 - 1.0;
		if(quake_SV.PointContents(v3) != -2) {
			break;
		}
		return true;
	}
	var v4 = new Float32Array(3);
	v4[0] = (mins_0 + maxs_0) * 0.5;
	v4[1] = (mins_1 + maxs_1) * 0.5;
	v4[2] = mins_2;
	var v5 = new Float32Array(3);
	v5[0] = v4[0];
	v5[1] = v4[1];
	v5[2] = v4[2] - 36.0;
	var trace = quake_SV.Move(v4,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,v5,1,ent);
	if(trace.fraction == 1.0) {
		return false;
	}
	var bottom = trace.endpos[2];
	var mid = bottom;
	v4[0] = v5[0] = mins_0;
	v4[1] = v5[1] = mins_1;
	trace = quake_SV.Move(v4,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,v5,1,ent);
	if(trace.fraction != 1.0 && trace.endpos[2] > bottom) {
		bottom = trace.endpos[2];
	}
	if(trace.fraction == 1.0 || mid - trace.endpos[2] > 18.0) {
		return false;
	}
	v4[0] = v5[0] = mins_0;
	v4[1] = v5[1] = maxs_1;
	trace = quake_SV.Move(v4,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,v5,1,ent);
	if(trace.fraction != 1.0 && trace.endpos[2] > bottom) {
		bottom = trace.endpos[2];
	}
	if(trace.fraction == 1.0 || mid - trace.endpos[2] > 18.0) {
		return false;
	}
	v4[0] = v5[0] = maxs_0;
	v4[1] = v5[1] = mins_1;
	trace = quake_SV.Move(v4,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,v5,1,ent);
	if(trace.fraction != 1.0 && trace.endpos[2] > bottom) {
		bottom = trace.endpos[2];
	}
	if(trace.fraction == 1.0 || mid - trace.endpos[2] > 18.0) {
		return false;
	}
	v4[0] = v5[0] = maxs_0;
	v4[1] = v5[1] = maxs_1;
	trace = quake_SV.Move(v4,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,v5,1,ent);
	if(trace.fraction != 1.0 && trace.endpos[2] > bottom) {
		bottom = trace.endpos[2];
	}
	if(trace.fraction == 1.0 || mid - trace.endpos[2] > 18.0) {
		return false;
	}
	return true;
};
quake_SV.movestep = function(ent,move,relink) {
	var oldorg = ent.v.origin;
	var neworg = new Float32Array(3);
	var mins = new Float32Array(ent.v.mins);
	var maxs = new Float32Array(ent.v.maxs);
	if(((ent.v.floats[76] | 0) & 2 + 1) != 0) {
		var enemy = ent.v.ints[75];
		var _g = 0;
		while(_g < 2) {
			var y = ent.v.origin[1] + move[1];
			var z = ent.v.origin[2];
			neworg[0] = ent.v.origin[0] + move[0];
			neworg[1] = y;
			neworg[2] = z;
			if(_g++ == 0 && enemy != 0) {
				var dz = ent.v.origin[2] - quake_SV.server.edicts[enemy].v.origin[2];
				if(dz > 40.0) {
					neworg[2] -= 8.0;
				} else if(dz < 30.0) {
					neworg[2] += 8.0;
				}
			}
			var trace = quake_SV.Move(new Float32Array(ent.v.origin),mins,maxs,neworg,0,ent);
			if(trace.fraction == 1.0) {
				if(((ent.v.floats[76] | 0) & 2) != 0 && quake_SV.PointContents(trace.endpos) == -1) {
					return false;
				}
				ent.v.origin.set(trace.endpos);
				if(relink) {
					quake_SV.LinkEdict(ent,true);
				}
				return true;
			}
			if(enemy == 0) {
				return false;
			}
		}
		return false;
	}
	var y1 = ent.v.origin[1] + move[1];
	var z1 = ent.v.origin[2] + 18.0;
	neworg[0] = ent.v.origin[0] + move[0];
	neworg[1] = y1;
	neworg[2] = z1;
	var v = new Float32Array(3);
	v[0] = neworg[0];
	v[1] = neworg[1];
	v[2] = neworg[2] - 36.0;
	var trace1 = quake_SV.Move(neworg,mins,maxs,v,0,ent);
	if(trace1.allsolid) {
		return false;
	}
	if(trace1.startsolid) {
		neworg[2] -= 18.0;
		trace1 = quake_SV.Move(neworg,mins,maxs,v,0,ent);
		if(trace1.allsolid || trace1.startsolid) {
			return false;
		}
	}
	if(trace1.fraction == 1.0) {
		if(((ent.v.floats[76] | 0) & 1024) == 0) {
			return false;
		}
		ent.v.origin[0] += move[0];
		ent.v.origin[1] += move[1];
		if(relink) {
			quake_SV.LinkEdict(ent,true);
		}
		ent.v.floats[76] = (ent.v.floats[76] | 0) & ~512;
		return true;
	}
	ent.v.origin.set(trace1.endpos);
	if(!quake_SV.CheckBottom(ent)) {
		if(((ent.v.floats[76] | 0) & 1024) != 0) {
			if(relink) {
				quake_SV.LinkEdict(ent,true);
			}
			return true;
		}
		ent.v.origin.set(oldorg);
		return false;
	}
	ent.v.floats[76] = (ent.v.floats[76] | 0) & ~1024;
	ent.v.ints[47] = trace1.ent.num;
	if(relink) {
		quake_SV.LinkEdict(ent,true);
	}
	return true;
};
quake_SV.StepDirection = function(ent,yaw,dist) {
	ent.v.floats[85] = yaw;
	quake_PF.changeyaw();
	yaw *= Math.PI / 180.0;
	var oldorigin = new Float32Array(ent.v.origin);
	var x = Math.cos(yaw) * dist;
	var y = Math.sin(yaw) * dist;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = 0;
	if(quake_SV.movestep(ent,v,false)) {
		var delta = ent.v.angles[1] - ent.v.floats[85];
		if(delta > 45.0 && delta < 315.0) {
			ent.v.origin.set(oldorigin);
		}
		quake_SV.LinkEdict(ent,true);
		return true;
	}
	quake_SV.LinkEdict(ent,true);
	return false;
};
quake_SV.NewChaseDir = function(actor,enemy,dist) {
	var olddir = quake__$Vec_Vec_$Impl_$.Anglemod((actor.v.floats[85] / 45.0 | 0) * 45.0);
	var turnaround = quake__$Vec_Vec_$Impl_$.Anglemod(olddir - 180.0);
	var deltax = enemy.v.origin[0] - actor.v.origin[0];
	var deltay = enemy.v.origin[1] - actor.v.origin[1];
	var dx;
	var dy;
	if(deltax > 10.0) {
		dx = 0.0;
	} else if(deltax < -10.0) {
		dx = 180.0;
	} else {
		dx = -1;
	}
	if(deltay < -10.0) {
		dy = 270.0;
	} else if(deltay > 10.0) {
		dy = 90.0;
	} else {
		dy = -1;
	}
	var tdir;
	if(dx != -1 && dy != -1) {
		if(dx == 0.0) {
			tdir = dy == 90.0 ? 45.0 : 315.0;
		} else {
			tdir = dy == 90.0 ? 135.0 : 215.0;
		}
		if(tdir != turnaround && quake_SV.StepDirection(actor,tdir,dist)) {
			return;
		}
	}
	if(Math.random() >= 0.25 || Math.abs(deltay) > Math.abs(deltax)) {
		tdir = dx;
		dx = dy;
		dy = tdir;
	}
	if(dx != -1 && dx != turnaround && quake_SV.StepDirection(actor,dx,dist)) {
		return;
	}
	if(dy != -1 && dy != turnaround && quake_SV.StepDirection(actor,dy,dist)) {
		return;
	}
	if(olddir != -1 && quake_SV.StepDirection(actor,olddir,dist)) {
		return;
	}
	if(Math.random() >= 0.5) {
		tdir = 0.0;
		while(tdir <= 315.0) {
			if(tdir != turnaround && quake_SV.StepDirection(actor,tdir,dist)) {
				return;
			}
			tdir += 45.0;
		}
	} else {
		tdir = 315.0;
		while(tdir >= 0.0) {
			if(tdir != turnaround && quake_SV.StepDirection(actor,tdir,dist)) {
				return;
			}
			tdir -= 45.0;
		}
	}
	if(turnaround != -1 && quake_SV.StepDirection(actor,turnaround,dist)) {
		return;
	}
	actor.v.floats[85] = olddir;
	if(!quake_SV.CheckBottom(actor)) {
		actor.v.floats[76] = actor.v.floats[76] | 0 | 1024;
	}
};
quake_SV.CloseEnough = function(ent,goal,dist) {
	if(goal.v.absmin[0] > ent.v.absmax[0] + dist) {
		return false;
	}
	if(goal.v.absmax[0] < ent.v.absmin[0] - dist) {
		return false;
	}
	if(goal.v.absmin[1] > ent.v.absmax[1] + dist) {
		return false;
	}
	if(goal.v.absmax[1] < ent.v.absmin[1] - dist) {
		return false;
	}
	if(goal.v.absmin[2] > ent.v.absmax[2] + dist) {
		return false;
	}
	if(goal.v.absmax[2] < ent.v.absmin[2] - dist) {
		return false;
	}
	return true;
};
quake_SV.CheckVelocity = function(ent) {
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		var velocity = ent.v.velocity[i];
		if(isNaN(velocity)) {
			quake_Console.Print("Got a NaN velocity on " + quake_PR.GetString(ent.v.ints[28]) + "\n");
			velocity = 0.0;
		}
		if(isNaN(ent.v.origin[i])) {
			quake_Console.Print("Got a NaN origin on " + quake_PR.GetString(ent.v.ints[28]) + "\n");
			ent.v.origin[i] = 0.0;
		}
		if(velocity > quake_SV.maxvelocity.value) {
			velocity = quake_SV.maxvelocity.value;
		} else if(velocity < -quake_SV.maxvelocity.value) {
			velocity = -quake_SV.maxvelocity.value;
		}
		ent.v.velocity[i] = velocity;
	}
};
quake_SV.RunThink = function(ent) {
	var thinktime = ent.v.floats[46];
	if(thinktime <= 0.0 || thinktime > quake_SV.server.time + quake_Host.frametime) {
		return true;
	}
	if(thinktime < quake_SV.server.time) {
		thinktime = quake_SV.server.time;
	}
	ent.v.floats[46] = 0.0;
	quake_PR.globals.floats[31] = thinktime;
	quake_PR.globals.ints[28] = ent.num;
	quake_PR.globals.ints[29] = 0;
	quake_PR.ExecuteProgram(ent.v.ints[44]);
	return !ent.free;
};
quake_SV.Impact = function(e1,e2) {
	var old_self = quake_PR.globals.ints[28];
	var old_other = quake_PR.globals.ints[29];
	quake_PR.globals.floats[31] = quake_SV.server.time;
	if(e1.v.ints[42] != 0 && e1.v.floats[9] != 0) {
		quake_PR.globals.ints[28] = e1.num;
		quake_PR.globals.ints[29] = e2.num;
		quake_PR.ExecuteProgram(e1.v.ints[42]);
	}
	if(e2.v.ints[42] != 0 && e2.v.floats[9] != 0) {
		quake_PR.globals.ints[28] = e2.num;
		quake_PR.globals.ints[29] = e1.num;
		quake_PR.ExecuteProgram(e2.v.ints[42]);
	}
	quake_PR.globals.ints[28] = old_self;
	quake_PR.globals.ints[29] = old_other;
};
quake_SV.ClipVelocity = function(vec,normal,out,overbounce) {
	var backoff = (vec[0] * normal[0] + vec[1] * normal[1] + vec[2] * normal[2]) * overbounce;
	out[0] = vec[0] - normal[0] * backoff;
	if(out[0] > -0.1 && out[0] < 0.1) {
		out[0] = 0.0;
	}
	out[1] = vec[1] - normal[1] * backoff;
	if(out[1] > -0.1 && out[1] < 0.1) {
		out[1] = 0.0;
	}
	out[2] = vec[2] - normal[2] * backoff;
	if(out[2] > -0.1 && out[2] < 0.1) {
		out[2] = 0.0;
	}
};
quake_SV.FlyMove = function(ent,time) {
	var primal_velocity = new Float32Array(ent.v.velocity);
	var original_velocity = new Float32Array(ent.v.velocity);
	var new_velocity = new Float32Array(3);
	var end = new Float32Array(3);
	var time_left = time;
	var blocked = 0;
	var planes = [];
	var numplanes = 0;
	var _g = 0;
	while(_g < 4) {
		++_g;
		if(ent.v.velocity[0] == 0.0 && ent.v.velocity[1] == 0.0 && ent.v.velocity[2] == 0.0) {
			break;
		}
		end[0] = ent.v.origin[0] + time_left * ent.v.velocity[0];
		end[1] = ent.v.origin[1] + time_left * ent.v.velocity[1];
		end[2] = ent.v.origin[2] + time_left * ent.v.velocity[2];
		var trace = quake_SV.Move(new Float32Array(ent.v.origin),new Float32Array(ent.v.mins),new Float32Array(ent.v.maxs),end,0,ent);
		if(trace.allsolid) {
			ent.v.velocity.set(quake__$Vec_Vec_$Impl_$.origin);
			return 3;
		}
		if(trace.fraction > 0.0) {
			ent.v.origin.set(trace.endpos);
			original_velocity = new Float32Array(ent.v.velocity);
			numplanes = 0;
			if(trace.fraction == 1.0) {
				break;
			}
		}
		if(trace.ent == null) {
			quake_Sys.Error("SV.FlyMove: !trace.ent");
		}
		if(trace.plane.normal[2] > 0.7) {
			blocked |= 1;
			if(trace.ent.v.floats[9] == 4) {
				ent.v.floats[76] = ent.v.floats[76] | 0 | 512;
				ent.v.ints[47] = trace.ent.num;
			}
		} else if(trace.plane.normal[2] == 0.0) {
			blocked |= 2;
			quake_SV.steptrace = trace;
		}
		quake_SV.Impact(ent,trace.ent);
		if(ent.free) {
			break;
		}
		time_left -= time_left * trace.fraction;
		if(numplanes >= 5) {
			ent.v.velocity.set(quake__$Vec_Vec_$Impl_$.origin);
			return 3;
		}
		var v = new Float32Array(3);
		v[0] = trace.plane.normal[0];
		v[1] = trace.plane.normal[1];
		v[2] = trace.plane.normal[2];
		planes[numplanes++] = v;
		var i = 0;
		while(i < numplanes) {
			quake_SV.ClipVelocity(original_velocity,planes[i],new_velocity,1.0);
			var j = 0;
			while(j < numplanes) {
				if(j != i) {
					var plane = planes[j];
					if(new_velocity[0] * plane[0] + new_velocity[1] * plane[1] + new_velocity[2] * plane[2] < 0.0) {
						break;
					}
				}
				++j;
			}
			if(j == numplanes) {
				break;
			}
			++i;
		}
		if(i != numplanes) {
			ent.v.velocity.set(new_velocity);
		} else {
			if(numplanes != 2) {
				ent.v.velocity.set(quake__$Vec_Vec_$Impl_$.origin);
				return 7;
			}
			var dir = quake__$Vec_Vec_$Impl_$.CrossProduct(planes[0],planes[1]);
			var d = dir[0] * ent.v.velocity[0] + dir[1] * ent.v.velocity[1] + dir[2] * ent.v.velocity[2];
			var this1 = ent.v.velocity;
			this1[0] = dir[0] * d;
			this1[1] = dir[1] * d;
			this1[2] = dir[2] * d;
		}
		if(ent.v.velocity[0] * primal_velocity[0] + ent.v.velocity[1] * primal_velocity[1] + ent.v.velocity[2] * primal_velocity[2] <= 0.0) {
			ent.v.velocity.set(quake__$Vec_Vec_$Impl_$.origin);
			return blocked;
		}
	}
	return blocked;
};
quake_SV.AddGravity = function(ent) {
	var val = quake_EdictVars.gravity_ofs;
	var ent_gravity;
	if(val != null) {
		ent_gravity = ent.v.floats[val] != 0.0 ? ent.v.floats[val] : 1.0;
	} else {
		ent_gravity = 1.0;
	}
	ent.v.velocity[2] -= ent_gravity * quake_SV.gravity.value * quake_Host.frametime;
};
quake_SV.PushEntity = function(ent,push) {
	var v1 = ent.v.origin;
	var v = new Float32Array(3);
	v[0] = v1[0] + push[0];
	v[1] = v1[1] + push[1];
	v[2] = v1[2] + push[2];
	var nomonsters;
	var solid = ent.v.floats[9];
	if(ent.v.floats[8] == 9) {
		nomonsters = 2;
	} else if(solid == 1 || solid == 0) {
		nomonsters = 1;
	} else {
		nomonsters = 0;
	}
	var trace = quake_SV.Move(new Float32Array(ent.v.origin),new Float32Array(ent.v.mins),new Float32Array(ent.v.maxs),v,nomonsters,ent);
	ent.v.origin.set(trace.endpos);
	quake_SV.LinkEdict(ent,true);
	if(trace.ent != null) {
		quake_SV.Impact(ent,trace.ent);
	}
	return trace;
};
quake_SV.PushMove = function(pusher,movetime) {
	if(pusher.v.velocity[0] == 0.0 && pusher.v.velocity[1] == 0.0 && pusher.v.velocity[2] == 0.0) {
		pusher.v.floats[7] += movetime;
		return;
	}
	var x = pusher.v.velocity[0] * movetime;
	var y = pusher.v.velocity[1] * movetime;
	var z = pusher.v.velocity[2] * movetime;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var mins_0 = pusher.v.absmin[0] + v[0];
	var mins_1 = pusher.v.absmin[1] + v[1];
	var mins_2 = pusher.v.absmin[2] + v[2];
	var maxs_0 = pusher.v.absmax[0] + v[0];
	var maxs_1 = pusher.v.absmax[1] + v[1];
	var maxs_2 = pusher.v.absmax[2] + v[2];
	var pushorig = new Float32Array(pusher.v.origin);
	pusher.v.origin[0] += v[0];
	pusher.v.origin[1] += v[1];
	pusher.v.origin[2] += v[2];
	pusher.v.floats[7] += movetime;
	quake_SV.LinkEdict(pusher,false);
	var moved = [];
	var _g = 1;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var check = quake_SV.server.edicts[_g++];
		if(check.free) {
			continue;
		}
		var movetype = check.v.floats[8];
		if(movetype == 7 || movetype == 0 || movetype == 8) {
			continue;
		}
		if(((check.v.floats[76] | 0) & 512) == 0 || check.v.ints[47] != pusher.num) {
			if(check.v.absmin[0] >= maxs_0 || check.v.absmin[1] >= maxs_1 || check.v.absmin[2] >= maxs_2 || check.v.absmax[0] <= mins_0 || check.v.absmax[1] <= mins_1 || check.v.absmax[2] <= mins_2) {
				continue;
			}
			if(!quake_SV.TestEntityPosition(check)) {
				continue;
			}
		}
		if(movetype != 3) {
			check.v.floats[76] = (check.v.floats[76] | 0) & ~512;
		}
		var entorig = new Float32Array(check.v.origin);
		moved.push([entorig[0],entorig[1],entorig[2],check]);
		pusher.v.floats[9] = 0;
		quake_SV.PushEntity(check,v);
		pusher.v.floats[9] = 4;
		if(quake_SV.TestEntityPosition(check)) {
			if(check.v.mins == check.v.maxs) {
				continue;
			}
			if(check.v.floats[9] == 0 || check.v.floats[9] == 1) {
				check.v.maxs[0] = 0.0;
				check.v.mins[0] = 0.0;
				check.v.maxs[1] = 0.0;
				check.v.mins[1] = 0.0;
				check.v.maxs[2] = check.v.mins[2];
				continue;
			}
			check.v.origin.set(entorig);
			quake_SV.LinkEdict(check,true);
			pusher.v.origin.set(pushorig);
			quake_SV.LinkEdict(pusher,false);
			pusher.v.floats[7] -= movetime;
			if(pusher.v.ints[45] != 0) {
				quake_PR.globals.ints[28] = pusher.num;
				quake_PR.globals.ints[29] = check.num;
				quake_PR.ExecuteProgram(pusher.v.ints[45]);
			}
			var _g2 = 0;
			while(_g2 < moved.length) {
				var moved_edict = moved[_g2];
				++_g2;
				var ed = moved_edict[3];
				var this1 = ed.v.origin;
				this1[0] = moved_edict[0];
				this1[1] = moved_edict[1];
				this1[2] = moved_edict[2];
				quake_SV.LinkEdict(ed,false);
			}
			return;
		}
	}
};
quake_SV.Physics_Pusher = function(ent) {
	var oldltime = ent.v.floats[7];
	var thinktime = ent.v.floats[46];
	var movetime;
	if(thinktime < oldltime + quake_Host.frametime) {
		movetime = thinktime - oldltime;
		if(movetime < 0.0) {
			movetime = 0.0;
		}
	} else {
		movetime = quake_Host.frametime;
	}
	if(movetime != 0.0) {
		quake_SV.PushMove(ent,movetime);
	}
	if(thinktime <= oldltime || thinktime > ent.v.floats[7]) {
		return;
	}
	ent.v.floats[46] = 0.0;
	quake_PR.globals.floats[31] = quake_SV.server.time;
	quake_PR.globals.ints[28] = ent.num;
	quake_PR.globals.ints[29] = 0;
	quake_PR.ExecuteProgram(ent.v.ints[44]);
};
quake_SV.CheckStuck = function(ent) {
	if(!quake_SV.TestEntityPosition(ent)) {
		ent.v.oldorigin.set(ent.v.origin);
		return;
	}
	var org = new Float32Array(ent.v.origin);
	ent.v.origin.set(ent.v.oldorigin);
	if(!quake_SV.TestEntityPosition(ent)) {
		quake_Console.DPrint("Unstuck.\n");
		quake_SV.LinkEdict(ent,true);
		return;
	}
	var _g = 0;
	while(_g < 18) {
		var z = _g++;
		var this1 = ent.v.origin;
		this1[0] = org[0] + (-1);
		this1[1] = org[1] + (-1);
		this1[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
		var this2 = ent.v.origin;
		this2[0] = org[0] + (-1);
		this2[1] = org[1];
		this2[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
		var this3 = ent.v.origin;
		this3[0] = org[0] + (-1);
		this3[1] = org[1] + 1;
		this3[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
		var this4 = ent.v.origin;
		this4[0] = org[0];
		this4[1] = org[1] + (-1);
		this4[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
		var this5 = ent.v.origin;
		this5[0] = org[0];
		this5[1] = org[1];
		this5[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
		var this6 = ent.v.origin;
		this6[0] = org[0];
		this6[1] = org[1] + 1;
		this6[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
		var this7 = ent.v.origin;
		this7[0] = org[0] + 1;
		this7[1] = org[1] + (-1);
		this7[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
		var this8 = ent.v.origin;
		this8[0] = org[0] + 1;
		this8[1] = org[1];
		this8[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
		var this9 = ent.v.origin;
		this9[0] = org[0] + 1;
		this9[1] = org[1] + 1;
		this9[2] = org[2] + z;
		if(!quake_SV.TestEntityPosition(ent)) {
			quake_Console.DPrint("Unstuck.\n");
			quake_SV.LinkEdict(ent,true);
			return;
		}
	}
	ent.v.origin.set(org);
	quake_Console.DPrint("player is stuck.\n");
};
quake_SV.CheckWater = function(ent) {
	var x = ent.v.origin[0];
	var y = ent.v.origin[1];
	var z = ent.v.origin[2] + ent.v.mins[2] + 1.0;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	ent.v.floats[83] = 0.0;
	ent.v.floats[84] = -1;
	var cont = quake_SV.PointContents(v);
	if(cont > -3) {
		return false;
	}
	ent.v.floats[84] = cont;
	ent.v.floats[83] = 1.0;
	v[2] = ent.v.origin[2] + (ent.v.mins[2] + ent.v.maxs[2]) * 0.5;
	cont = quake_SV.PointContents(v);
	if(cont <= -3) {
		ent.v.floats[83] = 2.0;
		v[2] = ent.v.origin[2] + ent.v.view_ofs[2];
		cont = quake_SV.PointContents(v);
		if(cont <= -3) {
			ent.v.floats[83] = 3.0;
		}
	}
	return ent.v.floats[83] > 1.0;
};
quake_SV.WallFriction = function(ent,tr) {
	var forward = new Float32Array(3);
	quake__$Vec_Vec_$Impl_$.AngleVectors(new Float32Array(ent.v.v_angle),forward);
	var normal = tr.plane.normal;
	var d = normal[0] * forward[0] + normal[1] * forward[1] + normal[2] * forward[2] + 0.5;
	if(d >= 0.0) {
		return;
	}
	d += 1.0;
	var i = normal[0] * ent.v.velocity[0] + normal[1] * ent.v.velocity[1] + normal[2] * ent.v.velocity[2];
	ent.v.velocity[0] = (ent.v.velocity[0] - normal[0] * i) * d;
	ent.v.velocity[1] = (ent.v.velocity[1] - normal[1] * i) * d;
};
quake_SV.TryUnstick = function(ent,oldvel) {
	var oldorg = new Float32Array(ent.v.origin);
	var v = new Float32Array(3);
	v[0] = 2.0;
	v[1] = 0.0;
	v[2] = 0.0;
	var _g = 0;
	while(_g < 8) {
		switch(_g++) {
		case 1:
			v[0] = 0.0;
			v[1] = 2.0;
			break;
		case 2:
			v[0] = -2.0;
			v[1] = 0.0;
			break;
		case 3:
			v[0] = 0.0;
			v[1] = -2.0;
			break;
		case 4:
			v[0] = 2.0;
			v[1] = 2.0;
			break;
		case 5:
			v[0] = -2.0;
			v[1] = 2.0;
			break;
		case 6:
			v[0] = 2.0;
			v[1] = -2.0;
			break;
		case 7:
			v[0] = -2.0;
			v[1] = -2.0;
			break;
		}
		quake_SV.PushEntity(ent,v);
		var this1 = ent.v.velocity;
		this1[0] = oldvel[0];
		this1[1] = oldvel[1];
		this1[2] = 0.0;
		var clip = quake_SV.FlyMove(ent,0.1);
		if(Math.abs(oldorg[1] - ent.v.origin[1]) > 4.0 || Math.abs(oldorg[0] - ent.v.origin[0]) > 4.0) {
			return clip;
		}
		ent.v.origin.set(oldorg);
	}
	ent.v.velocity.set(quake__$Vec_Vec_$Impl_$.origin);
	return 7;
};
quake_SV.WalkMove = function(ent) {
	var oldonground = (ent.v.floats[76] | 0) & 512;
	ent.v.floats[76] = (ent.v.floats[76] | 0) ^ oldonground;
	var oldorg = new Float32Array(ent.v.origin);
	var oldvel = new Float32Array(ent.v.velocity);
	var clip = quake_SV.FlyMove(ent,quake_Host.frametime);
	if((clip & 2) == 0) {
		return;
	}
	if(oldonground == 0 && ent.v.floats[83] == 0.0) {
		return;
	}
	if(ent.v.floats[8] != 3) {
		return;
	}
	if(quake_SV.nostep.value != 0) {
		return;
	}
	if(((quake_SV.player.v.floats[76] | 0) & 2048) != 0) {
		return;
	}
	var nosteporg = new Float32Array(ent.v.origin);
	var nostepvel = new Float32Array(ent.v.velocity);
	ent.v.origin.set(oldorg);
	var v = new Float32Array(3);
	v[0] = 0.0;
	v[1] = 0.0;
	v[2] = 18.0;
	quake_SV.PushEntity(ent,v);
	ent.v.velocity[0] = oldvel[0];
	ent.v.velocity[1] = oldvel[1];
	ent.v.velocity[2] = 0.0;
	clip = quake_SV.FlyMove(ent,quake_Host.frametime);
	if(clip != 0) {
		if(Math.abs(oldorg[1] - ent.v.origin[1]) < 0.03125 && Math.abs(oldorg[0] - ent.v.origin[0]) < 0.03125) {
			clip = quake_SV.TryUnstick(ent,oldvel);
		}
		if((clip & 2) != 0) {
			quake_SV.WallFriction(ent,quake_SV.steptrace);
		}
	}
	var z = oldvel[2] * quake_Host.frametime - 18.0;
	var v1 = new Float32Array(3);
	v1[0] = 0.0;
	v1[1] = 0.0;
	v1[2] = z;
	var downtrace = quake_SV.PushEntity(ent,v1);
	if(downtrace.plane.normal[2] > 0.7) {
		if(ent.v.floats[9] == 4) {
			ent.v.floats[76] = ent.v.floats[76] | 0 | 512;
			ent.v.ints[47] = downtrace.ent.num;
		}
		return;
	}
	ent.v.origin.set(nosteporg);
	ent.v.velocity.set(nostepvel);
};
quake_SV.Physics_Client = function(ent) {
	if(!quake_SV.svs.clients[ent.num - 1].active) {
		return;
	}
	quake_PR.globals.floats[31] = quake_SV.server.time;
	quake_PR.globals.ints[28] = ent.num;
	quake_PR.ExecuteProgram(quake_PR.globals.ints[84]);
	quake_SV.CheckVelocity(ent);
	var movetype = ent.v.floats[8] | 0;
	if(movetype == 6 || movetype == 10) {
		quake_SV.Physics_Toss(ent);
	} else {
		if(!quake_SV.RunThink(ent)) {
			return;
		}
		switch(movetype) {
		case 0:
			break;
		case 3:
			if(!quake_SV.CheckWater(ent) && ((ent.v.floats[76] | 0) & 2048) == 0) {
				quake_SV.AddGravity(ent);
			}
			quake_SV.CheckStuck(ent);
			quake_SV.WalkMove(ent);
			break;
		case 5:
			quake_SV.FlyMove(ent,quake_Host.frametime);
			break;
		case 8:
			ent.v.origin[0] += quake_Host.frametime * ent.v.velocity[0];
			ent.v.origin[1] += quake_Host.frametime * ent.v.velocity[1];
			ent.v.origin[2] += quake_Host.frametime * ent.v.velocity[2];
			break;
		default:
			quake_Sys.Error("SV.Physics_Client: bad movetype " + movetype);
		}
	}
	quake_SV.LinkEdict(ent,true);
	quake_PR.globals.floats[31] = quake_SV.server.time;
	quake_PR.globals.ints[28] = ent.num;
	quake_PR.ExecuteProgram(quake_PR.globals.ints[85]);
};
quake_SV.Physics_Noclip = function(ent) {
	if(!quake_SV.RunThink(ent)) {
		return;
	}
	ent.v.angles[0] += quake_Host.frametime * ent.v.avelocity[0];
	ent.v.angles[1] += quake_Host.frametime * ent.v.avelocity[1];
	ent.v.angles[2] += quake_Host.frametime * ent.v.avelocity[2];
	ent.v.origin[0] += quake_Host.frametime * ent.v.velocity[0];
	ent.v.origin[1] += quake_Host.frametime * ent.v.velocity[1];
	ent.v.origin[2] += quake_Host.frametime * ent.v.velocity[2];
	quake_SV.LinkEdict(ent,false);
};
quake_SV.CheckWaterTransition = function(ent) {
	var cont = quake_SV.PointContents(new Float32Array(ent.v.origin));
	if(ent.v.floats[84] == 0.0) {
		ent.v.floats[84] = cont;
		ent.v.floats[83] = 1.0;
		return;
	}
	if(cont <= -3) {
		if(ent.v.floats[84] == -1) {
			quake_SV.StartSound(ent,0,"misc/h2ohit1.wav",255,1.0);
		}
		ent.v.floats[84] = cont;
		ent.v.floats[83] = 1.0;
		return;
	}
	if(ent.v.floats[84] != -1) {
		quake_SV.StartSound(ent,0,"misc/h2ohit1.wav",255,1.0);
	}
	ent.v.floats[84] = -1;
	ent.v.floats[83] = cont;
};
quake_SV.Physics_Toss = function(ent) {
	if(!quake_SV.RunThink(ent)) {
		return;
	}
	if(((ent.v.floats[76] | 0) & 512) != 0) {
		return;
	}
	quake_SV.CheckVelocity(ent);
	var movetype = ent.v.floats[8];
	if(movetype != 5 && movetype != 9) {
		quake_SV.AddGravity(ent);
	}
	ent.v.angles[0] += quake_Host.frametime * ent.v.avelocity[0];
	ent.v.angles[1] += quake_Host.frametime * ent.v.avelocity[1];
	ent.v.angles[2] += quake_Host.frametime * ent.v.avelocity[2];
	var x = ent.v.velocity[0] * quake_Host.frametime;
	var y = ent.v.velocity[1] * quake_Host.frametime;
	var z = ent.v.velocity[2] * quake_Host.frametime;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var trace = quake_SV.PushEntity(ent,v);
	if(trace.fraction == 1.0 || ent.free) {
		return;
	}
	var velocity = new Float32Array(3);
	quake_SV.ClipVelocity(new Float32Array(ent.v.velocity),trace.plane.normal,velocity,movetype == 10 ? 1.5 : 1.0);
	ent.v.velocity.set(velocity);
	if(trace.plane.normal[2] > 0.7) {
		if(ent.v.velocity[2] < 60.0 || movetype != 10) {
			ent.v.floats[76] = ent.v.floats[76] | 0 | 512;
			ent.v.ints[47] = trace.ent.num;
			ent.v.velocity.set(quake__$Vec_Vec_$Impl_$.origin);
			ent.v.avelocity.set(quake__$Vec_Vec_$Impl_$.origin);
		}
	}
	quake_SV.CheckWaterTransition(ent);
};
quake_SV.Physics_Step = function(ent) {
	if(((ent.v.floats[76] | 0) & 512 + 1 + 2) == 0) {
		var hitsound = ent.v.velocity[2] < quake_SV.gravity.value * -0.1;
		quake_SV.AddGravity(ent);
		quake_SV.CheckVelocity(ent);
		quake_SV.FlyMove(ent,quake_Host.frametime);
		quake_SV.LinkEdict(ent,true);
		if(hitsound && ((ent.v.floats[76] | 0) & 512) != 0) {
			quake_SV.StartSound(ent,0,"demon/dland2.wav",255,1.0);
		}
	}
	quake_SV.RunThink(ent);
	quake_SV.CheckWaterTransition(ent);
};
quake_SV.Physics = function() {
	quake_PR.globals.ints[28] = 0;
	quake_PR.globals.ints[29] = 0;
	quake_PR.globals.floats[31] = quake_SV.server.time;
	quake_PR.ExecuteProgram(quake_PR.globals.ints[83]);
	var _g = 0;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var i = _g++;
		var ent = quake_SV.server.edicts[i];
		if(ent.free) {
			continue;
		}
		if(quake_PR.globals.floats[33] != 0.0) {
			quake_SV.LinkEdict(ent,true);
		}
		if(i > 0 && i <= quake_SV.svs.maxclients) {
			quake_SV.Physics_Client(ent);
			continue;
		}
		switch(ent.v.floats[8]) {
		case 0:
			quake_SV.RunThink(ent);
			break;
		case 4:
			quake_SV.Physics_Step(ent);
			break;
		case 7:
			quake_SV.Physics_Pusher(ent);
			break;
		case 8:
			quake_SV.Physics_Noclip(ent);
			break;
		case 5:case 6:case 9:case 10:
			quake_SV.Physics_Toss(ent);
			break;
		default:
			quake_Sys.Error("SV.Physics: bad movetype " + (ent.v.floats[8] | 0));
		}
	}
	if(quake_PR.globals.floats[33] != 0.0) {
		quake_PR.globals.floats[33] -= 1;
	}
	quake_SV.server.time += quake_Host.frametime;
};
quake_SV.SetIdealPitch = function() {
	var ent = quake_SV.player;
	if(((ent.v.floats[76] | 0) & 512) == 0) {
		return;
	}
	var angleval = ent.v.angles[1] * (Math.PI / 180.0);
	var sinval = Math.sin(angleval);
	var cosval = Math.cos(angleval);
	var z = ent.v.origin[2] + ent.v.view_ofs[2];
	var v = new Float32Array(3);
	v[0] = 0.0;
	v[1] = 0.0;
	v[2] = z;
	var v1 = new Float32Array(3);
	v1[0] = 0.0;
	v1[1] = 0.0;
	v1[2] = v[2] - 160.0;
	var z1 = [];
	var _g = 0;
	while(_g < 6) {
		var i = _g++;
		v[0] = v1[0] = ent.v.origin[0] + cosval * (i + 3) * 12.0;
		v[1] = v1[1] = ent.v.origin[1] + sinval * (i + 3) * 12.0;
		var tr = quake_SV.Move(v,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,v1,1,ent);
		if(tr.allsolid || tr.fraction == 1.0) {
			return;
		}
		z1[i] = v[2] - tr.fraction * 160.0;
	}
	var dir = 0.0;
	var steps = 0;
	var _g1 = 1;
	while(_g1 < 6) {
		var i1 = _g1++;
		var step = z1[i1] - z1[i1 - 1];
		if(step > -0.1 && step < 0.1) {
			continue;
		}
		if(dir != 0.0 && (step - dir > 0.1 || step - dir < -0.1)) {
			return;
		}
		++steps;
		dir = step;
	}
	if(dir == 0.0) {
		ent.v.floats[73] = 0.0;
		return;
	}
	if(steps >= 2) {
		ent.v.floats[73] = -dir * quake_SV.idealpitchscale.value;
	}
};
quake_SV.UserFriction = function() {
	var ent = quake_SV.player;
	var vel0 = ent.v.velocity[0];
	var vel1 = ent.v.velocity[1];
	var speed = Math.sqrt(vel0 * vel0 + vel1 * vel1);
	if(speed == 0.0) {
		return;
	}
	var x = ent.v.origin[0] + vel0 / speed * 16.0;
	var y = ent.v.origin[1] + vel1 / speed * 16.0;
	var z = ent.v.origin[2] + ent.v.mins[2];
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var friction = quake_SV.friction.value;
	var tmp = quake__$Vec_Vec_$Impl_$.origin;
	var tmp1 = quake__$Vec_Vec_$Impl_$.origin;
	var v1 = new Float32Array(3);
	v1[0] = v[0];
	v1[1] = v[1];
	v1[2] = v[2] - 34.0;
	if(quake_SV.Move(v,tmp,tmp1,v1,1,ent).fraction == 1.0) {
		friction *= quake_SV.edgefriction.value;
	}
	var newspeed = speed - quake_Host.frametime * (speed < quake_SV.stopspeed.value ? quake_SV.stopspeed.value : speed) * friction;
	if(newspeed < 0.0) {
		newspeed = 0.0;
	}
	newspeed /= speed;
	ent.v.velocity[0] *= newspeed;
	ent.v.velocity[1] *= newspeed;
	ent.v.velocity[2] *= newspeed;
};
quake_SV.Accelerate = function(wishvel,air) {
	var ent = quake_SV.player;
	var wishdir = new Float32Array(wishvel);
	var wishspeed = quake__$Vec_Vec_$Impl_$.Normalize(wishdir);
	if(air && wishspeed > 30.0) {
		wishspeed = 30.0;
	}
	var addspeed = wishspeed - (ent.v.velocity[0] * wishdir[0] + ent.v.velocity[1] * wishdir[1] + ent.v.velocity[2] * wishdir[2]);
	if(addspeed <= 0.0) {
		return;
	}
	var accelspeed = quake_SV.accelerate.value * quake_Host.frametime * wishspeed;
	if(accelspeed > addspeed) {
		accelspeed = addspeed;
	}
	ent.v.velocity[0] += accelspeed * wishdir[0];
	ent.v.velocity[1] += accelspeed * wishdir[1];
	ent.v.velocity[2] += accelspeed * wishdir[2];
};
quake_SV.WaterMove = function() {
	var ent = quake_SV.player;
	var cmd = quake_Host.client.cmd;
	var forward = new Float32Array(3);
	var right = new Float32Array(3);
	quake__$Vec_Vec_$Impl_$.AngleVectors(new Float32Array(ent.v.v_angle),forward,right);
	var wishvel_0 = forward[0] * cmd.forwardmove + right[0] * cmd.sidemove;
	var wishvel_1 = forward[1] * cmd.forwardmove + right[1] * cmd.sidemove;
	var wishvel_2 = forward[2] * cmd.forwardmove + right[2] * cmd.sidemove;
	if(cmd.forwardmove == 0.0 && cmd.sidemove == 0.0 && cmd.upmove == 0.0) {
		wishvel_2 -= 60.0;
	} else {
		wishvel_2 += cmd.upmove;
	}
	var wishspeed = Math.sqrt(wishvel_0 * wishvel_0 + wishvel_1 * wishvel_1 + wishvel_2 * wishvel_2);
	if(wishspeed > quake_SV.maxspeed.value) {
		var scale = quake_SV.maxspeed.value / wishspeed;
		wishvel_0 *= scale;
		wishvel_1 *= scale;
		wishvel_2 *= scale;
		wishspeed = quake_SV.maxspeed.value;
	}
	wishspeed *= 0.7;
	var v = ent.v.velocity;
	var speed = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
	var newspeed;
	if(speed != 0.0) {
		newspeed = speed - quake_Host.frametime * speed * quake_SV.friction.value;
		if(newspeed < 0.0) {
			newspeed = 0.0;
		}
		var scale1 = newspeed / speed;
		ent.v.velocity[0] *= scale1;
		ent.v.velocity[1] *= scale1;
		ent.v.velocity[2] *= scale1;
	} else {
		newspeed = 0.0;
	}
	if(wishspeed == 0.0) {
		return;
	}
	var addspeed = wishspeed - newspeed;
	if(addspeed <= 0.0) {
		return;
	}
	var accelspeed = quake_SV.accelerate.value * wishspeed * quake_Host.frametime;
	if(accelspeed > addspeed) {
		accelspeed = addspeed;
	}
	ent.v.velocity[0] += accelspeed * (wishvel_0 / wishspeed);
	ent.v.velocity[1] += accelspeed * (wishvel_1 / wishspeed);
	ent.v.velocity[2] += accelspeed * (wishvel_2 / wishspeed);
};
quake_SV.WaterJump = function() {
	var ent = quake_SV.player;
	if(quake_SV.server.time > ent.v.floats[80] || ent.v.floats[83] == 0.0) {
		ent.v.floats[76] = (ent.v.floats[76] | 0) & ~2048;
		ent.v.floats[80] = 0.0;
	}
	ent.v.velocity[0] = ent.v.movedir[0];
	ent.v.velocity[1] = ent.v.movedir[1];
};
quake_SV.AirMove = function() {
	var ent = quake_SV.player;
	var cmd = quake_Host.client.cmd;
	var forward = new Float32Array(3);
	var right = new Float32Array(3);
	quake__$Vec_Vec_$Impl_$.AngleVectors(new Float32Array(ent.v.angles),forward,right);
	var fmove = cmd.forwardmove;
	var smove = cmd.sidemove;
	if(quake_SV.server.time < ent.v.floats[80] && fmove < 0.0) {
		fmove = 0.0;
	}
	var z = (ent.v.floats[8] | 0) != 3 ? cmd.upmove : 0.0;
	var v = new Float32Array(3);
	v[0] = forward[0] * fmove + right[0] * smove;
	v[1] = forward[1] * fmove + right[1] * smove;
	v[2] = z;
	var wishdir = new Float32Array(v);
	if(quake__$Vec_Vec_$Impl_$.Normalize(wishdir) > quake_SV.maxspeed.value) {
		v[0] = wishdir[0] * quake_SV.maxspeed.value;
		v[1] = wishdir[1] * quake_SV.maxspeed.value;
		v[2] = wishdir[2] * quake_SV.maxspeed.value;
	}
	if(ent.v.floats[8] == 8) {
		ent.v.velocity.set(v);
	} else if(((ent.v.floats[76] | 0) & 512) != 0) {
		quake_SV.UserFriction();
		quake_SV.Accelerate(v,false);
	} else {
		quake_SV.Accelerate(v,true);
	}
};
quake_SV.ClientThink = function() {
	var ent = quake_SV.player;
	if(ent.v.floats[8] == 0) {
		return;
	}
	var punchangle = new Float32Array(ent.v.punchangle);
	var len = quake__$Vec_Vec_$Impl_$.Normalize(punchangle) - 10.0 * quake_Host.frametime;
	if(len < 0.0) {
		len = 0.0;
	}
	ent.v.punchangle[0] = punchangle[0] * len;
	ent.v.punchangle[1] = punchangle[1] * len;
	ent.v.punchangle[2] = punchangle[2] * len;
	if(ent.v.floats[48] <= 0.0) {
		return;
	}
	ent.v.angles[2] = quake_V.CalcRoll(new Float32Array(ent.v.angles),new Float32Array(ent.v.velocity)) * 4.0;
	if(ent.v.floats[69] == 0.0) {
		ent.v.angles[0] = (ent.v.v_angle[0] + ent.v.punchangle[0]) / -3.0;
		ent.v.angles[1] = ent.v.v_angle[1] + ent.v.punchangle[1];
	}
	if(((ent.v.floats[76] | 0) & 2048) != 0) {
		quake_SV.WaterJump();
	} else if(ent.v.floats[83] >= 2.0 && ent.v.floats[8] != 8) {
		quake_SV.WaterMove();
	} else {
		quake_SV.AirMove();
	}
};
quake_SV.ReadClientMove = function() {
	var client = quake_Host.client;
	client.ping_times[client.num_pings++ & 15] = quake_SV.server.time - quake_MSG.ReadFloat();
	client.edict.v.v_angle[0] = quake_MSG.ReadChar() * 1.40625;
	client.edict.v.v_angle[1] = quake_MSG.ReadChar() * 1.40625;
	client.edict.v.v_angle[2] = quake_MSG.ReadChar() * 1.40625;
	client.cmd.forwardmove = quake_MSG.ReadShort();
	client.cmd.sidemove = quake_MSG.ReadShort();
	client.cmd.upmove = quake_MSG.ReadShort();
	var i = quake_MSG.ReadByte();
	client.edict.v.floats[65] = i & 1;
	client.edict.v.floats[67] = (i & 2) >> 1;
	i = quake_MSG.ReadByte();
	if(i != 0) {
		client.edict.v.floats[68] = i;
	}
};
quake_SV.ReadClientMessage = function() {
	var ret;
	while(true) {
		ret = quake_NET.GetMessage(quake_Host.client.netconnection);
		if(ret == -1) {
			console.log("src/quake/Sys.hx:45:","SV.ReadClientMessage: NET.GetMessage failed\n");
			return false;
		}
		if(ret == 0) {
			return true;
		}
		quake_MSG.BeginReading();
		while(true) {
			if(!quake_Host.client.active) {
				return false;
			}
			if(quake_MSG.badread) {
				console.log("src/quake/Sys.hx:45:","SV.ReadClientMessage: badread\n");
				return false;
			}
			var cmd = quake_MSG.ReadChar();
			if(cmd == -1) {
				ret = 1;
				break;
			}
			if(cmd == 1) {
				continue;
			}
			if(cmd == 4) {
				var s = quake_MSG.ReadString();
				var i = 0;
				while(i < quake_SV.readClientCmds.length) {
					if(s.substring(0,quake_SV.readClientCmds[i].length).toLowerCase() != quake_SV.readClientCmds[i]) {
						++i;
						continue;
					}
					quake_Cmd.ExecuteString(s,true);
					break;
				}
				if(i == quake_SV.readClientCmds.length) {
					quake_Console.DPrint(quake_PR.GetString(quake_PR.netnames + (quake_Host.client.num << 5)) + " tried to " + s);
				}
			} else if(cmd == 2) {
				return false;
			} else if(cmd == 3) {
				quake_SV.ReadClientMove();
			} else {
				console.log("src/quake/Sys.hx:45:","SV.ReadClientMessage: unknown command char\n");
				return false;
			}
		}
	}
};
quake_SV.RunClients = function() {
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		quake_Host.client = quake_SV.svs.clients[_g++];
		if(!quake_Host.client.active) {
			continue;
		}
		quake_SV.player = quake_Host.client.edict;
		if(!quake_SV.ReadClientMessage()) {
			quake_Host.DropClient(false);
			continue;
		}
		if(!quake_Host.client.spawned) {
			quake_Host.client.cmd.forwardmove = 0.0;
			quake_Host.client.cmd.sidemove = 0.0;
			quake_Host.client.cmd.upmove = 0.0;
			continue;
		}
		quake_SV.ClientThink();
	}
};
quake_SV.InitBoxHull = function() {
	quake_SV.box_clipnodes = [];
	quake_SV.box_planes = [];
	quake_SV.box_hull = new quake_Hull();
	quake_SV.box_hull.clipnodes = quake_SV.box_clipnodes;
	quake_SV.box_hull.planes = quake_SV.box_planes;
	quake_SV.box_hull.firstclipnode = 0;
	quake_SV.box_hull.lastclipnode = 5;
	var _g = 0;
	while(_g < 6) {
		var i = _g++;
		var side = i & 1;
		var node = new quake_ClipNode();
		node.planenum = i;
		if(side == 0) {
			node.child0 = -1;
		} else {
			node.child1 = -1;
		}
		if(i != 5) {
			if(side == 0) {
				node.child1 = i + 1;
			} else {
				node.child0 = i + 1;
			}
		} else if(side == 0) {
			node.child1 = -2;
		} else {
			node.child0 = -2;
		}
		quake_SV.box_clipnodes.push(node);
		var plane = new quake_Plane();
		plane.type = i >> 1;
		plane.normal[i >> 1] = 1.0;
		plane.dist = 0.0;
		quake_SV.box_planes.push(plane);
	}
};
quake_SV.HullForEntity = function(ent,mins,maxs,offset) {
	if(ent.v.floats[9] != 4) {
		quake_SV.box_planes[0].dist = ent.v.maxs[0] - mins[0];
		quake_SV.box_planes[1].dist = ent.v.mins[0] - maxs[0];
		quake_SV.box_planes[2].dist = ent.v.maxs[1] - mins[1];
		quake_SV.box_planes[3].dist = ent.v.mins[1] - maxs[1];
		quake_SV.box_planes[4].dist = ent.v.maxs[2] - mins[2];
		quake_SV.box_planes[5].dist = ent.v.mins[2] - maxs[2];
		offset.set(ent.v.origin);
		return quake_SV.box_hull;
	}
	if(ent.v.floats[8] != 7) {
		quake_Sys.Error("SOLID_BSP without MOVETYPE_PUSH");
	}
	var model = quake_SV.server.models[ent.v.floats[0] | 0];
	if(model == null) {
		quake_Sys.Error("MOVETYPE_PUSH with a non bsp model");
	}
	if(model.type != 0) {
		quake_Sys.Error("MOVETYPE_PUSH with a non bsp model");
	}
	var size = maxs[0] - mins[0];
	var hull;
	if(size < 3.0) {
		hull = model.hulls[0];
	} else if(size <= 32.0) {
		hull = model.hulls[1];
	} else {
		hull = model.hulls[2];
	}
	var y = hull.clip_mins[1] - mins[1] + ent.v.origin[1];
	var z = hull.clip_mins[2] - mins[2] + ent.v.origin[2];
	offset[0] = hull.clip_mins[0] - mins[0] + ent.v.origin[0];
	offset[1] = y;
	offset[2] = z;
	return hull;
};
quake_SV.CreateAreaNode = function(depth,mins,maxs) {
	var anode = new quake__$SV_AreaNode();
	quake_SV.areanodes.push(anode);
	anode.trigger_edicts = new quake_EdictLink();
	anode.trigger_edicts.prev = anode.trigger_edicts.next = anode.trigger_edicts;
	anode.solid_edicts = new quake_EdictLink();
	anode.solid_edicts.prev = anode.solid_edicts.next = anode.solid_edicts;
	if(depth == 4) {
		anode.axis = -1;
		anode.children = [];
		return anode;
	}
	anode.axis = maxs[0] - mins[0] > maxs[1] - mins[1] ? 0 : 1;
	anode.dist = 0.5 * (maxs[anode.axis] + mins[anode.axis]);
	var maxs1 = new Float32Array(maxs);
	var mins2 = new Float32Array(mins);
	var v = mins2[anode.axis] = anode.dist;
	maxs1[anode.axis] = v;
	anode.children = [quake_SV.CreateAreaNode(depth + 1,mins2,maxs),quake_SV.CreateAreaNode(depth + 1,mins,maxs1)];
	return anode;
};
quake_SV.UnlinkEdict = function(ent) {
	if(ent.area.prev != null) {
		ent.area.prev.next = ent.area.next;
	}
	if(ent.area.next != null) {
		ent.area.next.prev = ent.area.prev;
	}
	ent.area.prev = ent.area.next = null;
};
quake_SV.TouchLinks = function(ent,node) {
	var l = node.trigger_edicts.next;
	while(l != node.trigger_edicts) {
		var touch = l.ent;
		l = l.next;
		if(touch == ent) {
			continue;
		}
		if(touch.v.ints[42] == 0 || touch.v.floats[9] != 1) {
			continue;
		}
		if(ent.v.absmin[0] > touch.v.absmax[0] || ent.v.absmin[1] > touch.v.absmax[1] || ent.v.absmin[2] > touch.v.absmax[2] || ent.v.absmax[0] < touch.v.absmin[0] || ent.v.absmax[1] < touch.v.absmin[1] || ent.v.absmax[2] < touch.v.absmin[2]) {
			continue;
		}
		var old_self = quake_PR.globals.ints[28];
		var old_other = quake_PR.globals.ints[29];
		quake_PR.globals.ints[28] = touch.num;
		quake_PR.globals.ints[29] = ent.num;
		quake_PR.globals.floats[31] = quake_SV.server.time;
		quake_PR.ExecuteProgram(touch.v.ints[42]);
		quake_PR.globals.ints[28] = old_self;
		quake_PR.globals.ints[29] = old_other;
	}
	if(node.axis == -1) {
		return;
	}
	if(ent.v.absmax[node.axis] > node.dist) {
		quake_SV.TouchLinks(ent,node.children[0]);
	}
	if(ent.v.absmin[node.axis] < node.dist) {
		quake_SV.TouchLinks(ent,node.children[1]);
	}
};
quake_SV.FindTouchedLeafs = function(ent,node) {
	if(node.contents == -2) {
		return;
	}
	if(node.contents < 0) {
		if(ent.leafnums.length == 16) {
			return;
		}
		ent.leafnums.push(node.num - 1);
		return;
	}
	var sides = quake__$Vec_Vec_$Impl_$.BoxOnPlaneSide(ent.v.absmin,ent.v.absmax,node.plane);
	if((sides & 1) != 0) {
		quake_SV.FindTouchedLeafs(ent,node.child0);
	}
	if((sides & 2) != 0) {
		quake_SV.FindTouchedLeafs(ent,node.child1);
	}
};
quake_SV.LinkEdict = function(ent,touch_triggers) {
	if(ent.free || ent == quake_SV.server.edicts[0]) {
		return;
	}
	quake_SV.UnlinkEdict(ent);
	var this1 = ent.v.absmin;
	var y = ent.v.origin[1] + ent.v.mins[1] - 1.0;
	var z = ent.v.origin[2] + ent.v.mins[2];
	this1[0] = ent.v.origin[0] + ent.v.mins[0] - 1.0;
	this1[1] = y;
	this1[2] = z;
	var this2 = ent.v.absmax;
	var y1 = ent.v.origin[1] + ent.v.maxs[1] + 1.0;
	var z1 = ent.v.origin[2] + ent.v.maxs[2];
	this2[0] = ent.v.origin[0] + ent.v.maxs[0] + 1.0;
	this2[1] = y1;
	this2[2] = z1;
	if(((ent.v.floats[76] | 0) & 256) != 0) {
		ent.v.absmin[0] -= 14.0;
		ent.v.absmin[1] -= 14.0;
		ent.v.absmax[0] += 14.0;
		ent.v.absmax[1] += 14.0;
	} else {
		ent.v.absmin[2] -= 1.0;
		ent.v.absmax[2] += 1.0;
	}
	ent.leafnums = [];
	if(ent.v.floats[0] != 0) {
		quake_SV.FindTouchedLeafs(ent,quake_SV.server.worldmodel.nodes[0]);
	}
	if(ent.v.floats[9] == 0) {
		return;
	}
	var node = quake_SV.areanodes[0];
	while(node.axis != -1) if(ent.v.absmin[node.axis] > node.dist) {
		node = node.children[0];
	} else if(ent.v.absmax[node.axis] < node.dist) {
		node = node.children[1];
	} else {
		break;
	}
	var before = ent.v.floats[9] == 1 ? node.trigger_edicts : node.solid_edicts;
	ent.area.next = before;
	ent.area.prev = before.prev;
	ent.area.prev.next = ent.area;
	ent.area.next.prev = ent.area;
	ent.area.ent = ent;
	if(touch_triggers) {
		quake_SV.TouchLinks(ent,quake_SV.areanodes[0]);
	}
};
quake_SV.HullPointContents = function(hull,num,p) {
	while(num >= 0) {
		if(num < hull.firstclipnode || num > hull.lastclipnode) {
			quake_Sys.Error("SV.HullPointContents: bad node number");
		}
		var node = hull.clipnodes[num];
		var plane = hull.planes[node.planenum];
		var d;
		if(plane.type <= 2) {
			d = p[plane.type] - plane.dist;
		} else {
			d = plane.normal[0] * p[0] + plane.normal[1] * p[1] + plane.normal[2] * p[2] - plane.dist;
		}
		if(d >= 0.0) {
			num = node.child0;
		} else {
			num = node.child1;
		}
	}
	return num;
};
quake_SV.PointContents = function(p) {
	var cont = quake_SV.HullPointContents(quake_SV.server.worldmodel.hulls[0],0,p);
	if(cont <= -9 && cont >= -14) {
		return -3;
	}
	return cont;
};
quake_SV.TestEntityPosition = function(ent) {
	var origin = new Float32Array(ent.v.origin);
	return quake_SV.Move(origin,new Float32Array(ent.v.mins),new Float32Array(ent.v.maxs),origin,0,ent).startsolid;
};
quake_SV.RecursiveHullCheck = function(hull,num,p1f,p2f,p1,p2,trace) {
	if(num < 0) {
		if(num != -2) {
			trace.allsolid = false;
			if(num == -1) {
				trace.inopen = true;
			} else {
				trace.inwater = true;
			}
		} else {
			trace.startsolid = true;
		}
		return true;
	}
	if(num < hull.firstclipnode || num > hull.lastclipnode) {
		quake_Sys.Error("SV.RecursiveHullCheck: bad node number");
	}
	var node = hull.clipnodes[num];
	var plane = hull.planes[node.planenum];
	var t1;
	var t2;
	if(plane.type <= 2) {
		t1 = p1[plane.type] - plane.dist;
		t2 = p2[plane.type] - plane.dist;
	} else {
		t1 = plane.normal[0] * p1[0] + plane.normal[1] * p1[1] + plane.normal[2] * p1[2] - plane.dist;
		t2 = plane.normal[0] * p2[0] + plane.normal[1] * p2[1] + plane.normal[2] * p2[2] - plane.dist;
	}
	if(t1 >= 0.0 && t2 >= 0.0) {
		return quake_SV.RecursiveHullCheck(hull,node.child0,p1f,p2f,p1,p2,trace);
	}
	if(t1 < 0.0 && t2 < 0.0) {
		return quake_SV.RecursiveHullCheck(hull,node.child1,p1f,p2f,p1,p2,trace);
	}
	var frac = (t1 + (t1 < 0.0 ? 0.03125 : -0.03125)) / (t1 - t2);
	if(frac < 0.0) {
		frac = 0.0;
	} else if(frac > 1.0) {
		frac = 1.0;
	}
	var midf = p1f + (p2f - p1f) * frac;
	var v = new Float32Array(3);
	v[0] = p1[0] + frac * (p2[0] - p1[0]);
	v[1] = p1[1] + frac * (p2[1] - p1[1]);
	v[2] = p1[2] + frac * (p2[2] - p1[2]);
	var side = t1 < 0.0;
	if(!quake_SV.RecursiveHullCheck(hull,side ? node.child1 : node.child0,p1f,midf,p1,v,trace)) {
		return false;
	}
	if(quake_SV.HullPointContents(hull,side ? node.child0 : node.child1,v) != -2) {
		return quake_SV.RecursiveHullCheck(hull,side ? node.child0 : node.child1,midf,p2f,v,p2,trace);
	}
	if(trace.allsolid) {
		return false;
	}
	if(!side) {
		trace.plane.normal.set(plane.normal);
		trace.plane.dist = plane.dist;
	} else {
		var this1 = trace.plane.normal;
		this1[0] = -plane.normal[0];
		this1[1] = -plane.normal[1];
		this1[2] = -plane.normal[2];
		trace.plane.dist = -plane.dist;
	}
	while(quake_SV.HullPointContents(hull,hull.firstclipnode,v) == -2) {
		frac -= 0.1;
		if(frac < 0.0) {
			trace.fraction = midf;
			trace.endpos.set(v);
			quake_Console.DPrint("backup past 0\n");
			return false;
		}
		midf = p1f + (p2f - p1f) * frac;
		v[0] = p1[0] + frac * (p2[0] - p1[0]);
		v[1] = p1[1] + frac * (p2[1] - p1[1]);
		v[2] = p1[2] + frac * (p2[2] - p1[2]);
	}
	trace.fraction = midf;
	trace.endpos.set(v);
	return false;
};
quake_SV.ClipMoveToEntity = function(ent,start,mins,maxs,end) {
	var trace = new quake_Trace();
	trace.fraction = 1.0;
	trace.allsolid = true;
	trace.endpos.set(end);
	var offset = new Float32Array(3);
	var hull = quake_SV.HullForEntity(ent,mins,maxs,offset);
	var hull1 = hull.firstclipnode;
	var v = new Float32Array(3);
	v[0] = start[0] - offset[0];
	v[1] = start[1] - offset[1];
	v[2] = start[2] - offset[2];
	var v1 = new Float32Array(3);
	v1[0] = end[0] - offset[0];
	v1[1] = end[1] - offset[1];
	v1[2] = end[2] - offset[2];
	quake_SV.RecursiveHullCheck(hull,hull1,0.0,1.0,v,v1,trace);
	if(trace.fraction != 1.0) {
		trace.endpos[0] += offset[0];
		trace.endpos[1] += offset[1];
		trace.endpos[2] += offset[2];
	}
	if(trace.fraction < 1.0 || trace.startsolid) {
		trace.ent = ent;
	}
	return trace;
};
quake_SV.ClipToLinks = function(node,clip) {
	var l = node.solid_edicts.next;
	while(l != node.solid_edicts) {
		var touch = l.ent;
		l = l.next;
		var solid = touch.v.floats[9];
		if(solid == 0 || touch == clip.passedict) {
			continue;
		}
		if(solid == 1) {
			quake_Sys.Error("Trigger in clipping list");
		}
		if(clip.type == 1 && solid != 4) {
			continue;
		}
		if(clip.boxmins[0] > touch.v.absmax[0] || clip.boxmins[1] > touch.v.absmax[1] || clip.boxmins[2] > touch.v.absmax[2] || clip.boxmaxs[0] < touch.v.absmin[0] || clip.boxmaxs[1] < touch.v.absmin[1] || clip.boxmaxs[2] < touch.v.absmin[2]) {
			continue;
		}
		if(clip.passedict != null) {
			if(clip.passedict.v.size[0] != 0.0 && touch.v.size[0] == 0.0) {
				continue;
			}
		}
		if(clip.trace.allsolid) {
			return;
		}
		if(clip.passedict != null) {
			if(quake_SV.server.edicts[touch.v.ints[95]] == clip.passedict) {
				continue;
			}
			if(quake_SV.server.edicts[clip.passedict.v.ints[95]] == touch) {
				continue;
			}
		}
		var trace;
		if(((touch.v.floats[76] | 0) & 32) != 0) {
			trace = quake_SV.ClipMoveToEntity(touch,clip.start,clip.mins2,clip.maxs2,clip.end);
		} else {
			trace = quake_SV.ClipMoveToEntity(touch,clip.start,clip.mins,clip.maxs,clip.end);
		}
		if(trace.allsolid || trace.startsolid || trace.fraction < clip.trace.fraction) {
			trace.ent = touch;
			clip.trace = trace;
			if(trace.startsolid) {
				clip.trace.startsolid = true;
			}
		}
	}
	if(node.axis == -1) {
		return;
	}
	if(clip.boxmaxs[node.axis] > node.dist) {
		quake_SV.ClipToLinks(node.children[0],clip);
	}
	if(clip.boxmins[node.axis] < node.dist) {
		quake_SV.ClipToLinks(node.children[1],clip);
	}
};
quake_SV.Move = function(start,mins,maxs,end,type,passedict) {
	var clip = new quake__$SV_MoveClip();
	clip.trace = quake_SV.ClipMoveToEntity(quake_SV.server.edicts[0],start,mins,maxs,end);
	clip.start = start;
	clip.end = end;
	clip.mins = mins;
	clip.maxs = maxs;
	clip.type = type;
	clip.passedict = passedict;
	clip.boxmins = new Float32Array(3);
	clip.boxmaxs = new Float32Array(3);
	if(type == 2) {
		var v = new Float32Array(3);
		v[0] = -15.0;
		v[1] = -15.0;
		v[2] = -15.0;
		clip.mins2 = v;
		var v1 = new Float32Array(3);
		v1[0] = 15.0;
		v1[1] = 15.0;
		v1[2] = 15.0;
		clip.maxs2 = v1;
	} else {
		clip.mins2 = new Float32Array(mins);
		clip.maxs2 = new Float32Array(maxs);
	}
	var _g = 0;
	while(_g < 3) {
		var i = _g++;
		if(end[i] > start[i]) {
			clip.boxmins[i] = start[i] + clip.mins2[i] - 1.0;
			clip.boxmaxs[i] = end[i] + clip.maxs2[i] + 1.0;
			continue;
		}
		clip.boxmins[i] = end[i] + clip.mins2[i] - 1.0;
		clip.boxmaxs[i] = start[i] + clip.maxs2[i] + 1.0;
	}
	quake_SV.ClipToLinks(quake_SV.areanodes[0],clip);
	return clip.trace;
};
var quake__$SV_MoveClip = function() {
};
quake__$SV_MoveClip.__name__ = true;
var quake_Trace = function() {
	this.endpos = new Float32Array(3);
	this.fraction = 0.0;
	this.plane = new quake_Plane();
	this.inwater = false;
	this.inopen = false;
	this.startsolid = false;
	this.allsolid = false;
};
quake_Trace.__name__ = true;
var quake_Plane = function() {
	this.signbits = 0;
	this.dist = 0;
	this.normal = new Float32Array(3);
	this.type = 0;
};
quake_Plane.__name__ = true;
var quake__$Render_RefDef = function() {
	this.viewangles = new Float32Array(3);
	this.vieworg = new Float32Array(3);
	this.vrect = new quake__$Render_Rect();
};
quake__$Render_RefDef.__name__ = true;
var quake_Render = function() { };
quake_Render.__name__ = true;
quake_Render.SplitEntityOnNode = function(emins,emaxs,node) {
	if(node.contents == -2) {
		return;
	}
	if(node.contents < 0) {
		quake_Render.currententity.leafs.push(node.num - 1);
		return;
	}
	var sides = quake__$Vec_Vec_$Impl_$.BoxOnPlaneSide(emins,emaxs,node.plane);
	if((sides & 1) != 0) {
		quake_Render.SplitEntityOnNode(emins,emaxs,node.child0);
	}
	if((sides & 2) != 0) {
		quake_Render.SplitEntityOnNode(emins,emaxs,node.child1);
	}
};
quake_Render.AnimateLight = function() {
	if(quake_Render.fullbright.value == 0) {
		var i = Math.floor(quake_CL.state.time * 10.0);
		var _g = 0;
		while(_g < 64) {
			var j = _g++;
			var style = quake_CL.lightstyle[j];
			if(style.length == 0) {
				quake_Render.lightstylevalue[j] = 12;
			} else {
				quake_Render.lightstylevalue[j] = HxOverrides.cca(style,i % style.length) - 97;
			}
		}
	} else {
		var _g1 = 0;
		while(_g1 < 64) quake_Render.lightstylevalue[_g1++] = 12;
	}
	quake_GL.Bind(0,quake_Render.lightstyle_texture);
	quake_GL.gl.texImage2D(3553,0,6406,64,1,0,6406,5121,quake_Render.lightstylevalue);
};
quake_Render.RenderDlights = function() {
	if(quake_Render.flashblend.value == 0) {
		return;
	}
	quake_Render.dlightframecount++;
	quake_GL.gl.enable(3042);
	var program = quake_GL.UseProgram(quake_GLPrograms.dlight);
	quake_GL.gl.bindBuffer(34962,quake_Render.dlightvecs);
	quake_GL.gl.vertexAttribPointer(program.aPoint,3,5126,false,0,0);
	var _g = 0;
	var _g1 = quake_CL.dlights;
	while(_g < _g1.length) {
		var l = _g1[_g];
		++_g;
		if(l.die < quake_CL.state.time || l.radius == 0.0) {
			continue;
		}
		var x = l.origin[0] - quake_Render.refdef.vieworg[0];
		var y = l.origin[1] - quake_Render.refdef.vieworg[1];
		var z = l.origin[2] - quake_Render.refdef.vieworg[2];
		var v = new Float32Array(3);
		v[0] = x;
		v[1] = y;
		v[2] = z;
		if(Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) < l.radius * 0.35) {
			var a = l.radius * 0.0003;
			quake_V.blend[3] += a * (1.0 - quake_V.blend[3]);
			a /= quake_V.blend[3];
			quake_V.blend[0] = quake_V.blend[1] * (1.0 - a) + 255.0 * a;
			quake_V.blend[1] = quake_V.blend[1] * (1.0 - a) + 127.5 * a;
			quake_V.blend[2] *= 1.0 - a;
			continue;
		}
		quake_GL.gl.uniform3fv(program.uOrigin,l.origin);
		quake_GL.gl.uniform1f(program.uRadius,l.radius);
		quake_GL.gl.drawArrays(6,0,18);
	}
	quake_GL.gl.disable(3042);
};
quake_Render.MarkLights = function(light,bit,node) {
	while(true) {
		if(node.contents < 0) {
			return;
		}
		var splitplane = node.plane;
		var dist;
		if(splitplane.type < 3) {
			dist = light.origin[splitplane.type] - splitplane.dist;
		} else {
			var v1 = light.origin;
			var v2 = splitplane.normal;
			dist = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2] - splitplane.dist;
		}
		if(dist > light.radius) {
			node = node.child0;
			continue;
		}
		if(dist < -light.radius) {
			node = node.child1;
			continue;
		}
		var _g = 0;
		var _g1 = node.numfaces;
		while(_g < _g1) {
			var surf = quake_CL.state.worldmodel.faces[node.firstface + _g++];
			if(surf.sky || surf.turbulent) {
				continue;
			}
			if(surf.dlightframe != quake_Render.dlightframecount + 1) {
				surf.dlightbits = 0;
				surf.dlightframe = quake_Render.dlightframecount + 1;
			}
			surf.dlightbits += bit;
		}
		if(node.child0.contents >= 0) {
			quake_Render.MarkLights(light,bit,node.child0);
		}
		if(node.child1.contents >= 0) {
			quake_Render.MarkLights(light,bit,node.child1);
		}
		break;
	}
};
quake_Render.PushDlights = function() {
	if(quake_Render.flashblend.value != 0) {
		return;
	}
	var _g = 0;
	while(_g < 1024) quake_Render.lightmap_modified[_g++] = 0;
	var bit = 1;
	var _g1 = 0;
	var _g2 = quake_CL.dlights;
	while(_g1 < _g2.length) {
		var l = _g2[_g1];
		++_g1;
		if(l.die >= quake_CL.state.time && l.radius != 0.0) {
			quake_Render.MarkLights(l,bit,quake_CL.state.worldmodel.nodes[0]);
			var _g11 = 0;
			var _g21 = quake_CL.numvisedicts;
			while(_g11 < _g21) {
				var ent = quake_CL.visedicts[_g11++];
				if(ent.model == null) {
					continue;
				}
				if(ent.model.type != 0 || !ent.model.submodel) {
					continue;
				}
				quake_Render.MarkLights(l,bit,quake_CL.state.worldmodel.nodes[ent.model.hulls[0].firstclipnode]);
			}
		}
		bit += bit;
	}
	var _g3 = 0;
	var _g4 = quake_CL.state.worldmodel.faces;
	while(_g3 < _g4.length) {
		var surf = _g4[_g3];
		++_g3;
		if(surf.dlightframe == quake_Render.dlightframecount) {
			quake_Render.RemoveDynamicLights(surf);
		} else if(surf.dlightframe == quake_Render.dlightframecount + 1) {
			quake_Render.AddDynamicLights(surf);
		}
	}
	quake_GL.Bind(0,quake_Render.dlightmap_texture);
	var start = null;
	var _g5 = 0;
	while(_g5 < 1024) {
		var i = _g5++;
		if(start == null && quake_Render.lightmap_modified[i] != 0) {
			start = i;
		} else if(start != null && quake_Render.lightmap_modified[i] == 0) {
			quake_GL.gl.texSubImage2D(3553,0,0,start,1024,i - start,6406,5121,quake_Render.dlightmaps.subarray(start << 10,i << 10));
			start = null;
		}
	}
	if(start != null) {
		quake_GL.gl.texSubImage2D(3553,0,0,start,1024,1024 - start,6406,5121,quake_Render.dlightmaps.subarray(start << 10,1048576));
	}
	quake_Render.dlightframecount++;
};
quake_Render.RecursiveLightPoint = function(node,start,end) {
	if(node.contents < 0) {
		return -1;
	}
	var normal = node.plane.normal;
	var front = start[0] * normal[0] + start[1] * normal[1] + start[2] * normal[2] - node.plane.dist;
	var back = end[0] * normal[0] + end[1] * normal[1] + end[2] * normal[2] - node.plane.dist;
	var side = front < 0;
	if(back < 0 == side) {
		return quake_Render.RecursiveLightPoint(side ? node.child1 : node.child0,start,end);
	}
	var frac = front / (front - back);
	var v = new Float32Array(3);
	v[0] = start[0] + (end[0] - start[0]) * frac;
	v[1] = start[1] + (end[1] - start[1]) * frac;
	v[2] = start[2] + (end[2] - start[2]) * frac;
	var r = quake_Render.RecursiveLightPoint(side ? node.child1 : node.child0,start,v);
	if(r >= 0) {
		return r;
	}
	if(back < 0 == side) {
		return -1;
	}
	var _g = 0;
	var _g1 = node.numfaces;
	while(_g < _g1) {
		var surf = quake_CL.state.worldmodel.faces[node.firstface + _g++];
		if(surf.sky || surf.turbulent) {
			continue;
		}
		var tex = quake_CL.state.worldmodel.texinfo[surf.texinfo];
		var a = tex.vecs[0];
		var v1 = new Float32Array(3);
		v1[0] = a[0];
		v1[1] = a[1];
		v1[2] = a[2];
		var s = v[0] * v1[0] + v[1] * v1[1] + v[2] * v1[2] + tex.vecs[0][3] | 0;
		var a1 = tex.vecs[1];
		var v2 = new Float32Array(3);
		v2[0] = a1[0];
		v2[1] = a1[1];
		v2[2] = a1[2];
		var t = v[0] * v2[0] + v[1] * v2[1] + v[2] * v2[2] + tex.vecs[1][3] | 0;
		if(s < surf.texturemins[0] || t < surf.texturemins[1]) {
			continue;
		}
		var ds = s - surf.texturemins[0];
		var dt = t - surf.texturemins[1];
		if(ds > surf.extents[0] || dt > surf.extents[1]) {
			continue;
		}
		if(surf.lightofs == 0) {
			return 0;
		}
		ds >>= 4;
		dt >>= 4;
		var lightmap = surf.lightofs;
		if(lightmap == 0) {
			return 0;
		}
		lightmap += dt * ((surf.extents[0] >> 4) + 1) + ds;
		r = 0;
		var size = ((surf.extents[0] >> 4) + 1) * ((surf.extents[1] >> 4) + 1);
		var _g2 = 0;
		var _g11 = surf.styles.length;
		while(_g2 < _g11) {
			r += quake_CL.state.worldmodel.lightdata[lightmap] * quake_Render.lightstylevalue[surf.styles[_g2++]] * 22;
			lightmap += size;
		}
		return r >> 8;
	}
	return quake_Render.RecursiveLightPoint(side ? node.child0 : node.child1,v,end);
};
quake_Render.LightPoint = function(p) {
	if(quake_CL.state.worldmodel.lightdata == null) {
		return 255;
	}
	var r = quake_CL.state.worldmodel.nodes[0];
	var v = new Float32Array(3);
	v[0] = p[0];
	v[1] = p[1];
	v[2] = p[2] - 2048.0;
	var r1 = quake_Render.RecursiveLightPoint(r,p,v);
	if(r1 == -1) {
		return 0;
	}
	return r1;
};
quake_Render.CullBox = function(mins,maxs) {
	if(quake__$Vec_Vec_$Impl_$.BoxOnPlaneSide(mins,maxs,quake_Render.frustum[0]) == 2) {
		return true;
	}
	if(quake__$Vec_Vec_$Impl_$.BoxOnPlaneSide(mins,maxs,quake_Render.frustum[1]) == 2) {
		return true;
	}
	if(quake__$Vec_Vec_$Impl_$.BoxOnPlaneSide(mins,maxs,quake_Render.frustum[2]) == 2) {
		return true;
	}
	if(quake__$Vec_Vec_$Impl_$.BoxOnPlaneSide(mins,maxs,quake_Render.frustum[3]) == 2) {
		return true;
	}
	return false;
};
quake_Render.DrawSpriteModel = function(e) {
	var program;
	if(e.model.oriented) {
		program = quake_GL.UseProgram(quake_GLPrograms.spriteOriented);
		quake_GL.gl.uniformMatrix3fv(quake_GLPrograms.spriteOriented.uAngles,false,quake_GL.RotationMatrix(e.angles[0],e.angles[1] - 90.0,e.angles[2]));
	} else {
		program = quake_GL.UseProgram(quake_GLPrograms.sprite);
	}
	var num = e.frame;
	if(num >= e.model.numframes || num < 0) {
		quake_Console.DPrint("Render.DrawSpriteModel: no such frame " + num + "\n");
		num = 0;
	}
	var frame = e.model.frames[num];
	if(frame.group) {
		var time = quake_CL.state.time + e.syncbase;
		var num1 = frame.frames.length - 1;
		var fullinterval = frame.frames[num1].interval;
		var targettime = time - Math.floor(time / fullinterval) * fullinterval;
		var i = 0;
		while(i < num1) {
			if(frame.frames[i].interval > targettime) {
				break;
			}
			++i;
		}
		frame = frame.frames[i];
	}
	quake_GL.gl.uniform4f(program.uRect,frame.origin[0],frame.origin[1],frame.width,frame.height);
	quake_GL.gl.uniform3fv(program.uOrigin,e.origin);
	quake_GL.Bind(program.tTexture,frame.texturenum);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Render.DrawAliasModel = function(e) {
	var clmodel = e.model;
	var x = e.origin[0] - clmodel.boundingradius;
	var y = e.origin[1] - clmodel.boundingradius;
	var z = e.origin[2] - clmodel.boundingradius;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var x1 = e.origin[0] + clmodel.boundingradius;
	var y1 = e.origin[1] + clmodel.boundingradius;
	var z1 = e.origin[2] + clmodel.boundingradius;
	var v1 = new Float32Array(3);
	v1[0] = x1;
	v1[1] = y1;
	v1[2] = z1;
	if(quake_Render.CullBox(v,v1)) {
		return;
	}
	var program;
	if(e.colormap != 0 && clmodel.player && quake_Render.nocolors.value == 0) {
		program = quake_GL.UseProgram(quake_GLPrograms.player);
		var top = (quake_CL.state.scores[e.colormap - 1].colors & 240) + 4;
		var bottom = ((quake_CL.state.scores[e.colormap - 1].colors & 15) << 4) + 4;
		if(top <= 127) {
			top += 7;
		}
		if(bottom <= 127) {
			bottom += 7;
		}
		top = quake_VID.d_8to24table[top];
		bottom = quake_VID.d_8to24table[bottom];
		quake_GL.gl.uniform3f(quake_GLPrograms.player.uTop,top & 255,top >> 8 & 255,top >> 16);
		quake_GL.gl.uniform3f(quake_GLPrograms.player.uBottom,bottom & 255,bottom >> 8 & 255,bottom >> 16);
	} else {
		program = quake_GL.UseProgram(quake_GLPrograms.alias);
	}
	quake_GL.gl.uniform3fv(program.uOrigin,e.origin);
	quake_GL.gl.uniformMatrix3fv(program.uAngles,false,quake_GL.RotationMatrix(e.angles[0],e.angles[1],e.angles[2]));
	var ambientlight = quake_Render.LightPoint(e.origin);
	var shadelight = ambientlight;
	if(e == quake_CL.state.viewent && ambientlight < 24.0) {
		shadelight = 24;
		ambientlight = shadelight;
	}
	var _g = 0;
	var _g1 = quake_CL.dlights;
	while(_g < _g1.length) {
		var dl = _g1[_g];
		++_g;
		if(dl.die < quake_CL.state.time) {
			continue;
		}
		var dl1 = dl.radius;
		var x2 = e.origin[0] - dl.origin[0];
		var y2 = e.origin[1] - dl.origin[1];
		var z2 = e.origin[1] - dl.origin[1];
		var v2 = new Float32Array(3);
		v2[0] = x2;
		v2[1] = y2;
		v2[2] = z2;
		var add = dl1 - Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);
		if(add > 0) {
			ambientlight += add;
			shadelight += add;
		}
	}
	if(ambientlight > 128.0) {
		ambientlight = 128.0;
	}
	if(ambientlight + shadelight > 192.0) {
		shadelight = 192.0 - ambientlight;
	}
	if(e.num >= 1 && e.num <= quake_CL.state.maxclients && ambientlight < 8.0) {
		shadelight = 8.0;
		ambientlight = 8.0;
	}
	quake_GL.gl.uniform1f(program.uAmbientLight,ambientlight * 0.0078125);
	quake_GL.gl.uniform1f(program.uShadeLight,shadelight * 0.0078125);
	var forward = new Float32Array(3);
	var right = new Float32Array(3);
	var up = new Float32Array(3);
	quake__$Vec_Vec_$Impl_$.AngleVectors(e.angles,forward,right,up);
	var tmp = quake_GL.gl;
	var program1 = program.uLightVec;
	var v3 = new Float32Array(3);
	v3[0] = -1.0;
	v3[1] = 0.0;
	v3[2] = 0.0;
	var tmp1 = v3[0] * forward[0] + v3[1] * forward[1] + v3[2] * forward[2];
	var v4 = new Float32Array(3);
	v4[0] = -1.0;
	v4[1] = 0.0;
	v4[2] = 0.0;
	var tmp2 = -(v4[0] * right[0] + v4[1] * right[1] + v4[2] * right[2]);
	var v5 = new Float32Array(3);
	v5[0] = -1.0;
	v5[1] = 0.0;
	v5[2] = 0.0;
	tmp.uniform3fv(program1,[tmp1,tmp2,v5[0] * up[0] + v5[1] * up[1] + v5[2] * up[2]]);
	quake_Render.c_alias_polys += clmodel.numtris;
	var time = quake_CL.state.time + e.syncbase;
	var num = e.frame;
	if(num >= clmodel.numframes || num < 0) {
		quake_Console.DPrint("Render.DrawAliasModel: no such frame " + num + "\n");
		num = 0;
	}
	var frame = clmodel.frames[num];
	if(frame.group) {
		var num1 = frame.frames.length - 1;
		var fullinterval = frame.frames[num1].interval;
		var targettime = time - Math.floor(time / fullinterval) * fullinterval;
		var i = 0;
		while(i < num1) {
			if(frame.frames[i].interval > targettime) {
				break;
			}
			++i;
		}
		frame = frame.frames[i];
	}
	quake_GL.gl.bindBuffer(34962,clmodel.cmds);
	quake_GL.gl.vertexAttribPointer(program.aPoint,3,5126,false,24,frame.cmdofs);
	quake_GL.gl.vertexAttribPointer(program.aLightNormal,3,5126,false,24,frame.cmdofs + 12);
	quake_GL.gl.vertexAttribPointer(program.aTexCoord,2,5126,false,0,0);
	num = e.skinnum;
	if(num >= clmodel.numskins || num < 0) {
		quake_Console.DPrint("Render.DrawAliasModel: no such skin # " + num + "\n");
		num = 0;
	}
	var skin = clmodel.skins[num];
	if(skin.group) {
		num = skin.skins.length - 1;
		var fullinterval1 = skin.skins[num].interval;
		var targettime1 = time - Math.floor(time / fullinterval1) * fullinterval1;
		var i1 = 0;
		while(i1 < num) {
			if(skin.skins[i1].interval > targettime1) {
				break;
			}
			++i1;
		}
		skin = skin.skins[i1];
	}
	quake_GL.Bind(program.tTexture,skin.texturenum.texnum);
	if(clmodel.player) {
		quake_GL.Bind(quake_GLPrograms.player.tPlayer,skin.playertexture);
	}
	quake_GL.gl.drawArrays(4,0,clmodel.numtris * 3);
};
quake_Render.DrawEntitiesOnList = function() {
	if(quake_Render.drawentities.value == 0) {
		return;
	}
	var vis = quake_Render.novis.value != 0 ? quake_Mod_$Brush.novis : quake_Mod_$Brush.LeafPVS(quake_Render.viewleaf,quake_CL.state.worldmodel);
	var _g = 0;
	var _g1 = quake_CL.static_entities;
	while(_g < _g1.length) {
		quake_Render.currententity = _g1[_g++];
		if(quake_Render.currententity.model == null) {
			continue;
		}
		var j = 0;
		while(j < quake_Render.currententity.leafs.length) {
			var leaf = quake_Render.currententity.leafs[j];
			if(leaf < 0 || (vis[leaf >> 3] & 1 << (leaf & 7)) != 0) {
				break;
			}
			++j;
		}
		if(j == quake_Render.currententity.leafs.length) {
			continue;
		}
		switch(quake_Render.currententity.model.type) {
		case 0:
			quake_Render.DrawBrushModel(quake_Render.currententity);
			break;
		case 2:
			quake_Render.DrawAliasModel(quake_Render.currententity);
			break;
		default:
		}
	}
	var _g2 = 0;
	var _g3 = quake_CL.numvisedicts;
	while(_g2 < _g3) {
		quake_Render.currententity = quake_CL.visedicts[_g2++];
		if(quake_Render.currententity.model == null) {
			continue;
		}
		switch(quake_Render.currententity.model.type) {
		case 0:
			quake_Render.DrawBrushModel(quake_Render.currententity);
			break;
		case 2:
			quake_Render.DrawAliasModel(quake_Render.currententity);
			break;
		default:
		}
	}
	quake_GL.gl.depthMask(false);
	quake_GL.gl.enable(3042);
	var _g4 = 0;
	var _g5 = quake_CL.static_entities;
	while(_g4 < _g5.length) {
		quake_Render.currententity = _g5[_g4++];
		if(quake_Render.currententity.model == null) {
			continue;
		}
		if(quake_Render.currententity.model.type == 1) {
			quake_Render.DrawSpriteModel(quake_Render.currententity);
		}
	}
	var _g6 = 0;
	var _g7 = quake_CL.numvisedicts;
	while(_g6 < _g7) {
		quake_Render.currententity = quake_CL.visedicts[_g6++];
		if(quake_Render.currententity.model == null) {
			continue;
		}
		if(quake_Render.currententity.model.type == 1) {
			quake_Render.DrawSpriteModel(quake_Render.currententity);
		}
	}
	quake_GL.gl.disable(3042);
	quake_GL.gl.depthMask(true);
};
quake_Render.DrawViewModel = function() {
	if(quake_Render.drawviewmodel.value == 0) {
		return;
	}
	if(quake_Chase.active.value != 0) {
		return;
	}
	if(quake_Render.drawentities.value == 0) {
		return;
	}
	if((quake_CL.state.items & quake_Def.it.invisibility) != 0) {
		return;
	}
	if(quake_CL.state.stats[0] <= 0) {
		return;
	}
	if(quake_CL.state.viewent.model == null) {
		return;
	}
	quake_GL.gl.depthRange(0.0,0.3);
	var ymax = 4.0 * Math.tan(quake_SCR.fov.value * 0.82 * Math.PI / 360.0);
	quake_Render.perspective[0] = 4.0 / (ymax * quake_Render.refdef.vrect.width / quake_Render.refdef.vrect.height);
	quake_Render.perspective[5] = 4.0 / ymax;
	var program = quake_GL.UseProgram(quake_GLPrograms.alias);
	quake_GL.gl.uniformMatrix4fv(program.uPerspective,false,quake_Render.perspective);
	quake_Render.DrawAliasModel(quake_CL.state.viewent);
	ymax = 4.0 * Math.tan(quake_Render.refdef.fov_y * Math.PI / 360.0);
	quake_Render.perspective[0] = 4.0 / (ymax * quake_Render.refdef.vrect.width / quake_Render.refdef.vrect.height);
	quake_Render.perspective[5] = 4.0 / ymax;
	program = quake_GL.UseProgram(quake_GLPrograms.alias);
	quake_GL.gl.uniformMatrix4fv(program.uPerspective,false,quake_Render.perspective);
	quake_GL.gl.depthRange(0.0,1.0);
};
quake_Render.PolyBlend = function() {
	if(quake_Render.polyblend.value == 0) {
		return;
	}
	if(quake_V.blend[3] == 0.0) {
		return;
	}
	var program = quake_GL.UseProgram(quake_GLPrograms.fill);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	var vrect = quake_Render.refdef.vrect;
	quake_GL.gl.uniform4f(program.uRect,vrect.x,vrect.y,vrect.width,vrect.height);
	quake_GL.gl.uniform4fv(program.uColor,quake_V.blend);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Render.SetFrustum = function() {
	quake__$Vec_Vec_$Impl_$.RotatePointAroundVector(quake_Render.vup,quake_Render.vpn,-(90.0 - quake_Render.refdef.fov_x * 0.5),quake_Render.frustum[0].normal);
	quake__$Vec_Vec_$Impl_$.RotatePointAroundVector(quake_Render.vup,quake_Render.vpn,90.0 - quake_Render.refdef.fov_x * 0.5,quake_Render.frustum[1].normal);
	quake__$Vec_Vec_$Impl_$.RotatePointAroundVector(quake_Render.vright,quake_Render.vpn,90.0 - quake_Render.refdef.fov_y * 0.5,quake_Render.frustum[2].normal);
	quake__$Vec_Vec_$Impl_$.RotatePointAroundVector(quake_Render.vright,quake_Render.vpn,-(90.0 - quake_Render.refdef.fov_y * 0.5),quake_Render.frustum[3].normal);
	var _g = 0;
	while(_g < 4) {
		var out = quake_Render.frustum[_g++];
		out.type = 5;
		var v1 = quake_Render.refdef.vieworg;
		var v2 = out.normal;
		out.dist = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
		out.signbits = 0;
		if(out.normal[0] < 0.0) {
			out.signbits = 1;
		}
		if(out.normal[1] < 0.0) {
			out.signbits += 2;
		}
		if(out.normal[2] < 0.0) {
			out.signbits += 4;
		}
		if(out.normal[3] < 0.0) {
			out.signbits += 8;
		}
	}
};
quake_Render.Perspective = function() {
	var viewangles_0 = quake_Render.refdef.viewangles[0] * Math.PI / 180.0;
	var viewangles_1 = (quake_Render.refdef.viewangles[1] - 90.0) * Math.PI / -180.0;
	var viewangles_2 = quake_Render.refdef.viewangles[2] * Math.PI / -180.0;
	var sp = Math.sin(viewangles_0);
	var cp = Math.cos(viewangles_0);
	var sy = Math.sin(viewangles_1);
	var cy = Math.cos(viewangles_1);
	var sr = Math.sin(viewangles_2);
	var cr = Math.cos(viewangles_2);
	var viewMatrix = [cr * cy + sr * sp * sy,cp * sy,-sr * cy + cr * sp * sy,cr * -sy + sr * sp * cy,cp * cy,-sr * -sy + cr * sp * cy,sr * cp,-sp,cr * cp];
	if(quake_V.gamma.value < 0.5) {
		quake_V.gamma.setValue(0.5);
	} else if(quake_V.gamma.value > 1.0) {
		quake_V.gamma.setValue(1.0);
	}
	quake_GL.UnbindProgram();
	var _g = 0;
	var _g1 = quake_GL.programs;
	while(_g < _g1.length) {
		var program = _g1[_g];
		++_g;
		program.gl.useProgram(program.program);
		program.setViewOrigin(quake_Render.refdef.vieworg);
		program.setViewAngles(viewMatrix);
		program.setPerspective(quake_Render.perspective);
		program.setGamma(quake_V.gamma.value);
	}
};
quake_Render.SetupGL = function() {
	if(quake_Render.dowarp) {
		quake_GL.gl.bindFramebuffer(36160,quake_Render.warpbuffer);
		quake_GL.gl.clear(16640);
		quake_GL.gl.viewport(0,0,quake_Render.warpwidth,quake_Render.warpheight);
	} else {
		var vrect = quake_Render.refdef.vrect;
		var pixelRatio = quake_SCR.devicePixelRatio;
		quake_GL.gl.viewport(vrect.x * pixelRatio | 0,(quake_VID.height - vrect.height - vrect.y) * pixelRatio | 0,vrect.width * pixelRatio | 0,vrect.height * pixelRatio | 0);
	}
	quake_Render.Perspective();
	quake_GL.gl.enable(2929);
};
quake_Render.RenderScene = function() {
	if(quake_CL.state.maxclients >= 2) {
		quake_Render.fullbright.set("0");
	}
	quake_Render.AnimateLight();
	quake__$Vec_Vec_$Impl_$.AngleVectors(quake_Render.refdef.viewangles,quake_Render.vpn,quake_Render.vright,quake_Render.vup);
	quake_Render.viewleaf = quake_Mod_$Brush.PointInLeaf(quake_Render.refdef.vieworg,quake_CL.state.worldmodel);
	quake_V.SetContentsColor(quake_Render.viewleaf.contents);
	quake_V.CalcBlend();
	quake_Render.dowarp = quake_Render.waterwarp.value != 0 && quake_Render.viewleaf.contents <= -3;
	quake_Render.SetFrustum();
	quake_Render.SetupGL();
	quake_Render.MarkLeaves();
	quake_GL.gl.enable(2884);
	quake_Render.DrawSkyBox();
	quake_Render.DrawViewModel();
	quake_Render.DrawWorld();
	quake_Render.DrawEntitiesOnList();
	quake_GL.gl.disable(2884);
	quake_Render.RenderDlights();
	quake_Render.DrawParticles();
};
quake_Render.RenderView = function() {
	quake_GL.gl.finish();
	var time1 = null;
	if(quake_Render.speeds.value != 0) {
		time1 = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	}
	quake_Render.c_brush_verts = 0;
	quake_Render.c_alias_polys = 0;
	quake_GL.gl.clear(16640);
	quake_Render.RenderScene();
	if(quake_Render.speeds.value != 0) {
		var time2 = Math.floor((new Date().getTime() * 0.001 - quake_Sys.oldtime - time1) * 1000.0);
		var c_brush_polys = quake_Render.c_brush_verts / 3;
		var c_alias_polys = quake_Render.c_alias_polys;
		var msg = (time2 >= 100 ? "" : time2 >= 10 ? " " : "  ") + time2 + " ms  ";
		msg += (c_brush_polys >= 1000 ? "" : c_brush_polys >= 100 ? " " : c_brush_polys >= 10 ? "  " : "   ") + c_brush_polys + " wpoly ";
		msg += (c_alias_polys >= 1000 ? "" : c_alias_polys >= 100 ? " " : c_alias_polys >= 10 ? "  " : "   ") + c_alias_polys + " epoly\n";
		quake_Console.Print(msg);
	}
};
quake_Render.MakeBrushModelDisplayLists = function(m) {
	if(m.cmds != null) {
		quake_GL.gl.deleteBuffer(m.cmds);
	}
	var cmds = [];
	var styles_0 = 0.0;
	var styles_1 = 0.0;
	var styles_2 = 0.0;
	var styles_3 = 0.0;
	var verts = 0;
	m.chains = [];
	var _g = 0;
	var _g1 = m.textures.length;
	while(_g < _g1) {
		var i = _g++;
		var texture = m.textures[i];
		if(texture.sky || texture.turbulent) {
			continue;
		}
		var chain = [i,verts,0];
		var _g2 = 0;
		var _g11 = m.numfaces;
		while(_g2 < _g11) {
			var surf = m.faces[m.firstface + _g2++];
			if(surf.texture != i) {
				continue;
			}
			styles_3 = 0.0;
			styles_2 = 0.0;
			styles_1 = 0.0;
			styles_0 = 0.0;
			switch(surf.styles.length) {
			case 1:
				styles_0 = surf.styles[0] * 0.015625 + 0.0078125;
				break;
			case 2:
				styles_1 = surf.styles[1] * 0.015625 + 0.0078125;
				break;
			case 3:
				styles_2 = surf.styles[2] * 0.015625 + 0.0078125;
				break;
			case 4:
				styles_3 = surf.styles[3] * 0.015625 + 0.0078125;
				break;
			}
			chain[2] += surf.verts.length;
			var _g12 = 0;
			var _g21 = surf.verts.length;
			while(_g12 < _g21) {
				var vert = surf.verts[_g12++];
				cmds.push(vert[0]);
				cmds.push(vert[1]);
				cmds.push(vert[2]);
				cmds.push(vert[3]);
				cmds.push(vert[4]);
				cmds.push(vert[5]);
				cmds.push(vert[6]);
				cmds.push(styles_0);
				cmds.push(styles_1);
				cmds.push(styles_2);
				cmds.push(styles_3);
			}
		}
		if(chain[2] != 0) {
			m.chains.push(chain);
			verts += chain[2];
		}
	}
	m.waterchain = verts * 44;
	verts = 0;
	var _g22 = 0;
	var _g3 = m.textures.length;
	while(_g22 < _g3) {
		var i1 = _g22++;
		if(!m.textures[i1].turbulent) {
			continue;
		}
		var chain1 = [i1,verts,0];
		var _g23 = 0;
		var _g31 = m.numfaces;
		while(_g23 < _g31) {
			var surf1 = m.faces[m.firstface + _g23++];
			if(surf1.texture != i1) {
				continue;
			}
			chain1[2] += surf1.verts.length;
			var _g24 = 0;
			var _g32 = surf1.verts.length;
			while(_g24 < _g32) {
				var vert1 = surf1.verts[_g24++];
				cmds.push(vert1[0]);
				cmds.push(vert1[1]);
				cmds.push(vert1[2]);
				cmds.push(vert1[3]);
				cmds.push(vert1[4]);
			}
		}
		if(chain1[2] != 0) {
			m.chains.push(chain1);
			verts += chain1[2];
		}
	}
	m.cmds = quake_GL.gl.createBuffer();
	quake_GL.gl.bindBuffer(34962,m.cmds);
	quake_GL.gl.bufferData(34962,new Float32Array(cmds),35044);
};
quake_Render.MakeWorldModelDisplayLists = function(m) {
	if(m.cmds != null) {
		return;
	}
	var cmds = [];
	var styles_0 = 0.0;
	var styles_1 = 0.0;
	var styles_2 = 0.0;
	var styles_3 = 0.0;
	var verts = 0;
	var _g = 0;
	var _g1 = m.textures.length;
	while(_g < _g1) {
		var i = _g++;
		var texture = m.textures[i];
		if(texture.sky || texture.turbulent) {
			continue;
		}
		var _g2 = 0;
		var _g11 = m.leafs.length;
		while(_g2 < _g11) {
			var leaf = m.leafs[_g2++];
			var chain = [i,verts,0];
			var _g3 = 0;
			var _g12 = leaf.nummarksurfaces;
			while(_g3 < _g12) {
				var surf = m.faces[m.marksurfaces[leaf.firstmarksurface + _g3++]];
				if(surf.texture != i) {
					continue;
				}
				styles_3 = 0.0;
				styles_2 = 0.0;
				styles_1 = 0.0;
				styles_0 = 0.0;
				switch(surf.styles.length) {
				case 1:
					styles_0 = surf.styles[0] * 0.015625 + 0.0078125;
					break;
				case 2:
					styles_1 = surf.styles[1] * 0.015625 + 0.0078125;
					styles_0 = surf.styles[0] * 0.015625 + 0.0078125;
					break;
				case 3:
					styles_2 = surf.styles[2] * 0.015625 + 0.0078125;
					styles_1 = surf.styles[1] * 0.015625 + 0.0078125;
					styles_0 = surf.styles[0] * 0.015625 + 0.0078125;
					break;
				case 4:
					styles_3 = surf.styles[3] * 0.015625 + 0.0078125;
					styles_2 = surf.styles[2] * 0.015625 + 0.0078125;
					styles_1 = surf.styles[1] * 0.015625 + 0.0078125;
					styles_0 = surf.styles[0] * 0.015625 + 0.0078125;
					break;
				}
				chain[2] += surf.verts.length;
				var _g13 = 0;
				var _g21 = surf.verts;
				while(_g13 < _g21.length) {
					var vert = _g21[_g13];
					++_g13;
					cmds.push(vert[0]);
					cmds.push(vert[1]);
					cmds.push(vert[2]);
					cmds.push(vert[3]);
					cmds.push(vert[4]);
					cmds.push(vert[5]);
					cmds.push(vert[6]);
					cmds.push(styles_0);
					cmds.push(styles_1);
					cmds.push(styles_2);
					cmds.push(styles_3);
				}
			}
			if(chain[2] != 0) {
				leaf.cmds.push(chain);
				++leaf.skychain;
				++leaf.waterchain;
				verts += chain[2];
			}
		}
	}
	m.skychain = verts * 44;
	verts = 0;
	var _g22 = 0;
	var _g31 = m.textures.length;
	while(_g22 < _g31) {
		var i1 = _g22++;
		if(!m.textures[i1].sky) {
			continue;
		}
		var _g23 = 0;
		var _g32 = m.leafs.length;
		while(_g23 < _g32) {
			var leaf1 = m.leafs[_g23++];
			var chain1 = [verts,0];
			var _g24 = 0;
			var _g33 = leaf1.nummarksurfaces;
			while(_g24 < _g33) {
				var surf1 = m.faces[m.marksurfaces[leaf1.firstmarksurface + _g24++]];
				if(surf1.texture != i1) {
					continue;
				}
				chain1[1] += surf1.verts.length;
				var _g25 = 0;
				var _g34 = surf1.verts.length;
				while(_g25 < _g34) {
					var vert1 = surf1.verts[_g25++];
					cmds.push(vert1[0]);
					cmds.push(vert1[1]);
					cmds.push(vert1[2]);
				}
			}
			if(chain1[1] != 0) {
				leaf1.cmds.push(chain1);
				++leaf1.waterchain;
				verts += chain1[1];
			}
		}
	}
	m.waterchain = m.skychain + verts * 12;
	verts = 0;
	var _g4 = 0;
	var _g5 = m.textures.length;
	while(_g4 < _g5) {
		var i2 = _g4++;
		if(!m.textures[i2].turbulent) {
			continue;
		}
		var _g41 = 0;
		var _g51 = m.leafs.length;
		while(_g41 < _g51) {
			var leaf2 = m.leafs[_g41++];
			var chain2 = [i2,verts,0];
			var _g42 = 0;
			var _g52 = leaf2.nummarksurfaces;
			while(_g42 < _g52) {
				var surf2 = m.faces[m.marksurfaces[leaf2.firstmarksurface + _g42++]];
				if(surf2.texture != i2) {
					continue;
				}
				chain2[2] += surf2.verts.length;
				var _g43 = 0;
				var _g53 = surf2.verts.length;
				while(_g43 < _g53) {
					var vert2 = surf2.verts[_g43++];
					cmds.push(vert2[0]);
					cmds.push(vert2[1]);
					cmds.push(vert2[2]);
					cmds.push(vert2[3]);
					cmds.push(vert2[4]);
				}
			}
			if(chain2[2] != 0) {
				leaf2.cmds.push(chain2);
				verts += chain2[2];
			}
		}
	}
	m.cmds = quake_GL.gl.createBuffer();
	quake_GL.gl.bindBuffer(34962,m.cmds);
	quake_GL.gl.bufferData(34962,new Float32Array(cmds),35044);
};
quake_Render.InitTextures = function() {
	var data = new Uint8Array(new ArrayBuffer(256));
	var _g = 0;
	while(_g < 8) {
		var i = _g++;
		var _g1 = 0;
		while(_g1 < 8) {
			var j = _g1++;
			data[136 + (i << 4) + j] = 255;
			data[(i << 4) + j] = 255;
			data[128 + (i << 4) + j] = 0;
			data[8 + (i << 4) + j] = 0;
		}
	}
	var t = new quake_MTexture();
	t.name = "notexture";
	t.width = 16;
	t.height = 16;
	t.texturenum = quake_GL.gl.createTexture();
	quake_Render.notexture_mip = t;
	quake_GL.Bind(0,quake_Render.notexture_mip.texturenum);
	quake_GL.Upload(data,16,16);
	quake_Render.solidskytexture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Render.solidskytexture);
	quake_GL.gl.texParameteri(3553,10241,9729);
	quake_GL.gl.texParameteri(3553,10240,9729);
	quake_Render.alphaskytexture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Render.alphaskytexture);
	quake_GL.gl.texParameteri(3553,10241,9729);
	quake_GL.gl.texParameteri(3553,10240,9729);
	quake_Render.lightmap_texture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Render.lightmap_texture);
	quake_GL.gl.texParameteri(3553,10241,9729);
	quake_GL.gl.texParameteri(3553,10240,9729);
	quake_Render.dlightmap_texture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Render.dlightmap_texture);
	quake_GL.gl.texParameteri(3553,10241,9729);
	quake_GL.gl.texParameteri(3553,10240,9729);
	quake_Render.lightstyle_texture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Render.lightstyle_texture);
	quake_GL.gl.texParameteri(3553,10241,9728);
	quake_GL.gl.texParameteri(3553,10240,9728);
	quake_Render.fullbright_texture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Render.fullbright_texture);
	quake_GL.gl.texImage2D(3553,0,6408,1,1,0,6408,5121,new Uint8Array([255,0,0,0]));
	quake_GL.gl.texParameteri(3553,10241,9728);
	quake_GL.gl.texParameteri(3553,10240,9728);
	quake_Render.null_texture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Render.null_texture);
	quake_GL.gl.texImage2D(3553,0,6408,1,1,0,6408,5121,new Uint8Array([0,0,0,0]));
	quake_GL.gl.texParameteri(3553,10241,9728);
	quake_GL.gl.texParameteri(3553,10240,9728);
};
quake_Render.Init = function() {
	quake_Render.InitTextures();
	quake_Cmd.AddCommand("timerefresh",quake_Render.TimeRefresh_f);
	quake_Cmd.AddCommand("pointfile",quake_Render.ReadPointFile_f);
	quake_Render.waterwarp = quake_Cvar.RegisterVariable("r_waterwarp","1");
	quake_Render.fullbright = quake_Cvar.RegisterVariable("r_fullbright","0");
	quake_Render.drawentities = quake_Cvar.RegisterVariable("r_drawentities","1");
	quake_Render.drawviewmodel = quake_Cvar.RegisterVariable("r_drawviewmodel","1");
	quake_Render.novis = quake_Cvar.RegisterVariable("r_novis","0");
	quake_Render.speeds = quake_Cvar.RegisterVariable("r_speeds","0");
	quake_Render.polyblend = quake_Cvar.RegisterVariable("gl_polyblend","1");
	quake_Render.flashblend = quake_Cvar.RegisterVariable("gl_flashblend","0");
	quake_Render.nocolors = quake_Cvar.RegisterVariable("gl_nocolors","0");
	quake_Render.InitParticles();
	quake_Render.warpbuffer = quake_GL.gl.createFramebuffer();
	quake_Render.warptexture = quake_GL.gl.createTexture();
	quake_GL.Bind(0,quake_Render.warptexture);
	quake_GL.gl.texParameteri(3553,10241,9729);
	quake_GL.gl.texParameteri(3553,10240,9729);
	quake_GL.gl.texParameteri(3553,10242,33071);
	quake_GL.gl.texParameteri(3553,10243,33071);
	quake_Render.warprenderbuffer = quake_GL.gl.createRenderbuffer();
	quake_GL.gl.bindRenderbuffer(36161,quake_Render.warprenderbuffer);
	quake_GL.gl.renderbufferStorage(36161,33189,0,0);
	quake_GL.gl.bindRenderbuffer(36161,null);
	quake_GL.gl.bindFramebuffer(36160,quake_Render.warpbuffer);
	quake_GL.gl.framebufferTexture2D(36160,36064,3553,quake_Render.warptexture,0);
	quake_GL.gl.framebufferRenderbuffer(36160,36096,36161,quake_Render.warprenderbuffer);
	quake_GL.gl.bindFramebuffer(36160,null);
	quake_Render.dlightvecs = quake_GL.gl.createBuffer();
	quake_GL.gl.bindBuffer(34962,quake_Render.dlightvecs);
	quake_GL.gl.bufferData(34962,new Float32Array([0.0,-1.0,0.0,0.0,0.0,1.0,-0.382683,0.0,0.92388,-0.707107,0.0,0.707107,-0.92388,0.0,0.382683,-1.0,0.0,0.0,-0.92388,0.0,-0.382683,-0.707107,0.0,-0.707107,-0.382683,0.0,-0.92388,0.0,0.0,-1.0,0.382683,0.0,-0.92388,0.707107,0.0,-0.707107,0.92388,0.0,-0.382683,1.0,0.0,0.0,0.92388,0.0,0.382683,0.707107,0.0,0.707107,0.382683,0.0,0.92388,0.0,0.0,1.0]),35044);
	quake_Render.MakeSky();
};
quake_Render.NewMap = function() {
	var _g = 0;
	while(_g < 64) quake_Render.lightstylevalue[_g++] = 12;
	quake_Render.ClearParticles();
	quake_Render.BuildLightmaps();
	var _g1 = 0;
	while(_g1 < 1048576) quake_Render.dlightmaps[_g1++] = 0;
	quake_GL.Bind(0,quake_Render.dlightmap_texture);
	quake_GL.gl.texImage2D(3553,0,6406,1024,1024,0,6406,5121,null);
};
quake_Render.TimeRefresh_f = function() {
	quake_GL.gl.finish();
	var start = new Date().getTime() * 0.001 - quake_Sys.oldtime;
	var _g = 0;
	while(_g < 128) {
		quake_Render.refdef.viewangles[1] = _g++ * 2.8125;
		quake_Render.RenderView();
	}
	quake_GL.gl.finish();
	var time = new Date().getTime() * 0.001 - quake_Sys.oldtime - start;
	quake_Console.Print(time.toFixed(6) + " seconds (" + (128.0 / time).toFixed(6) + " fps)\n");
};
quake_Render.InitParticles = function() {
	var numparticles;
	var i = quake_COM.CheckParm("-particles");
	if(i != null) {
		numparticles = quake_Q.atoi(quake_COM.argv[i + 1]);
		if(numparticles < 512) {
			numparticles = 512;
		}
	} else {
		numparticles = 2048;
	}
	var _g = [];
	var _g1 = 0;
	var _g2 = numparticles;
	while(_g1 < _g2) {
		++_g1;
		_g.push(new quake__$Render_Particle());
	}
	quake_Render.particles = _g;
	quake_Render.avelocities = [];
	var _g3 = 0;
	while(_g3 < 162) {
		++_g3;
		var tmp = quake_Render.avelocities;
		var x = Math.random() * 2.56;
		var y = Math.random() * 2.56;
		var z = Math.random() * 2.56;
		var v = new Float32Array(3);
		v[0] = x;
		v[1] = y;
		v[2] = z;
		tmp.push(v);
	}
};
quake_Render.EntityParticles = function(ent) {
	var allocated = quake_Render.AllocParticles(162);
	var _g = 0;
	var _g1 = allocated.length;
	while(_g < _g1) {
		var i = _g++;
		var p = quake_Render.particles[allocated[i]];
		var angle = quake_CL.state.time * quake_Render.avelocities[i][0];
		var sy = Math.sin(angle);
		var cy = Math.cos(angle);
		var angle1 = quake_CL.state.time * quake_Render.avelocities[i][1];
		var sp = Math.sin(angle1);
		var cp = Math.cos(angle1);
		p.die = quake_CL.state.time + 0.01;
		p.color = 111;
		p.type = 4;
		var this1 = p.org;
		this1[0] = ent.origin[0] + quake_Render.avertexnormals[i * 3] * 64 + cp * cy * 16;
		this1[1] = ent.origin[1] + quake_Render.avertexnormals[i * 3 + 1] * 64 + cp * sy * 16;
		this1[2] = ent.origin[2] + quake_Render.avertexnormals[i * 3 + 2] * 64 - sp * 16;
	}
};
quake_Render.ClearParticles = function() {
	var _g = 0;
	var _g1 = quake_Render.particles;
	while(_g < _g1.length) _g1[_g++].die = -1.0;
};
quake_Render.ReadPointFile_f = function() {
	if(!quake_SV.server.active) {
		return;
	}
	var name = "maps/" + quake_PR.GetString(quake_PR.globals.ints[34]) + ".pts";
	var f = quake_COM.LoadTextFile(name);
	if(f == null) {
		quake_Console.Print("couldn't open " + name + "\n");
		return;
	}
	quake_Console.Print("Reading " + name + "...\n");
	var f1 = f.split("\n");
	var c = 0;
	while(c < f1.length) {
		var org = f1[c].split(" ");
		if(org.length != 3) {
			break;
		}
		++c;
		var p = quake_Render.AllocParticles(1);
		if(p.length == 0) {
			quake_Console.Print("Not enough free particles\n");
			break;
		}
		var p1 = quake_Render.particles[p[0]];
		p1.type = 0;
		p1.die = 99999.0;
		p1.color = -c & 15;
		var this1 = p1.org;
		var x = quake_Q.atof(org[0]);
		var y = quake_Q.atof(org[1]);
		var z = quake_Q.atof(org[2]);
		this1[0] = x;
		this1[1] = y;
		this1[2] = z;
	}
	quake_Console.Print(c + " points read\n");
};
quake_Render.ParseParticleEffect = function() {
	var x = quake_MSG.ReadShort() * 0.125;
	var y = quake_MSG.ReadShort() * 0.125;
	var z = quake_MSG.ReadShort() * 0.125;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var x1 = quake_MSG.ReadChar() * 0.0625;
	var y1 = quake_MSG.ReadChar() * 0.0625;
	var z1 = quake_MSG.ReadChar() * 0.0625;
	var v1 = new Float32Array(3);
	v1[0] = x1;
	v1[1] = y1;
	v1[2] = z1;
	var msgcount = quake_MSG.ReadByte();
	var color = quake_MSG.ReadByte();
	if(msgcount == 255) {
		quake_Render.ParticleExplosion(v);
	} else {
		quake_Render.RunParticleEffect(v,v1,color,msgcount);
	}
};
quake_Render.ParticleExplosion = function(org) {
	var allocated = quake_Render.AllocParticles(1024);
	var _g = 0;
	var _g1 = allocated.length;
	while(_g < _g1) {
		var i = _g++;
		var p = quake_Render.particles[allocated[i]];
		p.type = (i & 1) != 0 ? 4 : 5;
		p.die = quake_CL.state.time + 5.0;
		p.color = quake_Render.ramp1[0];
		p.ramp = Math.floor(Math.random() * 4.0);
		var this1 = p.vel;
		var x = Math.random() * 512.0 - 256.0;
		var y = Math.random() * 512.0 - 256.0;
		var z = Math.random() * 512.0 - 256.0;
		this1[0] = x;
		this1[1] = y;
		this1[2] = z;
		var this2 = p.org;
		var x1 = org[0] + Math.random() * 32.0 - 16.0;
		var y1 = org[1] + Math.random() * 32.0 - 16.0;
		var z1 = org[2] + Math.random() * 32.0 - 16.0;
		this2[0] = x1;
		this2[1] = y1;
		this2[2] = z1;
	}
};
quake_Render.ParticleExplosion2 = function(org,colorStart,colorLength) {
	var allocated = quake_Render.AllocParticles(512);
	var colorMod = 0;
	var _g = 0;
	while(_g < allocated.length) {
		var p = quake_Render.particles[allocated[_g++]];
		p.type = 6;
		p.die = quake_CL.state.time + 0.3;
		p.color = colorStart + colorMod++ % colorLength;
		var this1 = p.org;
		var x = org[0] + Math.random() * 32.0 - 16.0;
		var y = org[1] + Math.random() * 32.0 - 16.0;
		var z = org[2] + Math.random() * 32.0 - 16.0;
		this1[0] = x;
		this1[1] = y;
		this1[2] = z;
		var this2 = p.vel;
		var x1 = Math.random() * 512.0 - 256.0;
		var y1 = Math.random() * 512.0 - 256.0;
		var z1 = Math.random() * 512.0 - 256.0;
		this2[0] = x1;
		this2[1] = y1;
		this2[2] = z1;
	}
};
quake_Render.BlobExplosion = function(org) {
	var allocated = quake_Render.AllocParticles(1024);
	var _g = 0;
	var _g1 = allocated.length;
	while(_g < _g1) {
		var i = _g++;
		var p = quake_Render.particles[allocated[i]];
		p.die = quake_CL.state.time + 1.0 + Math.random() * 0.4;
		if((i & 1) != 0) {
			p.type = 6;
			p.color = 66 + Math.floor(Math.random() * 7.0);
		} else {
			p.type = 7;
			p.color = 150 + Math.floor(Math.random() * 7.0);
		}
		var this1 = p.org;
		var x = org[0] + Math.random() * 32.0 - 16.0;
		var y = org[1] + Math.random() * 32.0 - 16.0;
		var z = org[2] + Math.random() * 32.0 - 16.0;
		this1[0] = x;
		this1[1] = y;
		this1[2] = z;
		var this2 = p.vel;
		var x1 = Math.random() * 512.0 - 256.0;
		var y1 = Math.random() * 512.0 - 256.0;
		var z1 = Math.random() * 512.0 - 256.0;
		this2[0] = x1;
		this2[1] = y1;
		this2[2] = z1;
	}
};
quake_Render.RunParticleEffect = function(org,dir,color,count) {
	var allocated = quake_Render.AllocParticles(count);
	var _g = 0;
	while(_g < allocated.length) {
		var p = quake_Render.particles[allocated[_g++]];
		p.type = 2;
		p.die = quake_CL.state.time + 0.6 * Math.random();
		p.color = (color & 248) + Math.floor(Math.random() * 8.0);
		var this1 = p.org;
		var x = org[0] + Math.random() * 16.0 - 8.0;
		var y = org[1] + Math.random() * 16.0 - 8.0;
		var z = org[2] + Math.random() * 16.0 - 8.0;
		this1[0] = x;
		this1[1] = y;
		this1[2] = z;
		var this2 = p.vel;
		this2[0] = dir[0] * 15.0;
		this2[1] = dir[1] * 15.0;
		this2[2] = dir[2] * 15.0;
	}
};
quake_Render.LavaSplash = function(org) {
	var allocated = quake_Render.AllocParticles(1024);
	var dir = new Float32Array(3);
	var k = 0;
	var _g = -16;
	while(_g < 16) {
		var i = _g++;
		var _g1 = -16;
		while(_g1 < 16) {
			var j = _g1++;
			if(k >= allocated.length) {
				return;
			}
			var p = quake_Render.particles[allocated[k++]];
			p.die = quake_CL.state.time + 2.0 + Math.random() * 0.64;
			p.color = 224 + Math.floor(Math.random() * 8.0);
			p.type = 2;
			dir[0] = (j + Math.random()) * 8.0;
			dir[1] = (i + Math.random()) * 8.0;
			dir[2] = 256.0;
			var this1 = p.org;
			var z = org[2] + Math.random() * 64.0;
			this1[0] = org[0] + dir[0];
			this1[1] = org[1] + dir[1];
			this1[2] = z;
			quake__$Vec_Vec_$Impl_$.Normalize(dir);
			var vel = 50.0 + Math.random() * 64.0;
			var this2 = p.vel;
			this2[0] = dir[0] * vel;
			this2[1] = dir[1] * vel;
			this2[2] = dir[2] * vel;
		}
	}
};
quake_Render.TeleportSplash = function(org) {
	var allocated = quake_Render.AllocParticles(896);
	var j;
	var k;
	var l = 0;
	var dir = new Float32Array(3);
	var i = -16;
	while(i < 16) {
		j = -16;
		while(j < 16) {
			k = -24;
			while(k < 32) {
				if(l >= allocated.length) {
					return;
				}
				var p = quake_Render.particles[allocated[l++]];
				p.die = quake_CL.state.time + 0.2 + Math.random() * 0.16;
				p.color = 7 + Math.floor(Math.random() * 8.0);
				p.type = 2;
				dir[0] = j * 8.0;
				dir[1] = i * 8.0;
				dir[2] = k * 8.0;
				var this1 = p.org;
				var x = org[0] + i + Math.random() * 4.0;
				var y = org[1] + j + Math.random() * 4.0;
				var z = org[2] + k + Math.random() * 4.0;
				this1[0] = x;
				this1[1] = y;
				this1[2] = z;
				quake__$Vec_Vec_$Impl_$.Normalize(dir);
				var vel = 50.0 + Math.random() * 64.0;
				var this2 = p.vel;
				this2[0] = dir[0] * vel;
				this2[1] = dir[1] * vel;
				this2[2] = dir[2] * vel;
				k += 4;
			}
			j += 4;
		}
		i += 4;
	}
};
quake_Render.RocketTrail = function(start,end,type) {
	var v = new Float32Array(3);
	v[0] = end[0] - start[0];
	v[1] = end[1] - start[1];
	v[2] = end[2] - start[2];
	var len = quake__$Vec_Vec_$Impl_$.Normalize(v);
	if(len == 0.0) {
		return;
	}
	var allocated;
	if(type == 4) {
		allocated = quake_Render.AllocParticles(Math.floor(len / 6.0));
	} else {
		allocated = quake_Render.AllocParticles(Math.floor(len / 3.0));
	}
	var _g = 0;
	while(_g < allocated.length) {
		var p = quake_Render.particles[allocated[_g++]];
		p.vel.set(quake__$Vec_Vec_$Impl_$.origin);
		p.die = quake_CL.state.time + 2.0;
		switch(type) {
		case 0:case 1:
			p.ramp = Math.floor(Math.random() * 4.0) + (type << 1);
			p.color = quake_Render.ramp3[p.ramp | 0];
			p.type = 3;
			var this1 = p.org;
			var x = start[0] + Math.random() * 6.0 - 3.0;
			var y = start[1] + Math.random() * 6.0 - 3.0;
			var z = start[2] + Math.random() * 6.0 - 3.0;
			this1[0] = x;
			this1[1] = y;
			this1[2] = z;
			break;
		case 2:
			p.type = 1;
			p.color = 67 + Math.floor(Math.random() * 4.0);
			var this2 = p.org;
			var x1 = start[0] + Math.random() * 6.0 - 3.0;
			var y1 = start[1] + Math.random() * 6.0 - 3.0;
			var z1 = start[2] + Math.random() * 6.0 - 3.0;
			this2[0] = x1;
			this2[1] = y1;
			this2[2] = z1;
			break;
		case 3:case 5:
			p.die = quake_CL.state.time + 0.5;
			p.type = 0;
			if(type == 3) {
				p.color = 52 + ((quake_Render.tracercount++ & 4) << 1);
			} else {
				p.color = 230 + ((quake_Render.tracercount++ & 4) << 1);
			}
			p.org.set(start);
			if((quake_Render.tracercount & 1) != 0) {
				p.vel[0] = 30.0 * v[1];
				p.vel[2] = -30.0 * v[0];
			} else {
				p.vel[0] = -30.0 * v[1];
				p.vel[2] = 30.0 * v[0];
			}
			break;
		case 4:
			p.type = 1;
			p.color = 67 + Math.floor(Math.random() * 4.0);
			var this3 = p.org;
			var x2 = start[0] + Math.random() * 6.0 - 3.0;
			var y2 = start[1] + Math.random() * 6.0 - 3.0;
			var z2 = start[2] + Math.random() * 6.0 - 3.0;
			this3[0] = x2;
			this3[1] = y2;
			this3[2] = z2;
			break;
		case 6:
			p.color = 152 + Math.floor(Math.random() * 4.0);
			p.type = 0;
			p.die = quake_CL.state.time + 0.3;
			var this4 = p.org;
			var x3 = start[0] + Math.random() * 16.0 - 8.0;
			var y3 = start[1] + Math.random() * 16.0 - 8.0;
			var z3 = start[2] + Math.random() * 16.0 - 8.0;
			this4[0] = x3;
			this4[1] = y3;
			this4[2] = z3;
			break;
		}
		start[0] += v[0];
		start[1] += v[1];
		start[2] += v[2];
	}
};
quake_Render.DrawParticles = function() {
	var program = quake_GL.UseProgram(quake_GLPrograms.particle);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.depthMask(false);
	quake_GL.gl.enable(3042);
	var _g = 0;
	var _g1 = quake_Render.particles;
	while(_g < _g1.length) {
		var p = _g1[_g];
		++_g;
		if(p.die < quake_CL.state.time) {
			continue;
		}
		var color = quake_VID.d_8to24table[p.color];
		quake_GL.gl.uniform3f(program.uColor,color & 255,color >> 8 & 255,color >> 16);
		quake_GL.gl.uniform3fv(program.uOrigin,p.org);
		var scale = (p.org[0] - quake_Render.refdef.vieworg[0]) * quake_Render.vpn[0] + (p.org[1] - quake_Render.refdef.vieworg[1]) * quake_Render.vpn[1] + (p.org[2] - quake_Render.refdef.vieworg[2]) * quake_Render.vpn[2];
		if(scale < 20.0) {
			quake_GL.gl.uniform1f(program.uScale,1.08);
		} else {
			quake_GL.gl.uniform1f(program.uScale,1 + scale * 0.004);
		}
		quake_GL.gl.drawArrays(5,0,4);
	}
	quake_GL.gl.disable(3042);
	quake_GL.gl.depthMask(true);
};
quake_Render.AllocParticles = function(count) {
	var allocated = [];
	var _g = 0;
	var _g1 = quake_Render.particles.length;
	while(_g < _g1) {
		var i = _g++;
		if(count == 0) {
			return allocated;
		}
		if(quake_Render.particles[i].die < quake_CL.state.time) {
			allocated.push(i);
			--count;
		}
	}
	return allocated;
};
quake_Render.AddDynamicLights = function(surf) {
	var smax = (surf.extents[0] >> 4) + 1;
	var tmax = (surf.extents[1] >> 4) + 1;
	var size = smax * tmax;
	var tex = quake_CL.state.worldmodel.texinfo[surf.texinfo];
	var impact = new Float32Array(3);
	var blocklights = [];
	var _g = 0;
	while(_g < size) blocklights[_g++] = 0;
	var _g2 = 0;
	while(_g2 < 32) {
		var i = _g2++;
		if((surf.dlightbits >>> i & 1) == 0) {
			continue;
		}
		var light = quake_CL.dlights[i];
		var v1 = light.origin;
		var v2 = surf.plane.normal;
		var dist = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2] - surf.plane.dist;
		var rad = light.radius - Math.abs(dist);
		var minlight = light.minlight;
		if(rad < minlight) {
			continue;
		}
		minlight = rad - minlight;
		impact[0] = light.origin[0] - surf.plane.normal[0] * dist;
		impact[1] = light.origin[1] - surf.plane.normal[1] * dist;
		impact[2] = light.origin[2] - surf.plane.normal[2] * dist;
		var a = tex.vecs[0];
		var v = new Float32Array(3);
		v[0] = a[0];
		v[1] = a[1];
		v[2] = a[2];
		var local0 = impact[0] * v[0] + impact[1] * v[1] + impact[2] * v[2] + tex.vecs[0][3] - surf.texturemins[0];
		var a1 = tex.vecs[1];
		var v3 = new Float32Array(3);
		v3[0] = a1[0];
		v3[1] = a1[1];
		v3[2] = a1[2];
		var local1 = impact[0] * v3[0] + impact[1] * v3[1] + impact[2] * v3[2] + tex.vecs[1][3] - surf.texturemins[1];
		var _g21 = 0;
		while(_g21 < tmax) {
			var t = _g21++;
			var td = local1 - (t << 4);
			if(td < 0.0) {
				td = -td;
			}
			var td1 = Math.floor(td);
			var _g22 = 0;
			while(_g22 < smax) {
				var s = _g22++;
				var sd = local0 - (s << 4);
				if(sd < 0) {
					sd = -sd;
				}
				var sd1 = Math.floor(sd);
				if(sd1 > td1) {
					dist = sd1 + (td1 >> 1);
				} else {
					dist = td1 + (sd1 >> 1);
				}
				if(dist < minlight) {
					blocklights[t * smax + s] += Math.floor((rad - dist) * 256.0);
				}
			}
		}
	}
	var i1 = 0;
	var _g3 = 0;
	while(_g3 < tmax) {
		var idx = surf.light_t + _g3++;
		if(idx >= 1024) {
			quake_Sys.Error("Funny lightmap_modified index: " + idx + " < 1024");
		}
		quake_Render.lightmap_modified[idx] = 1;
		var dest = (idx << 10) + surf.light_s;
		var _g31 = 0;
		while(_g31 < smax) {
			var s1 = _g31++;
			var bl = blocklights[i1++] >> 7;
			if(bl > 255) {
				bl = 255;
			}
			quake_Render.dlightmaps[dest + s1] = bl;
		}
	}
};
quake_Render.RemoveDynamicLights = function(surf) {
	var smax = (surf.extents[0] >> 4) + 1;
	var tmax = (surf.extents[1] >> 4) + 1;
	var _g = 0;
	while(_g < tmax) {
		var idx = surf.light_t + _g++;
		if(idx >= 1024) {
			quake_Sys.Error("Funny lightmap_modified index: " + idx + " < 1024");
		}
		quake_Render.lightmap_modified[idx] = 1;
		var dest = (idx << 10) + surf.light_s;
		var _g1 = 0;
		while(_g1 < smax) quake_Render.dlightmaps[dest + _g1++] = 0;
	}
};
quake_Render.BuildLightMap = function(surf) {
	var smax = (surf.extents[0] >> 4) + 1;
	var tmax = (surf.extents[1] >> 4) + 1;
	var lightmap = surf.lightofs;
	var maps = 0;
	while(maps < surf.styles.length) {
		var dest = (surf.light_t << 12) + (surf.light_s << 2) + maps;
		var _g = 0;
		while(_g < tmax) {
			++_g;
			var _g1 = 0;
			while(_g1 < smax) {
				var j = _g1++;
				quake_Render.lightmaps[dest + (j << 2)] = quake_Render.currentmodel.lightdata[lightmap + j];
			}
			lightmap += smax;
			dest += 4096;
		}
		++maps;
	}
	while(maps <= 3) {
		var dest1 = (surf.light_t << 12) + (surf.light_s << 2) + maps;
		var _g2 = 0;
		while(_g2 < tmax) {
			++_g2;
			var _g3 = 0;
			while(_g3 < smax) quake_Render.lightmaps[dest1 + (_g3++ << 2)] = 0;
			dest1 += 4096;
		}
		++maps;
	}
};
quake_Render.TextureAnimation = function(base) {
	var frame = 0;
	if(base.anim_base != null) {
		frame = base.anim_frame;
		base = quake_Render.currententity.model.textures[base.anim_base];
	}
	var anims = base.anims;
	if(anims == null) {
		return base;
	}
	if(quake_Render.currententity.frame != 0 && base.alternate_anims.length != 0) {
		anims = base.alternate_anims;
	}
	return quake_Render.currententity.model.textures[anims[(Math.floor(quake_CL.state.time * 5.0) + frame) % anims.length]];
};
quake_Render.DrawBrushModel = function(e) {
	var clmodel = e.model;
	if(clmodel.submodel) {
		var x = e.origin[0] + clmodel.mins[0];
		var y = e.origin[1] + clmodel.mins[1];
		var z = e.origin[2] + clmodel.mins[2];
		var v = new Float32Array(3);
		v[0] = x;
		v[1] = y;
		v[2] = z;
		var x1 = e.origin[0] + clmodel.maxs[0];
		var y1 = e.origin[1] + clmodel.maxs[1];
		var z1 = e.origin[2] + clmodel.maxs[2];
		var v1 = new Float32Array(3);
		v1[0] = x1;
		v1[1] = y1;
		v1[2] = z1;
		if(quake_Render.CullBox(v,v1)) {
			return;
		}
	} else {
		var x2 = e.origin[0] - clmodel.radius;
		var y2 = e.origin[1] - clmodel.radius;
		var z2 = e.origin[2] - clmodel.radius;
		var v2 = new Float32Array(3);
		v2[0] = x2;
		v2[1] = y2;
		v2[2] = z2;
		var x3 = e.origin[0] + clmodel.radius;
		var y3 = e.origin[1] + clmodel.radius;
		var z3 = e.origin[2] + clmodel.radius;
		var v3 = new Float32Array(3);
		v3[0] = x3;
		v3[1] = y3;
		v3[2] = z3;
		if(quake_Render.CullBox(v2,v3)) {
			return;
		}
	}
	quake_GL.gl.bindBuffer(34962,clmodel.cmds);
	var viewMatrix = quake_GL.RotationMatrix(e.angles[0],e.angles[1],e.angles[2]);
	var program = quake_GL.UseProgram(quake_GLPrograms.brush);
	quake_GL.gl.uniform3fv(program.uOrigin,e.origin);
	quake_GL.gl.uniformMatrix3fv(program.uAngles,false,viewMatrix);
	quake_GL.gl.vertexAttribPointer(program.aPoint,3,5126,false,44,0);
	quake_GL.gl.vertexAttribPointer(program.aTexCoord,4,5126,false,44,12);
	quake_GL.gl.vertexAttribPointer(program.aLightStyle,4,5126,false,44,28);
	if(quake_Render.fullbright.value != 0 || clmodel.lightdata == null) {
		quake_GL.Bind(program.tLightmap,quake_Render.fullbright_texture);
	} else {
		quake_GL.Bind(program.tLightmap,quake_Render.lightmap_texture);
	}
	quake_GL.Bind(program.tDlight,quake_Render.flashblend.value == 0 && clmodel.submodel ? quake_Render.dlightmap_texture : quake_Render.null_texture);
	quake_GL.Bind(program.tLightStyle,quake_Render.lightstyle_texture);
	var _g = 0;
	var _g1 = clmodel.chains.length;
	while(_g < _g1) {
		var chain = clmodel.chains[_g++];
		var texture = quake_Render.TextureAnimation(clmodel.textures[chain[0]]);
		if(texture.turbulent) {
			continue;
		}
		quake_Render.c_brush_verts += chain[2];
		quake_GL.Bind(program.tTexture,texture.texturenum);
		quake_GL.gl.drawArrays(4,chain[1],chain[2]);
	}
	var program1 = quake_GL.UseProgram(quake_GLPrograms.turbulent);
	quake_GL.gl.uniform3f(program1.uOrigin,0.0,0.0,0.0);
	quake_GL.gl.uniformMatrix3fv(program1.uAngles,false,viewMatrix);
	quake_GL.gl.uniform1f(program1.uTime,quake_Host.realtime % (Math.PI * 2.0));
	quake_GL.gl.vertexAttribPointer(program1.aPoint,3,5126,false,20,e.model.waterchain);
	quake_GL.gl.vertexAttribPointer(program1.aTexCoord,2,5126,false,20,e.model.waterchain + 12);
	var _g2 = 0;
	var _g3 = clmodel.chains.length;
	while(_g2 < _g3) {
		var chain1 = clmodel.chains[_g2++];
		var texture1 = clmodel.textures[chain1[0]];
		if(!texture1.turbulent) {
			continue;
		}
		quake_Render.c_brush_verts += chain1[2];
		quake_GL.Bind(program1.tTexture,texture1.texturenum);
		quake_GL.gl.drawArrays(4,chain1[1],chain1[2]);
	}
};
quake_Render.RecursiveWorldNode = function(node) {
	if(node.contents == -2) {
		return;
	}
	if(node.contents < 0) {
		if(node.markvisframe != quake_Render.visframecount) {
			return;
		}
		node.visframe = quake_Render.visframecount;
		if(node.skychain != node.waterchain) {
			quake_Render.drawsky = true;
		}
		return;
	}
	quake_Render.RecursiveWorldNode(node.child0);
	quake_Render.RecursiveWorldNode(node.child1);
};
quake_Render.DrawWorld = function() {
	var clmodel = quake_CL.state.worldmodel;
	quake_Render.currententity = quake_CL.entities[0];
	quake_GL.gl.bindBuffer(34962,clmodel.cmds);
	var program = quake_GL.UseProgram(quake_GLPrograms.brush);
	quake_GL.gl.uniform3f(program.uOrigin,0.0,0.0,0.0);
	quake_GL.gl.uniformMatrix3fv(program.uAngles,false,quake_GL.identity);
	quake_GL.gl.vertexAttribPointer(program.aPoint,3,5126,false,44,0);
	quake_GL.gl.vertexAttribPointer(program.aTexCoord,4,5126,false,44,12);
	quake_GL.gl.vertexAttribPointer(program.aLightStyle,4,5126,false,44,28);
	if(quake_Render.fullbright.value != 0 || clmodel.lightdata == null) {
		quake_GL.Bind(program.tLightmap,quake_Render.fullbright_texture);
	} else {
		quake_GL.Bind(program.tLightmap,quake_Render.lightmap_texture);
	}
	if(quake_Render.flashblend.value == 0) {
		quake_GL.Bind(program.tDlight,quake_Render.dlightmap_texture);
	} else {
		quake_GL.Bind(program.tDlight,quake_Render.null_texture);
	}
	quake_GL.Bind(program.tLightStyle,quake_Render.lightstyle_texture);
	var _g = 0;
	var _g1 = clmodel.leafs;
	while(_g < _g1.length) {
		var leaf = _g1[_g];
		++_g;
		if(leaf.visframe != quake_Render.visframecount || leaf.skychain == 0) {
			continue;
		}
		if(quake_Render.CullBox(leaf.mins,leaf.maxs)) {
			continue;
		}
		var _g2 = 0;
		var _g11 = leaf.skychain;
		while(_g2 < _g11) {
			var cmds = leaf.cmds[_g2++];
			quake_Render.c_brush_verts += cmds[2];
			quake_GL.Bind(program.tTexture,quake_Render.TextureAnimation(clmodel.textures[cmds[0]]).texturenum);
			quake_GL.gl.drawArrays(4,cmds[1],cmds[2]);
		}
	}
	var program1 = quake_GL.UseProgram(quake_GLPrograms.turbulent);
	quake_GL.gl.uniform3f(program1.uOrigin,0.0,0.0,0.0);
	quake_GL.gl.uniformMatrix3fv(program1.uAngles,false,quake_GL.identity);
	quake_GL.gl.uniform1f(program1.uTime,quake_Host.realtime % (Math.PI * 2.0));
	quake_GL.gl.vertexAttribPointer(program1.aPoint,3,5126,false,20,clmodel.waterchain);
	quake_GL.gl.vertexAttribPointer(program1.aTexCoord,2,5126,false,20,clmodel.waterchain + 12);
	var _g21 = 0;
	var _g3 = clmodel.leafs;
	while(_g21 < _g3.length) {
		var leaf1 = _g3[_g21];
		++_g21;
		if(leaf1.visframe != quake_Render.visframecount || leaf1.waterchain == leaf1.cmds.length) {
			continue;
		}
		if(quake_Render.CullBox(leaf1.mins,leaf1.maxs)) {
			continue;
		}
		var _g22 = leaf1.waterchain;
		var _g31 = leaf1.cmds.length;
		while(_g22 < _g31) {
			var cmds1 = leaf1.cmds[_g22++];
			quake_Render.c_brush_verts += cmds1[2];
			quake_GL.Bind(program1.tTexture,clmodel.textures[cmds1[0]].texturenum);
			quake_GL.gl.drawArrays(4,cmds1[1],cmds1[2]);
		}
	}
};
quake_Render.MarkLeaves = function() {
	if(quake_Render.oldviewleaf == quake_Render.viewleaf && quake_Render.novis.value == 0) {
		return;
	}
	++quake_Render.visframecount;
	quake_Render.oldviewleaf = quake_Render.viewleaf;
	var vis = quake_Render.novis.value != 0 ? quake_Mod_$Brush.novis : quake_Mod_$Brush.LeafPVS(quake_Render.viewleaf,quake_CL.state.worldmodel);
	var _g = 0;
	var _g1 = quake_CL.state.worldmodel.leafs.length;
	while(_g < _g1) {
		var i = _g++;
		if((vis[i >> 3] & 1 << (i & 7)) == 0) {
			continue;
		}
		var node = quake_CL.state.worldmodel.leafs[i + 1];
		while(node != null) {
			if(node.markvisframe == quake_Render.visframecount) {
				break;
			}
			node.markvisframe = quake_Render.visframecount;
			node = node.parent;
		}
	}
	while(quake_Render.novis.value == 0) {
		var leaf;
		if(quake_Render.viewleaf.contents <= -3) {
			var v = new Float32Array(3);
			v[0] = quake_Render.refdef.vieworg[0];
			v[1] = quake_Render.refdef.vieworg[1];
			v[2] = quake_Render.refdef.vieworg[2] + 16.0;
			leaf = quake_Mod_$Brush.PointInLeaf(v,quake_CL.state.worldmodel);
			if(leaf.contents <= -3) {
				break;
			}
		} else {
			var v1 = new Float32Array(3);
			v1[0] = quake_Render.refdef.vieworg[0];
			v1[1] = quake_Render.refdef.vieworg[1];
			v1[2] = quake_Render.refdef.vieworg[2] - 16.0;
			leaf = quake_Mod_$Brush.PointInLeaf(v1,quake_CL.state.worldmodel);
			if(leaf.contents > -3) {
				break;
			}
		}
		if(leaf == quake_Render.viewleaf) {
			break;
		}
		vis = quake_Mod_$Brush.LeafPVS(leaf,quake_CL.state.worldmodel);
		var _g2 = 0;
		var _g3 = quake_CL.state.worldmodel.leafs.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			if((vis[i1 >> 3] & 1 << (i1 & 7)) == 0) {
				continue;
			}
			var node1 = quake_CL.state.worldmodel.leafs[i1 + 1];
			while(node1 != null) {
				if(node1.markvisframe == quake_Render.visframecount) {
					break;
				}
				node1.markvisframe = quake_Render.visframecount;
				node1 = node1.parent;
			}
		}
		break;
	}
	quake_Render.drawsky = false;
	quake_Render.RecursiveWorldNode(quake_CL.state.worldmodel.nodes[0]);
};
quake_Render.AllocBlock = function(surf) {
	var w = (surf.extents[0] >> 4) + 1;
	var h = (surf.extents[1] >> 4) + 1;
	var x = null;
	var y = null;
	var best = 1024;
	var _g = 0;
	var _g1 = 1024 - w;
	while(_g < _g1) {
		var i = _g++;
		var best2 = 0;
		var j = 0;
		while(j < w) {
			if(quake_Render.allocated[i + j] >= best) {
				break;
			}
			if(quake_Render.allocated[i + j] > best2) {
				best2 = quake_Render.allocated[i + j];
			}
			++j;
		}
		if(j == w) {
			x = i;
			best = best2;
			y = best;
		}
	}
	best += h;
	if(best > 1024) {
		quake_Sys.Error("AllocBlock: full");
	}
	var _g2 = 0;
	while(_g2 < w) quake_Render.allocated[x + _g2++] = best;
	surf.light_s = x;
	surf.light_t = y;
};
quake_Render.BuildSurfaceDisplayList = function(fa) {
	fa.verts = [];
	if(fa.numedges <= 2) {
		return;
	}
	var texinfo = quake_Render.currentmodel.texinfo[fa.texinfo];
	var texture = quake_Render.currentmodel.textures[texinfo.texture];
	var _g = 0;
	var _g1 = fa.numedges;
	while(_g < _g1) {
		var i = _g++;
		var index = quake_Render.currentmodel.surfedges[fa.firstedge + i];
		var vec;
		if(index > 0) {
			vec = quake_Render.currentmodel.vertexes[quake_Render.currentmodel.edges[index][0]];
		} else {
			vec = quake_Render.currentmodel.vertexes[quake_Render.currentmodel.edges[-index][1]];
		}
		var vert = [vec[0],vec[1],vec[2]];
		if(!fa.sky) {
			var a = texinfo.vecs[0];
			var v = new Float32Array(3);
			v[0] = a[0];
			v[1] = a[1];
			v[2] = a[2];
			var s = vec[0] * v[0] + vec[1] * v[1] + vec[2] * v[2] + texinfo.vecs[0][3];
			var a1 = texinfo.vecs[1];
			var v1 = new Float32Array(3);
			v1[0] = a1[0];
			v1[1] = a1[1];
			v1[2] = a1[2];
			var t = vec[0] * v1[0] + vec[1] * v1[1] + vec[2] * v1[2] + texinfo.vecs[1][3];
			vert[3] = s / texture.width;
			vert[4] = t / texture.height;
			if(!fa.turbulent) {
				vert[5] = (s - fa.texturemins[0] + (fa.light_s << 4) + 8.0) / 16384.0;
				vert[6] = (t - fa.texturemins[1] + (fa.light_t << 4) + 8.0) / 16384.0;
			}
		}
		if(i >= 3) {
			fa.verts.push(fa.verts[0]);
			fa.verts.push(fa.verts[fa.verts.length - 2]);
		}
		fa.verts.push(vert);
	}
};
quake_Render.BuildLightmaps = function() {
	quake_Render.allocated = [];
	var _g = 0;
	while(_g < 1024) quake_Render.allocated[_g++] = 0;
	var _g1 = 1;
	var _g2 = quake_CL.state.model_precache.length;
	while(_g1 < _g2) {
		var i = _g1++;
		quake_Render.currentmodel = quake_CL.state.model_precache[i];
		if(quake_Render.currentmodel.type != 0) {
			continue;
		}
		if(HxOverrides.cca(quake_Render.currentmodel.name,0) != 42) {
			var _g11 = 0;
			var _g21 = quake_Render.currentmodel.faces.length;
			while(_g11 < _g21) {
				var surf = quake_Render.currentmodel.faces[_g11++];
				if(!surf.sky && !surf.turbulent) {
					quake_Render.AllocBlock(surf);
					if(quake_Render.currentmodel.lightdata != null) {
						quake_Render.BuildLightMap(surf);
					}
				}
				quake_Render.BuildSurfaceDisplayList(surf);
			}
		}
		if(i == 1) {
			quake_Render.MakeWorldModelDisplayLists(quake_Render.currentmodel);
		} else {
			quake_Render.MakeBrushModelDisplayLists(quake_Render.currentmodel);
		}
	}
	quake_GL.Bind(0,quake_Render.lightmap_texture);
	quake_GL.gl.texImage2D(3553,0,6408,1024,1024,0,6408,5121,quake_Render.lightmaps);
};
quake_Render.WarpScreen = function() {
	quake_GL.gl.finish();
	quake_GL.gl.bindFramebuffer(36160,null);
	quake_GL.gl.bindRenderbuffer(36161,null);
	var program = quake_GL.UseProgram(quake_GLPrograms.warp);
	var vrect = quake_Render.refdef.vrect;
	quake_GL.gl.uniform4f(program.uRect,vrect.x,vrect.y,vrect.width,vrect.height);
	quake_GL.gl.uniform1f(program.uTime,quake_Host.realtime % (Math.PI * 2.0));
	quake_GL.Bind(program.tTexture,quake_Render.warptexture);
	quake_GL.gl.clear(16384);
	quake_GL.gl.bindBuffer(34962,quake_GL.rect);
	quake_GL.gl.vertexAttribPointer(program.aPoint,2,5126,false,0,0);
	quake_GL.gl.drawArrays(5,0,4);
};
quake_Render.MakeSky = function() {
	var sin = [0.0,0.19509,0.382683,0.55557,0.707107,0.831470,0.92388,0.980785,1.0];
	var vecs = [];
	var i = 0;
	while(i < 7) {
		vecs = vecs.concat([0.0,0.0,1.0,sin[i + 2] * 0.19509,sin[6 - i] * 0.19509,0.980785,sin[i] * 0.19509,sin[8 - i] * 0.19509,0.980785]);
		var _g = 0;
		while(_g < 7) {
			var j = _g++;
			vecs = vecs.concat([sin[i] * sin[8 - j],sin[8 - i] * sin[8 - j],sin[j],sin[i] * sin[7 - j],sin[8 - i] * sin[7 - j],sin[j + 1],sin[i + 2] * sin[7 - j],sin[6 - i] * sin[7 - j],sin[j + 1],sin[i] * sin[8 - j],sin[8 - i] * sin[8 - j],sin[j],sin[i + 2] * sin[7 - j],sin[6 - i] * sin[7 - j],sin[j + 1],sin[i + 2] * sin[8 - j],sin[6 - i] * sin[8 - j],sin[j]]);
		}
		i += 2;
	}
	quake_Render.skyvecs = quake_GL.gl.createBuffer();
	quake_GL.gl.bindBuffer(34962,quake_Render.skyvecs);
	quake_GL.gl.bufferData(34962,new Float32Array(vecs),35044);
};
quake_Render.DrawSkyBox = function() {
	if(!quake_Render.drawsky) {
		return;
	}
	quake_GL.gl.colorMask(false,false,false,false);
	var clmodel = quake_CL.state.worldmodel;
	var program = quake_GL.UseProgram(quake_GLPrograms.skyChain);
	quake_GL.gl.bindBuffer(34962,clmodel.cmds);
	quake_GL.gl.vertexAttribPointer(program.aPoint,3,5126,false,12,clmodel.skychain);
	var _g = 0;
	var _g1 = clmodel.leafs.length;
	while(_g < _g1) {
		var leaf = clmodel.leafs[_g++];
		if(leaf.visframe != quake_Render.visframecount || leaf.skychain == leaf.waterchain) {
			continue;
		}
		if(quake_Render.CullBox(leaf.mins,leaf.maxs)) {
			continue;
		}
		var _g2 = leaf.skychain;
		var _g11 = leaf.waterchain;
		while(_g2 < _g11) {
			var cmds = leaf.cmds[_g2++];
			quake_GL.gl.drawArrays(4,cmds[0],cmds[1]);
		}
	}
	quake_GL.gl.colorMask(true,true,true,true);
	quake_GL.gl.depthFunc(516);
	quake_GL.gl.depthMask(false);
	quake_GL.gl.disable(2884);
	var program1 = quake_GL.UseProgram(quake_GLPrograms.sky);
	quake_GL.gl.uniform2f(program1.uTime,quake_Host.realtime * 0.125 % 1.0,quake_Host.realtime * 0.03125 % 1.0);
	quake_GL.Bind(program1.tSolid,quake_Render.solidskytexture);
	quake_GL.Bind(program1.tAlpha,quake_Render.alphaskytexture);
	quake_GL.gl.bindBuffer(34962,quake_Render.skyvecs);
	quake_GL.gl.vertexAttribPointer(program1.aPoint,3,5126,false,12,0);
	quake_GL.gl.uniform3f(program1.uScale,2.0,-2.0,1.0);
	quake_GL.gl.drawArrays(4,0,180);
	quake_GL.gl.uniform3f(program1.uScale,2.0,-2.0,-1.0);
	quake_GL.gl.drawArrays(4,0,180);
	quake_GL.gl.uniform3f(program1.uScale,2.0,2.0,1.0);
	quake_GL.gl.drawArrays(4,0,180);
	quake_GL.gl.uniform3f(program1.uScale,2.0,2.0,-1.0);
	quake_GL.gl.drawArrays(4,0,180);
	quake_GL.gl.uniform3f(program1.uScale,-2.0,-2.0,1.0);
	quake_GL.gl.drawArrays(4,0,180);
	quake_GL.gl.uniform3f(program1.uScale,-2.0,-2.0,-1.0);
	quake_GL.gl.drawArrays(4,0,180);
	quake_GL.gl.uniform3f(program1.uScale,-2.0,2.0,1.0);
	quake_GL.gl.drawArrays(4,0,180);
	quake_GL.gl.uniform3f(program1.uScale,-2.0,2.0,-1.0);
	quake_GL.gl.drawArrays(4,0,180);
	quake_GL.gl.enable(2884);
	quake_GL.gl.depthMask(true);
	quake_GL.gl.depthFunc(513);
};
quake_Render.InitSky = function(src) {
	var trans = new ArrayBuffer(65536);
	var trans32 = new Uint32Array(trans);
	var _g = 0;
	while(_g < 128) {
		var i = _g++;
		var _g1 = 0;
		while(_g1 < 128) {
			var j = _g1++;
			trans32[(i << 7) + j] = quake_COM.LittleLong(quake_VID.d_8to24table[src[(i << 8) + j + 128]] + (-16777216));
		}
	}
	quake_GL.Bind(0,quake_Render.solidskytexture);
	quake_GL.gl.texImage2D(3553,0,6408,128,128,0,6408,5121,new Uint8Array(trans));
	quake_GL.gl.generateMipmap(3553);
	var _g11 = 0;
	while(_g11 < 128) {
		var i1 = _g11++;
		var _g12 = 0;
		while(_g12 < 128) {
			var j1 = _g12++;
			var p = (i1 << 8) + j1;
			if(src[p] != 0) {
				trans32[(i1 << 7) + j1] = quake_COM.LittleLong(quake_VID.d_8to24table[src[p]] + (-16777216));
			} else {
				trans32[(i1 << 7) + j1] = 0;
			}
		}
	}
	quake_GL.Bind(0,quake_Render.alphaskytexture);
	quake_GL.gl.texImage2D(3553,0,6408,128,128,0,6408,5121,new Uint8Array(trans));
	quake_GL.gl.generateMipmap(3553);
};
var quake_PF = function() { };
quake_PF.__name__ = true;
quake_PF.VarString = function(first) {
	var out = "";
	var _g = first;
	var _g1 = quake_PF.argc;
	while(_g < _g1) out += quake_PR.GetString(quake_PR.globals.ints[4 + _g++ * 3]);
	return out;
};
quake_PF.error = function() {
	quake_Console.Print("====SERVER ERROR in " + quake_PR.GetString(quake_PR.xfunction.name) + "\n" + quake_PF.VarString(0) + "\n");
	quake_ED.Print(quake_SV.server.edicts[quake_PR.globals.ints[28]]);
	quake_Host.Error("Program error");
};
quake_PF.objerror = function() {
	quake_Console.Print("====OBJECT ERROR in " + quake_PR.GetString(quake_PR.xfunction.name) + "\n" + quake_PF.VarString(0) + "\n");
	quake_ED.Print(quake_SV.server.edicts[quake_PR.globals.ints[28]]);
	quake_Host.Error("Program error");
};
quake_PF.makevectors = function() {
	var _this = quake_PR.globals;
	var x = _this.floats[4];
	var y = _this.floats[5];
	var z = _this.floats[6];
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	quake__$Vec_Vec_$Impl_$.AngleVectors(v,quake_PR.globals.v_forward,quake_PR.globals.v_right,quake_PR.globals.v_up);
};
quake_PF.setorigin = function() {
	var e = quake_SV.server.edicts[quake_PR.globals.ints[4]];
	var this1 = e.v.origin;
	var y = quake_PR.globals.floats[8];
	var z = quake_PR.globals.floats[9];
	this1[0] = quake_PR.globals.floats[7];
	this1[1] = y;
	this1[2] = z;
	quake_SV.LinkEdict(e,false);
};
quake_PF.SetMinMaxSize = function(e,min,max) {
	if(min[0] > max[0] || min[1] > max[1] || min[2] > max[2]) {
		quake_PR.RunError("backwards mins/maxs");
	}
	e.v.mins.set(min);
	e.v.maxs.set(max);
	var this1 = e.v.size;
	this1[0] = max[0] - min[0];
	this1[1] = max[1] - min[1];
	this1[2] = max[2] - min[2];
	quake_SV.LinkEdict(e,false);
};
quake_PF.setsize = function() {
	var tmp = quake_SV.server.edicts[quake_PR.globals.ints[4]];
	var _this = quake_PR.globals;
	var x = _this.floats[7];
	var y = _this.floats[8];
	var z = _this.floats[9];
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var _this1 = quake_PR.globals;
	var x1 = _this1.floats[10];
	var y1 = _this1.floats[11];
	var z1 = _this1.floats[12];
	var v1 = new Float32Array(3);
	v1[0] = x1;
	v1[1] = y1;
	v1[2] = z1;
	quake_PF.SetMinMaxSize(tmp,v,v1);
};
quake_PF.setmodel = function() {
	var e = quake_SV.server.edicts[quake_PR.globals.ints[4]];
	var m = quake_PR.GetString(quake_PR.globals.ints[7]);
	var i = 0;
	while(i < quake_SV.server.model_precache.length) {
		if(quake_SV.server.model_precache[i] == m) {
			break;
		}
		++i;
	}
	if(i == quake_SV.server.model_precache.length) {
		quake_PR.RunError("no precache: " + m + "\n");
	}
	e.v.ints[29] = quake_PR.globals.ints[7];
	e.v.floats[0] = i;
	var mod = quake_SV.server.models[i];
	if(mod != null) {
		quake_PF.SetMinMaxSize(e,mod.mins,mod.maxs);
	} else {
		quake_PF.SetMinMaxSize(e,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin);
	}
};
quake_PF.bprint = function() {
	quake_Host.BroadcastPrint(quake_PF.VarString(0));
};
quake_PF.sprint = function() {
	var entnum = quake_PR.globals.ints[4];
	if(entnum <= 0 || entnum > quake_SV.svs.maxclients) {
		quake_Console.Print("tried to sprint to a non-client\n");
		return;
	}
	var client = quake_SV.svs.clients[entnum - 1];
	client.message.WriteByte(8);
	client.message.WriteString(quake_PF.VarString(1));
};
quake_PF.centerprint = function() {
	var entnum = quake_PR.globals.ints[4];
	if(entnum <= 0 || entnum > quake_SV.svs.maxclients) {
		quake_Console.Print("tried to sprint to a non-client\n");
		return;
	}
	var client = quake_SV.svs.clients[entnum - 1];
	client.message.WriteByte(26);
	client.message.WriteString(quake_PF.VarString(1));
};
quake_PF.normalize = function() {
	var _this = quake_PR.globals;
	var x = _this.floats[4];
	var y = _this.floats[5];
	var z = _this.floats[6];
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	quake__$Vec_Vec_$Impl_$.Normalize(v);
	var _this1 = quake_PR.globals;
	_this1.floats[1] = v[0];
	_this1.floats[2] = v[1];
	_this1.floats[3] = v[2];
};
quake_PF.vlen = function() {
	quake_PR.globals.floats[1] = Math.sqrt(quake_PR.globals.floats[4] * quake_PR.globals.floats[4] + quake_PR.globals.floats[5] * quake_PR.globals.floats[5] + quake_PR.globals.floats[6] * quake_PR.globals.floats[6]);
};
quake_PF.vectoyaw = function() {
	var value1 = quake_PR.globals.floats[4];
	var value2 = quake_PR.globals.floats[5];
	if(value1 == 0.0 && value2 == 0.0) {
		quake_PR.globals.floats[1] = 0.0;
		return;
	}
	var yaw = Math.atan2(value2,value1) * 180.0 / Math.PI | 0;
	if(yaw < 0) {
		yaw += 360;
	}
	quake_PR.globals.floats[1] = yaw;
};
quake_PF.vectoangles = function() {
	quake_PR.globals.floats[3] = 0.0;
	var value1_0 = quake_PR.globals.floats[4];
	var value1_1 = quake_PR.globals.floats[5];
	var value1_2 = quake_PR.globals.floats[6];
	if(value1_0 == 0.0 && value1_1 == 0.0) {
		if(value1_2 > 0.0) {
			quake_PR.globals.floats[1] = 90.0;
		} else {
			quake_PR.globals.floats[1] = 270.0;
		}
		quake_PR.globals.floats[2] = 0.0;
		return;
	}
	var yaw = Math.atan2(value1_1,value1_0) * 180.0 / Math.PI | 0;
	if(yaw < 0) {
		yaw += 360;
	}
	var pitch = Math.atan2(value1_2,Math.sqrt(value1_0 * value1_0 + value1_1 * value1_1)) * 180.0 / Math.PI | 0;
	if(pitch < 0) {
		pitch += 360;
	}
	quake_PR.globals.floats[1] = pitch;
	quake_PR.globals.floats[2] = yaw;
};
quake_PF.random = function() {
	var _this = quake_PR.globals;
	var f = Math.random();
	_this.floats[1] = f;
};
quake_PF.particle = function() {
	var _this = quake_PR.globals;
	var x = _this.floats[4];
	var y = _this.floats[5];
	var z = _this.floats[6];
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var _this1 = quake_PR.globals;
	var x1 = _this1.floats[7];
	var y1 = _this1.floats[8];
	var z1 = _this1.floats[9];
	var v1 = new Float32Array(3);
	v1[0] = x1;
	v1[1] = y1;
	v1[2] = z1;
	quake_SV.StartParticle(v,v1,quake_PR.globals.floats[10] | 0,quake_PR.globals.floats[13] | 0);
};
quake_PF.ambientsound = function() {
	var samp = quake_PR.GetString(quake_PR.globals.ints[7]);
	var i = 0;
	while(i < quake_SV.server.sound_precache.length) {
		if(quake_SV.server.sound_precache[i] == samp) {
			break;
		}
		++i;
	}
	if(i == quake_SV.server.sound_precache.length) {
		quake_Console.Print("no precache: " + samp + "\n");
		return;
	}
	var signon = quake_SV.server.signon;
	signon.WriteByte(29);
	signon.WriteShort(quake_PR.globals.floats[4] * 8 | 0);
	signon.WriteShort(quake_PR.globals.floats[5] * 8 | 0);
	signon.WriteShort(quake_PR.globals.floats[6] * 8 | 0);
	signon.WriteByte(i);
	signon.WriteByte(quake_PR.globals.floats[10] * 255 | 0);
	signon.WriteByte(quake_PR.globals.floats[13] * 64 | 0);
};
quake_PF.sound = function() {
	quake_SV.StartSound(quake_SV.server.edicts[quake_PR.globals.ints[4]],quake_PR.globals.floats[7] | 0,quake_PR.GetString(quake_PR.globals.ints[10]),quake_PR.globals.floats[13] * 255 | 0,quake_PR.globals.floats[16]);
};
quake_PF.breakstatement = function() {
	quake_Console.Print("break statement\n");
};
quake_PF.traceline = function() {
	var x = quake_PR.globals.floats[4];
	var y = quake_PR.globals.floats[5];
	var z = quake_PR.globals.floats[6];
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var trace = quake__$Vec_Vec_$Impl_$.origin;
	var trace1 = quake__$Vec_Vec_$Impl_$.origin;
	var x1 = quake_PR.globals.floats[7];
	var y1 = quake_PR.globals.floats[8];
	var z1 = quake_PR.globals.floats[9];
	var v1 = new Float32Array(3);
	v1[0] = x1;
	v1[1] = y1;
	v1[2] = z1;
	var trace2 = quake_SV.Move(v,trace,trace1,v1,quake_PR.globals.floats[10] | 0,quake_SV.server.edicts[quake_PR.globals.ints[13]]);
	quake_PR.globals.floats[68] = trace2.allsolid ? 1.0 : 0.0;
	quake_PR.globals.floats[69] = trace2.startsolid ? 1.0 : 0.0;
	quake_PR.globals.floats[70] = trace2.fraction;
	quake_PR.globals.floats[80] = trace2.inwater ? 1.0 : 0.0;
	quake_PR.globals.floats[79] = trace2.inopen ? 1.0 : 0.0;
	quake_PR.globals.trace_endpos.set(trace2.endpos);
	var plane = trace2.plane;
	quake_PR.globals.trace_plane_normal.set(plane.normal);
	quake_PR.globals.floats[77] = plane.dist;
	quake_PR.globals.ints[78] = trace2.ent != null ? trace2.ent.num : 0;
};
quake_PF.newcheckclient = function(check) {
	if(check <= 0) {
		check = 1;
	} else if(check > quake_SV.svs.maxclients) {
		check = quake_SV.svs.maxclients;
	}
	var i = 1;
	if(check != quake_SV.svs.maxclients) {
		i = 1 + check;
	}
	var ent = null;
	while(true) {
		if(i == quake_SV.svs.maxclients + 1) {
			i = 1;
		}
		ent = quake_SV.server.edicts[i];
		if(i == check) {
			break;
		}
		if(ent.free) {
			++i;
			continue;
		}
		if(ent.v.floats[48] <= 0.0 || ((ent.v.floats[76] | 0) & 128) != 0) {
			++i;
			continue;
		}
		break;
	}
	var v1 = ent.v.origin;
	var v2 = ent.v.view_ofs;
	var v = new Float32Array(3);
	v[0] = v1[0] + v2[0];
	v[1] = v1[1] + v2[1];
	v[2] = v1[2] + v2[2];
	quake_PF.checkpvs = quake_Mod_$Brush.LeafPVS(quake_Mod_$Brush.PointInLeaf(v,quake_SV.server.worldmodel),quake_SV.server.worldmodel);
	return i;
};
quake_PF.checkclient = function() {
	if(quake_SV.server.time - quake_SV.server.lastchecktime >= 0.1) {
		quake_SV.server.lastcheck = quake_PF.newcheckclient(quake_SV.server.lastcheck);
		quake_SV.server.lastchecktime = quake_SV.server.time;
	}
	var ent = quake_SV.server.edicts[quake_SV.server.lastcheck];
	if(ent.free || ent.v.floats[48] <= 0.0) {
		quake_PR.globals.ints[1] = 0;
		return;
	}
	var self = quake_SV.server.edicts[quake_PR.globals.ints[28]];
	var v1 = self.v.origin;
	var v2 = self.v.view_ofs;
	var v = new Float32Array(3);
	v[0] = v1[0] + v2[0];
	v[1] = v1[1] + v2[1];
	v[2] = v1[2] + v2[2];
	var l = quake_Mod_$Brush.PointInLeaf(v,quake_SV.server.worldmodel).num - 1;
	if(l < 0 || (quake_PF.checkpvs[l >> 3] & 1 << (l & 7)) == 0) {
		quake_PR.globals.ints[1] = 0;
		return;
	}
	quake_PR.globals.ints[1] = ent.num;
};
quake_PF.stuffcmd = function() {
	var entnum = quake_PR.globals.ints[4];
	if(entnum <= 0 || entnum > quake_SV.svs.maxclients) {
		quake_PR.RunError("Parm 0 not a client");
	}
	var client = quake_SV.svs.clients[entnum - 1];
	client.message.WriteByte(9);
	client.message.WriteString(quake_PR.GetString(quake_PR.globals.ints[7]));
};
quake_PF.localcmd = function() {
	quake_Cmd.text += quake_PR.GetString(quake_PR.globals.ints[4]);
};
quake_PF.cvar = function() {
	var name = quake_PR.GetString(quake_PR.globals.ints[4]);
	var _this = quake_Cvar.vars;
	var v = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
	quake_PR.globals.floats[1] = v != null ? v.value : 0.0;
};
quake_PF.cvar_set = function() {
	quake_Cvar.Set(quake_PR.GetString(quake_PR.globals.ints[4]),quake_PR.GetString(quake_PR.globals.ints[7]));
};
quake_PF.findradius = function() {
	var chain = 0;
	var org_0 = quake_PR.globals.floats[4];
	var org_1 = quake_PR.globals.floats[5];
	var org_2 = quake_PR.globals.floats[6];
	var eorg = [];
	var rad = quake_PR.globals.floats[7];
	var _g = 1;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var i = _g++;
		var ent = quake_SV.server.edicts[i];
		if(ent.free) {
			continue;
		}
		if(ent.v.floats[9] == 0) {
			continue;
		}
		eorg[0] = org_0 - (ent.v.origin[0] + (ent.v.mins[0] + ent.v.maxs[0]) * 0.5);
		eorg[1] = org_1 - (ent.v.origin[1] + (ent.v.mins[1] + ent.v.maxs[1]) * 0.5);
		eorg[2] = org_2 - (ent.v.origin[2] + (ent.v.mins[2] + ent.v.maxs[2]) * 0.5);
		if(Math.sqrt(eorg[0] * eorg[0] + eorg[1] * eorg[1] + eorg[2] * eorg[2]) > rad) {
			continue;
		}
		ent.v.ints[60] = chain;
		chain = i;
	}
	quake_PR.globals.ints[1] = chain;
};
quake_PF.dprint = function() {
	quake_Console.DPrint(quake_PF.VarString(0));
};
quake_PF.ftos = function() {
	var v = quake_PR.globals.floats[4];
	if(v == Math.floor(v)) {
		quake_PR.TempString(v == null ? "null" : "" + v);
	} else {
		quake_PR.TempString(v.toFixed(1));
	}
	quake_PR.globals.ints[1] = quake_PR.string_temp;
};
quake_PF.fabs = function() {
	quake_PR.globals.floats[1] = Math.abs(quake_PR.globals.floats[4]);
};
quake_PF.vtos = function() {
	quake_PR.TempString(quake_PR.globals.floats[4].toFixed(1) + " " + quake_PR.globals.floats[5].toFixed(1) + " " + quake_PR.globals.floats[6].toFixed(1));
	quake_PR.globals.ints[1] = quake_PR.string_temp;
};
quake_PF.Spawn = function() {
	var _this = quake_PR.globals;
	var i = quake_ED.Alloc().num;
	_this.ints[1] = i;
};
quake_PF.Remove = function() {
	quake_ED.Free(quake_SV.server.edicts[quake_PR.globals.ints[4]]);
};
quake_PF.Find = function() {
	var f = quake_PR.globals.ints[7];
	var s = quake_PR.GetString(quake_PR.globals.ints[10]);
	var _g = quake_PR.globals.ints[4] + 1;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var ed = quake_SV.server.edicts[_g++];
		if(ed.free) {
			continue;
		}
		if(quake_PR.GetString(ed.v.ints[f]) == s) {
			quake_PR.globals.ints[1] = ed.num;
			return;
		}
	}
	quake_PR.globals.ints[1] = 0;
};
quake_PF.MoveToGoal = function() {
	var ent = quake_SV.server.edicts[quake_PR.globals.ints[28]];
	if(((ent.v.floats[76] | 0) & 512 + 1 + 2) == 0) {
		quake_PR.globals.floats[1] = 0.0;
		return;
	}
	var goal = quake_SV.server.edicts[ent.v.ints[88]];
	var dist = quake_PR.globals.floats[4];
	if(ent.v.ints[75] != 0 && quake_SV.CloseEnough(ent,goal,dist)) {
		return;
	}
	if(Math.random() >= 0.75 || !quake_SV.StepDirection(ent,ent.v.floats[85],dist)) {
		quake_SV.NewChaseDir(ent,goal,dist);
	}
};
quake_PF.precache_file = function() {
	quake_PR.globals.ints[1] = quake_PR.globals.ints[4];
};
quake_PF.precache_sound = function() {
	var s = quake_PR.GetString(quake_PR.globals.ints[4]);
	quake_PR.globals.ints[1] = quake_PR.globals.ints[4];
	quake_PR.CheckEmptyString(s);
	var i = 0;
	while(i < quake_SV.server.sound_precache.length) {
		if(quake_SV.server.sound_precache[i] == s) {
			return;
		}
		++i;
	}
	quake_SV.server.sound_precache[i] = s;
};
quake_PF.precache_model = function() {
	if(!quake_SV.server.loading) {
		quake_PR.RunError("Precache_*: Precache can only be done in spawn functions");
	}
	var s = quake_PR.GetString(quake_PR.globals.ints[4]);
	quake_PR.globals.ints[1] = quake_PR.globals.ints[4];
	quake_PR.CheckEmptyString(s);
	var i = 0;
	while(i < quake_SV.server.model_precache.length) {
		if(quake_SV.server.model_precache[i] == s) {
			return;
		}
		++i;
	}
	quake_SV.server.model_precache[i] = s;
	quake_SV.server.models[i] = quake_Mod.LoadModel(quake_Mod.FindName(s),true);
};
quake_PF.coredump = function() {
	quake_ED.PrintEdicts();
};
quake_PF.traceon = function() {
	quake_PR.trace = true;
};
quake_PF.traceoff = function() {
	quake_PR.trace = false;
};
quake_PF.eprint = function() {
	quake_ED.Print(quake_SV.server.edicts[quake_PR.globals.floats[4] | 0]);
};
quake_PF.walkmove = function() {
	var ent = quake_SV.server.edicts[quake_PR.globals.ints[28]];
	if(((ent.v.floats[76] | 0) & 512 + 1 + 2) == 0) {
		quake_PR.globals.floats[1] = 0.0;
		return;
	}
	var yaw = quake_PR.globals.floats[4] * Math.PI / 180.0;
	var dist = quake_PR.globals.floats[7];
	var oldf = quake_PR.xfunction;
	var x = Math.cos(yaw) * dist;
	var y = Math.sin(yaw) * dist;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = 0;
	var tmp = quake_SV.movestep(ent,v,true) ? 1 : 0;
	quake_PR.globals.floats[1] = tmp;
	quake_PR.xfunction = oldf;
	quake_PR.globals.ints[28] = ent.num;
};
quake_PF.droptofloor = function() {
	var ent = quake_SV.server.edicts[quake_PR.globals.ints[28]];
	var trace = new Float32Array(ent.v.origin);
	var trace1 = new Float32Array(ent.v.mins);
	var trace2 = new Float32Array(ent.v.maxs);
	var x = ent.v.origin[0];
	var y = ent.v.origin[1];
	var z = ent.v.origin[2] - 256.0;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var trace3 = quake_SV.Move(trace,trace1,trace2,v,0,ent);
	if(trace3.fraction == 1.0 || trace3.allsolid) {
		quake_PR.globals.floats[1] = 0.0;
		return;
	}
	ent.v.origin.set(trace3.endpos);
	quake_SV.LinkEdict(ent,false);
	ent.v.floats[76] = ent.v.floats[76] | 0 | 512;
	ent.v.ints[47] = trace3.ent.num;
	quake_PR.globals.floats[1] = 1.0;
};
quake_PF.lightstyle = function() {
	var style = quake_PR.globals.floats[4] | 0;
	var val = quake_PR.GetString(quake_PR.globals.ints[7]);
	quake_SV.server.lightstyles[style] = val;
	if(quake_SV.server.loading) {
		return;
	}
	var _g = 0;
	var _g1 = quake_SV.svs.maxclients;
	while(_g < _g1) {
		var client = quake_SV.svs.clients[_g++];
		if(!client.active && !client.spawned) {
			continue;
		}
		client.message.WriteByte(12);
		client.message.WriteByte(style);
		client.message.WriteString(val);
	}
};
quake_PF.rint = function() {
	var f = quake_PR.globals.floats[4];
	quake_PR.globals.floats[1] = (f >= 0.0 ? f + 0.5 : f - 0.5) | 0;
};
quake_PF.floor = function() {
	quake_PR.globals.floats[1] = Math.floor(quake_PR.globals.floats[4]);
};
quake_PF.ceil = function() {
	quake_PR.globals.floats[1] = Math.ceil(quake_PR.globals.floats[4]);
};
quake_PF.checkbottom = function() {
	var tmp = quake_SV.CheckBottom(quake_SV.server.edicts[quake_PR.globals.ints[4]]) ? 1 : 0;
	quake_PR.globals.floats[1] = tmp;
};
quake_PF.pointcontents = function() {
	var tmp = quake_PR.globals.floats;
	var x = quake_PR.globals.floats[4];
	var y = quake_PR.globals.floats[5];
	var z = quake_PR.globals.floats[6];
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	tmp[1] = quake_SV.PointContents(v);
};
quake_PF.nextent = function() {
	var _g = quake_PR.globals.ints[4] + 1;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var i = _g++;
		if(!quake_SV.server.edicts[i].free) {
			quake_PR.globals.ints[1] = i;
			return;
		}
	}
	quake_PR.globals.ints[1] = 0;
};
quake_PF.aim = function() {
	var ent = quake_SV.server.edicts[quake_PR.globals.ints[4]];
	var x = ent.v.origin[0];
	var y = ent.v.origin[1];
	var z = ent.v.origin[2] + 20.0;
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	var dir = new Float32Array(quake_PR.globals.v_forward);
	var v1 = new Float32Array(3);
	v1[0] = v[0] + 2048.0 * dir[0];
	v1[1] = v[1] + 2048.0 * dir[1];
	v1[2] = v[2] + 2048.0 * dir[2];
	var tr = quake_SV.Move(v,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,v1,0,ent);
	if(tr.ent != null) {
		if(tr.ent.v.floats[59] == 2 && (quake_Host.teamplay.value == 0 || ent.v.floats[78] <= 0 || ent.v.floats[78] != tr.ent.v.floats[78])) {
			var _this = quake_PR.globals;
			_this.floats[1] = dir[0];
			_this.floats[2] = dir[1];
			_this.floats[3] = dir[2];
			return;
		}
	}
	var bestdir = new Float32Array(dir);
	var bestdist = quake_SV.aim.value;
	var bestent = null;
	var end = new Float32Array(3);
	var _g = 1;
	var _g1 = quake_SV.server.num_edicts;
	while(_g < _g1) {
		var check = quake_SV.server.edicts[_g++];
		if(check.v.floats[59] != 2) {
			continue;
		}
		if(check == ent) {
			continue;
		}
		if(quake_Host.teamplay.value != 0 && ent.v.floats[78] > 0 && ent.v.floats[78] == check.v.floats[78]) {
			continue;
		}
		end[0] = check.v.origin[0] + 0.5 * (check.v.mins[0] + check.v.maxs[0]);
		end[1] = check.v.origin[1] + 0.5 * (check.v.mins[1] + check.v.maxs[1]);
		end[2] = check.v.origin[2] + 0.5 * (check.v.mins[2] + check.v.maxs[2]);
		dir[0] = end[0] - v[0];
		dir[1] = end[1] - v[1];
		dir[2] = end[2] - v[2];
		quake__$Vec_Vec_$Impl_$.Normalize(dir);
		var dist = dir[0] * bestdir[0] + dir[1] * bestdir[1] + dir[2] * bestdir[2];
		if(dist < bestdist) {
			continue;
		}
		tr = quake_SV.Move(v,quake__$Vec_Vec_$Impl_$.origin,quake__$Vec_Vec_$Impl_$.origin,end,0,ent);
		if(tr.ent == check) {
			bestdist = dist;
			bestent = check;
		}
	}
	if(bestent != null) {
		dir[0] = bestent.v.origin[0] - ent.v.origin[0];
		dir[1] = bestent.v.origin[1] - ent.v.origin[1];
		dir[2] = bestent.v.origin[2] - ent.v.origin[2];
		var dist1 = dir[0] * bestdir[0] + dir[1] * bestdir[1] + dir[2] * bestdir[2];
		end[0] = bestdir[0] * dist1;
		end[1] = bestdir[1] * dist1;
		end[2] = dir[2];
		quake__$Vec_Vec_$Impl_$.Normalize(end);
		var _this1 = quake_PR.globals;
		_this1.floats[1] = end[0];
		_this1.floats[2] = end[1];
		_this1.floats[3] = end[2];
		return;
	}
	var _this2 = quake_PR.globals;
	_this2.floats[1] = bestdir[0];
	_this2.floats[2] = bestdir[1];
	_this2.floats[3] = bestdir[2];
};
quake_PF.changeyaw = function() {
	var ent = quake_SV.server.edicts[quake_PR.globals.ints[28]];
	var current = quake__$Vec_Vec_$Impl_$.Anglemod(ent.v.angles[1]);
	var ideal = ent.v.floats[85];
	if(current == ideal) {
		return;
	}
	var move = ideal - current;
	if(ideal > current) {
		if(move >= 180.0) {
			move -= 360.0;
		}
	} else if(move <= -180.0) {
		move += 360.0;
	}
	var speed = ent.v.floats[86];
	if(move > 0.0) {
		if(move > speed) {
			move = speed;
		}
	} else if(move < -speed) {
		move = -speed;
	}
	ent.v.angles[1] = quake__$Vec_Vec_$Impl_$.Anglemod(current + move);
};
quake_PF.WriteDest = function() {
	switch(quake_PR.globals.floats[4] | 0) {
	case 0:
		return quake_SV.server.datagram;
	case 1:
		var entnum = quake_PR.globals.ints[81];
		if(entnum <= 0 || entnum > quake_SV.svs.maxclients) {
			quake_PR.RunError("WriteDest: not a client");
		}
		return quake_SV.svs.clients[entnum - 1].message;
	case 2:
		return quake_SV.server.reliable_datagram;
	case 3:
		return quake_SV.server.signon;
	default:
		quake_PR.RunError("WriteDest: bad destination");
		return null;
	}
};
quake_PF.WriteByte = function() {
	quake_PF.WriteDest().WriteByte(quake_PR.globals.floats[7] | 0);
};
quake_PF.WriteChar = function() {
	quake_PF.WriteDest().WriteChar(quake_PR.globals.floats[7] | 0);
};
quake_PF.WriteShort = function() {
	quake_PF.WriteDest().WriteShort(quake_PR.globals.floats[7] | 0);
};
quake_PF.WriteLong = function() {
	quake_PF.WriteDest().WriteLong(quake_PR.globals.floats[7] | 0);
};
quake_PF.WriteAngle = function() {
	quake_PF.WriteDest().WriteByte((quake_PR.globals.floats[7] * 256 / 360 | 0) & 255);
};
quake_PF.WriteCoord = function() {
	quake_PF.WriteDest().WriteShort(quake_PR.globals.floats[7] * 8 | 0);
};
quake_PF.WriteString = function() {
	quake_PF.WriteDest().WriteString(quake_PR.GetString(quake_PR.globals.ints[7]));
};
quake_PF.WriteEntity = function() {
	quake_PF.WriteDest().WriteShort(quake_PR.globals.ints[7]);
};
quake_PF.makestatic = function() {
	var ent = quake_SV.server.edicts[quake_PR.globals.ints[4]];
	var message = quake_SV.server.signon;
	message.WriteByte(20);
	message.WriteByte(quake_SV.ModelIndex(quake_PR.GetString(ent.v.ints[29])));
	message.WriteByte(ent.v.floats[30] | 0);
	message.WriteByte(ent.v.floats[77] | 0);
	message.WriteByte(ent.v.floats[31] | 0);
	message.WriteShort(ent.v.origin[0] * 8 | 0);
	message.WriteByte((ent.v.angles[0] * 256 / 360 | 0) & 255);
	message.WriteShort(ent.v.origin[1] * 8 | 0);
	message.WriteByte((ent.v.angles[1] * 256 / 360 | 0) & 255);
	message.WriteShort(ent.v.origin[2] * 8 | 0);
	message.WriteByte((ent.v.angles[2] * 256 / 360 | 0) & 255);
	quake_ED.Free(ent);
};
quake_PF.setspawnparms = function() {
	var i = quake_PR.globals.ints[4];
	if(i <= 0 || i > quake_SV.svs.maxclients) {
		quake_PR.RunError("Entity is not a client");
	}
	var _this = quake_PR.globals;
	var values = quake_SV.svs.clients[i - 1].spawn_parms;
	_this.floats[43] = values[0];
	_this.floats[44] = values[1];
	_this.floats[45] = values[2];
	_this.floats[46] = values[3];
	_this.floats[47] = values[4];
	_this.floats[48] = values[5];
	_this.floats[49] = values[6];
	_this.floats[50] = values[7];
	_this.floats[51] = values[8];
	_this.floats[52] = values[9];
	_this.floats[53] = values[10];
	_this.floats[54] = values[11];
	_this.floats[55] = values[12];
	_this.floats[56] = values[13];
	_this.floats[57] = values[14];
	_this.floats[58] = values[15];
};
quake_PF.changelevel = function() {
	if(quake_SV.svs.changelevel_issued) {
		return;
	}
	quake_SV.svs.changelevel_issued = true;
	quake_Cmd.text += "changelevel " + quake_PR.GetString(quake_PR.globals.ints[4]) + "\n";
};
quake_PF.Fixme = function() {
	quake_PR.RunError("unimplemented builtin");
};
var quake_PRDef = function(view,ofs) {
	this.type = view.getUint16(ofs,true);
	this.ofs = view.getUint16(ofs + 2,true);
	this.name = view.getUint32(ofs + 4,true);
};
quake_PRDef.__name__ = true;
var quake__$PR_PRFunction = function(view,ofs) {
	this.first_statement = view.getInt32(ofs,true);
	this.parm_start = view.getUint32(ofs + 4,true);
	this.locals = view.getUint32(ofs + 8,true);
	this.profile = view.getUint32(ofs + 12,true);
	this.name = view.getUint32(ofs + 16,true);
	this.file = view.getUint32(ofs + 20,true);
	this.numparms = view.getUint32(ofs + 24,true);
	this.parm_size = [view.getUint8(ofs + 28),view.getUint8(ofs + 29),view.getUint8(ofs + 30),view.getUint8(ofs + 31),view.getUint8(ofs + 32),view.getUint8(ofs + 33),view.getUint8(ofs + 34),view.getUint8(ofs + 35)];
};
quake__$PR_PRFunction.__name__ = true;
var quake__$PR_PRStatement = function(view,ofs) {
	this.op = view.getUint16(ofs,true);
	this.a = view.getInt16(ofs + 2,true);
	this.b = view.getInt16(ofs + 4,true);
	this.c = view.getInt16(ofs + 6,true);
};
quake__$PR_PRStatement.__name__ = true;
var quake__$Render_Rect = function() {
};
quake__$Render_Rect.__name__ = true;
var quake__$Render_Particle = function() {
	this.color = 0;
	this.vel = new Float32Array(3);
	this.org = new Float32Array(3);
	this.die = -1;
	this.ramp = 0;
	this.type = 0;
};
quake__$Render_Particle.__name__ = true;
var quake_Sfx = function(n) {
	this.name = n;
};
quake_Sfx.__name__ = true;
var quake__$SV_AreaNode = function() {
};
quake__$SV_AreaNode.__name__ = true;
var quake_Sbar = function() { };
quake_Sbar.__name__ = true;
quake_Sbar.Init = function() {
	quake_Sbar.nums = [[],[]];
	quake_Sbar.nums[0][0] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 0));
	quake_Sbar.nums[1][0] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 0));
	quake_Sbar.nums[0][1] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 1));
	quake_Sbar.nums[1][1] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 1));
	quake_Sbar.nums[0][2] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 2));
	quake_Sbar.nums[1][2] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 2));
	quake_Sbar.nums[0][3] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 3));
	quake_Sbar.nums[1][3] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 3));
	quake_Sbar.nums[0][4] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 4));
	quake_Sbar.nums[1][4] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 4));
	quake_Sbar.nums[0][5] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 5));
	quake_Sbar.nums[1][5] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 5));
	quake_Sbar.nums[0][6] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 6));
	quake_Sbar.nums[1][6] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 6));
	quake_Sbar.nums[0][7] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 7));
	quake_Sbar.nums[1][7] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 7));
	quake_Sbar.nums[0][8] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 8));
	quake_Sbar.nums[1][8] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 8));
	quake_Sbar.nums[0][9] = new quake_DrawPic(quake_W.GetLumpName("NUM_" + 9));
	quake_Sbar.nums[1][9] = new quake_DrawPic(quake_W.GetLumpName("ANUM_" + 9));
	quake_Sbar.nums[0][10] = new quake_DrawPic(quake_W.GetLumpName("NUM_MINUS"));
	quake_Sbar.nums[1][10] = new quake_DrawPic(quake_W.GetLumpName("ANUM_MINUS"));
	quake_Sbar.colon = new quake_DrawPic(quake_W.GetLumpName("NUM_COLON"));
	quake_Sbar.slash = new quake_DrawPic(quake_W.GetLumpName("NUM_SLASH"));
	quake_Sbar.weapons = [[new quake_DrawPic(quake_W.GetLumpName("INV_SHOTGUN")),new quake_DrawPic(quake_W.GetLumpName("INV_SSHOTGUN")),new quake_DrawPic(quake_W.GetLumpName("INV_NAILGUN")),new quake_DrawPic(quake_W.GetLumpName("INV_SNAILGUN")),new quake_DrawPic(quake_W.GetLumpName("INV_RLAUNCH")),new quake_DrawPic(quake_W.GetLumpName("INV_SRLAUNCH")),new quake_DrawPic(quake_W.GetLumpName("INV_LIGHTNG"))],[new quake_DrawPic(quake_W.GetLumpName("INV2_SHOTGUN")),new quake_DrawPic(quake_W.GetLumpName("INV2_SSHOTGUN")),new quake_DrawPic(quake_W.GetLumpName("INV2_NAILGUN")),new quake_DrawPic(quake_W.GetLumpName("INV2_SNAILGUN")),new quake_DrawPic(quake_W.GetLumpName("INV2_RLAUNCH")),new quake_DrawPic(quake_W.GetLumpName("INV2_SRLAUNCH")),new quake_DrawPic(quake_W.GetLumpName("INV2_LIGHTNG"))]];
	var _g = 0;
	while(_g < 5) {
		var i = _g++;
		quake_Sbar.weapons.push([new quake_DrawPic(quake_W.GetLumpName("INVA" + (i + 1) + "_SHOTGUN")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i + 1) + "_SSHOTGUN")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i + 1) + "_NAILGUN")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i + 1) + "_SNAILGUN")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i + 1) + "_RLAUNCH")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i + 1) + "_SRLAUNCH")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i + 1) + "_LIGHTNG"))]);
	}
	quake_Sbar.ammo = [new quake_DrawPic(quake_W.GetLumpName("SB_SHELLS")),new quake_DrawPic(quake_W.GetLumpName("SB_NAILS")),new quake_DrawPic(quake_W.GetLumpName("SB_ROCKET")),new quake_DrawPic(quake_W.GetLumpName("SB_CELLS"))];
	quake_Sbar.armor = [new quake_DrawPic(quake_W.GetLumpName("SB_ARMOR1")),new quake_DrawPic(quake_W.GetLumpName("SB_ARMOR2")),new quake_DrawPic(quake_W.GetLumpName("SB_ARMOR3"))];
	quake_Sbar.items = [new quake_DrawPic(quake_W.GetLumpName("SB_KEY1")),new quake_DrawPic(quake_W.GetLumpName("SB_KEY2")),new quake_DrawPic(quake_W.GetLumpName("SB_INVIS")),new quake_DrawPic(quake_W.GetLumpName("SB_INVULN")),new quake_DrawPic(quake_W.GetLumpName("SB_SUIT")),new quake_DrawPic(quake_W.GetLumpName("SB_QUAD"))];
	quake_Sbar.sigil = [new quake_DrawPic(quake_W.GetLumpName("SB_SIGIL1")),new quake_DrawPic(quake_W.GetLumpName("SB_SIGIL2")),new quake_DrawPic(quake_W.GetLumpName("SB_SIGIL3")),new quake_DrawPic(quake_W.GetLumpName("SB_SIGIL4"))];
	quake_Sbar.faces = [];
	quake_Sbar.faces.push([new quake_DrawPic(quake_W.GetLumpName("FACE" + 5)),new quake_DrawPic(quake_W.GetLumpName("FACE_P" + 5))]);
	quake_Sbar.faces.push([new quake_DrawPic(quake_W.GetLumpName("FACE" + 4)),new quake_DrawPic(quake_W.GetLumpName("FACE_P" + 4))]);
	quake_Sbar.faces.push([new quake_DrawPic(quake_W.GetLumpName("FACE" + 3)),new quake_DrawPic(quake_W.GetLumpName("FACE_P" + 3))]);
	quake_Sbar.faces.push([new quake_DrawPic(quake_W.GetLumpName("FACE" + 2)),new quake_DrawPic(quake_W.GetLumpName("FACE_P" + 2))]);
	quake_Sbar.faces.push([new quake_DrawPic(quake_W.GetLumpName("FACE" + 1)),new quake_DrawPic(quake_W.GetLumpName("FACE_P" + 1))]);
	quake_Sbar.face_invis = new quake_DrawPic(quake_W.GetLumpName("FACE_INVIS"));
	quake_Sbar.face_invuln = new quake_DrawPic(quake_W.GetLumpName("FACE_INVUL2"));
	quake_Sbar.face_invis_invuln = new quake_DrawPic(quake_W.GetLumpName("FACE_INV2"));
	quake_Sbar.face_quad = new quake_DrawPic(quake_W.GetLumpName("FACE_QUAD"));
	quake_Cmd.AddCommand("+showscores",quake_Sbar.ShowScores);
	quake_Cmd.AddCommand("-showscores",quake_Sbar.DontShowScores);
	quake_Sbar.sbar = new quake_DrawPic(quake_W.GetLumpName("SBAR"));
	quake_Sbar.ibar = new quake_DrawPic(quake_W.GetLumpName("IBAR"));
	quake_Sbar.scorebar = new quake_DrawPic(quake_W.GetLumpName("SCOREBAR"));
	quake_Sbar.ranking = quake_Draw.CachePic("ranking");
	quake_Sbar.complete = quake_Draw.CachePic("complete");
	quake_Sbar.inter = quake_Draw.CachePic("inter");
	quake_Sbar.finale = quake_Draw.CachePic("finale");
	quake_Sbar.disc = new quake_DrawPic(quake_W.GetLumpName("DISC"));
	if(quake_COM.hipnotic) {
		quake_Sbar.h_weapons = [[new quake_DrawPic(quake_W.GetLumpName("INV_LASER")),new quake_DrawPic(quake_W.GetLumpName("INV_MJOLNIR")),new quake_DrawPic(quake_W.GetLumpName("INV_GREN_PROX")),new quake_DrawPic(quake_W.GetLumpName("INV_PROX_GREN")),new quake_DrawPic(quake_W.GetLumpName("INV_PROX"))],[new quake_DrawPic(quake_W.GetLumpName("INV2_LASER")),new quake_DrawPic(quake_W.GetLumpName("INV2_MJOLNIR")),new quake_DrawPic(quake_W.GetLumpName("INV2_GREN_PROX")),new quake_DrawPic(quake_W.GetLumpName("INV2_PROX_GREN")),new quake_DrawPic(quake_W.GetLumpName("INV2_PROX"))]];
		var _g1 = 0;
		while(_g1 < 5) {
			var i1 = _g1++;
			quake_Sbar.h_weapons.push([new quake_DrawPic(quake_W.GetLumpName("INVA" + (i1 + 1) + "_LASER")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i1 + 1) + "_MJOLNIR")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i1 + 1) + "_GREN_PROX")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i1 + 1) + "_PROX_GREN")),new quake_DrawPic(quake_W.GetLumpName("INVA" + (i1 + 1) + "_PROX"))]);
		}
		quake_Sbar.hipweapons = [quake_Def.hit.laser_cannon_bit,quake_Def.hit.mjolnir_bit,4,quake_Def.hit.proximity_gun_bit];
		quake_Sbar.h_items = [new quake_DrawPic(quake_W.GetLumpName("SB_WSUIT")),new quake_DrawPic(quake_W.GetLumpName("SB_ESHLD"))];
	}
	if(quake_COM.rogue) {
		quake_Sbar.r_invbar = [new quake_DrawPic(quake_W.GetLumpName("R_INVBAR1")),new quake_DrawPic(quake_W.GetLumpName("R_INVBAR2"))];
		quake_Sbar.r_weapons = [new quake_DrawPic(quake_W.GetLumpName("R_LAVA")),new quake_DrawPic(quake_W.GetLumpName("R_SUPERLAVA")),new quake_DrawPic(quake_W.GetLumpName("R_GREN")),new quake_DrawPic(quake_W.GetLumpName("R_MULTIROCK")),new quake_DrawPic(quake_W.GetLumpName("R_PLASMA"))];
		quake_Sbar.r_items = [new quake_DrawPic(quake_W.GetLumpName("R_SHIELD1")),new quake_DrawPic(quake_W.GetLumpName("R_AGRAV1"))];
		quake_Sbar.r_teambord = new quake_DrawPic(quake_W.GetLumpName("R_TEAMBORD"));
		quake_Sbar.r_ammo = [new quake_DrawPic(quake_W.GetLumpName("R_AMMOLAVA")),new quake_DrawPic(quake_W.GetLumpName("R_AMMOMULTI")),new quake_DrawPic(quake_W.GetLumpName("R_AMMOPLASMA"))];
	}
};
quake_Sbar.ShowScores = function() {
	quake_Sbar.showscores = true;
};
quake_Sbar.DontShowScores = function() {
	quake_Sbar.showscores = false;
};
quake_Sbar.DrawPic = function(x,y,pic) {
	if(quake_CL.state.gametype == 1) {
		quake_Draw.Pic(x,y + quake_VID.height - 24,pic);
	} else {
		quake_Draw.Pic(x + (quake_VID.width >> 1) - 160,y + quake_VID.height - 24,pic);
	}
};
quake_Sbar.DrawCharacter = function(x,y,num) {
	if(quake_CL.state.gametype == 1) {
		quake_Draw.Character(x + 4,y + quake_VID.height - 24,num);
	} else {
		quake_Draw.Character(x + (quake_VID.width >> 1) - 156,y + quake_VID.height - 24,num);
	}
};
quake_Sbar.DrawString = function(x,y,str) {
	if(quake_CL.state.gametype == 1) {
		quake_Draw.String(x,y + quake_VID.height - 24,str);
	} else {
		quake_Draw.String(x + (quake_VID.width >> 1) - 160,y + quake_VID.height - 24,str);
	}
};
quake_Sbar.DrawNum = function(x,y,num,digits,color) {
	var str = num == null ? "null" : "" + num;
	if(str.length > digits) {
		str = str.substring(str.length - digits,str.length);
	} else if(str.length < digits) {
		x += (digits - str.length) * 24;
	}
	var _g = 0;
	var _g1 = str.length;
	while(_g < _g1) {
		var frame = HxOverrides.cca(str,_g++);
		quake_Sbar.DrawPic(x,y,quake_Sbar.nums[color][frame == 45 ? 10 : frame - 48]);
		x += 24;
	}
};
quake_Sbar.SortFrags = function() {
	quake_Sbar.scoreboardlines = 0;
	var _g = 0;
	var _g1 = quake_CL.state.maxclients;
	while(_g < _g1) {
		var i = _g++;
		if(quake_CL.state.scores[i].name.length != 0) {
			quake_Sbar.fragsort[quake_Sbar.scoreboardlines++] = i;
		}
	}
	var _g2 = 0;
	var _g3 = quake_Sbar.scoreboardlines;
	while(_g2 < _g3) {
		var _g21 = 0;
		var _g31 = quake_Sbar.scoreboardlines - 1 - _g2++;
		while(_g21 < _g31) {
			var j = _g21++;
			if(quake_CL.state.scores[quake_Sbar.fragsort[j]].frags < quake_CL.state.scores[quake_Sbar.fragsort[j + 1]].frags) {
				var k = quake_Sbar.fragsort[j];
				quake_Sbar.fragsort[j] = quake_Sbar.fragsort[j + 1];
				quake_Sbar.fragsort[j + 1] = k;
			}
		}
	}
};
quake_Sbar.SoloScoreboard = function() {
	quake_Sbar.DrawString(8,4,"Monsters:    /");
	var str = Std.string(quake_CL.state.stats[14]);
	quake_Sbar.DrawString(104 - (str.length << 3),4,str);
	str = Std.string(quake_CL.state.stats[12]);
	quake_Sbar.DrawString(144 - (str.length << 3),4,str);
	quake_Sbar.DrawString(8,12,"Secrets :    /");
	str = Std.string(quake_CL.state.stats[13]);
	quake_Sbar.DrawString(104 - (str.length << 3),12,str);
	str = Std.string(quake_CL.state.stats[11]);
	quake_Sbar.DrawString(144 - (str.length << 3),12,str);
	var minutes = Math.floor(quake_CL.state.time / 60.0);
	var seconds = Math.floor(quake_CL.state.time - 60 * minutes);
	var tens = Math.floor(seconds / 10.0);
	str = Std.string(seconds - 10 * tens);
	quake_Sbar.DrawString(184,4,"Time :   :" + tens + str);
	str = minutes == null ? "null" : "" + minutes;
	quake_Sbar.DrawString(256 - (str.length << 3),4,str);
	quake_Sbar.DrawString(232 - (quake_CL.state.levelname.length << 2),12,quake_CL.state.levelname);
};
quake_Sbar.DrawInventory = function() {
	if(quake_COM.rogue) {
		quake_Sbar.DrawPic(0,-24,quake_Sbar.r_invbar[quake_CL.state.stats[10] >= quake_Def.rit.lava_nailgun ? 0 : 1]);
	} else {
		quake_Sbar.DrawPic(0,-24,quake_Sbar.ibar);
	}
	var flashon;
	var _g = 0;
	while(_g < 7) {
		var i = _g++;
		if((quake_CL.state.items & quake_Def.it.shotgun << i) == 0) {
			continue;
		}
		flashon = Math.floor((quake_CL.state.time - quake_CL.state.item_gettime[i]) * 10.0);
		if(flashon >= 10) {
			flashon = quake_CL.state.stats[10] == quake_Def.it.shotgun << i ? 1 : 0;
		} else {
			flashon = flashon % 5 + 2;
		}
		quake_Sbar.DrawPic(i * 24,-16,quake_Sbar.weapons[flashon][i]);
	}
	if(quake_COM.hipnotic) {
		var grenadeflashing = false;
		var _g1 = 0;
		while(_g1 < 4) {
			var i1 = _g1++;
			if((quake_CL.state.items & 1 << quake_Sbar.hipweapons[i1]) != 0) {
				flashon = Math.floor((quake_CL.state.time - quake_CL.state.item_gettime[i1]) * 10.0);
				if(flashon >= 10) {
					flashon = quake_CL.state.stats[10] == 1 << quake_Sbar.hipweapons[i1] ? 1 : 0;
				} else {
					flashon = flashon % 5 + 2;
				}
				if(i1 == 2) {
					if((quake_CL.state.items & quake_Def.hit.proximity_gun) != 0 && flashon != 0) {
						grenadeflashing = true;
						quake_Sbar.DrawPic(96,-16,quake_Sbar.h_weapons[flashon][2]);
					}
				} else if(i1 == 3) {
					if((quake_CL.state.items & quake_Def.it.grenade_launcher) != 0) {
						if(!grenadeflashing) {
							quake_Sbar.DrawPic(96,-16,quake_Sbar.h_weapons[flashon][3]);
						}
					} else {
						quake_Sbar.DrawPic(96,-16,quake_Sbar.h_weapons[flashon][4]);
					}
				} else {
					quake_Sbar.DrawPic(176 + i1 * 24,-16,quake_Sbar.h_weapons[flashon][i1]);
				}
			}
		}
	} else if(quake_COM.rogue) {
		if(quake_CL.state.stats[10] >= quake_Def.rit.lava_nailgun) {
			if(quake_CL.state.stats[10] == quake_Def.rit.lava_nailgun) {
				quake_Sbar.DrawPic(48,-16,quake_Sbar.r_weapons[0]);
			}
			if(quake_CL.state.stats[10] == quake_Def.rit.lava_nailgun << 1) {
				quake_Sbar.DrawPic(72,-16,quake_Sbar.r_weapons[1]);
			}
			if(quake_CL.state.stats[10] == quake_Def.rit.lava_nailgun << 2) {
				quake_Sbar.DrawPic(96,-16,quake_Sbar.r_weapons[2]);
			}
			if(quake_CL.state.stats[10] == quake_Def.rit.lava_nailgun << 3) {
				quake_Sbar.DrawPic(120,-16,quake_Sbar.r_weapons[3]);
			}
			if(quake_CL.state.stats[10] == quake_Def.rit.lava_nailgun << 4) {
				quake_Sbar.DrawPic(144,-16,quake_Sbar.r_weapons[4]);
			}
		}
	}
	var _g11 = 0;
	while(_g11 < 4) {
		var i2 = _g11++;
		var num = Std.string(quake_CL.state.stats[6 + i2]);
		switch(num.length) {
		case 1:
			quake_Sbar.DrawCharacter((6 * i2 + 3 << 3) - 2,-24,HxOverrides.cca(num,0) - 30);
			continue;
		case 2:
			quake_Sbar.DrawCharacter((6 * i2 + 2 << 3) - 2,-24,HxOverrides.cca(num,0) - 30);
			quake_Sbar.DrawCharacter((6 * i2 + 3 << 3) - 2,-24,HxOverrides.cca(num,1) - 30);
			continue;
		case 3:
			quake_Sbar.DrawCharacter((6 * i2 + 1 << 3) - 2,-24,HxOverrides.cca(num,0) - 30);
			quake_Sbar.DrawCharacter((6 * i2 + 2 << 3) - 2,-24,HxOverrides.cca(num,1) - 30);
			quake_Sbar.DrawCharacter((6 * i2 + 3 << 3) - 2,-24,HxOverrides.cca(num,2) - 30);
			break;
		}
	}
	if(quake_COM.hipnotic) {
		if((quake_CL.state.items & 524288) != 0) {
			quake_Sbar.DrawPic(224,-16,quake_Sbar.items[2]);
		}
		if((quake_CL.state.items & 1048576) != 0) {
			quake_Sbar.DrawPic(240,-16,quake_Sbar.items[3]);
		}
		if((quake_CL.state.items & 2097152) != 0) {
			quake_Sbar.DrawPic(256,-16,quake_Sbar.items[4]);
		}
		if((quake_CL.state.items & 4194304) != 0) {
			quake_Sbar.DrawPic(272,-16,quake_Sbar.items[5]);
		}
		if((quake_CL.state.items & 16777216) != 0) {
			quake_Sbar.DrawPic(288,-16,quake_Sbar.h_items[0]);
		}
		if((quake_CL.state.items & 33554432) != 0) {
			quake_Sbar.DrawPic(304,-16,quake_Sbar.h_items[1]);
		}
	} else {
		if((quake_CL.state.items & 131072) != 0) {
			quake_Sbar.DrawPic(192,-16,quake_Sbar.items[0]);
		}
		if((quake_CL.state.items & 262144) != 0) {
			quake_Sbar.DrawPic(208,-16,quake_Sbar.items[1]);
		}
		if((quake_CL.state.items & 524288) != 0) {
			quake_Sbar.DrawPic(224,-16,quake_Sbar.items[2]);
		}
		if((quake_CL.state.items & 1048576) != 0) {
			quake_Sbar.DrawPic(240,-16,quake_Sbar.items[3]);
		}
		if((quake_CL.state.items & 2097152) != 0) {
			quake_Sbar.DrawPic(256,-16,quake_Sbar.items[4]);
		}
		if((quake_CL.state.items & 4194304) != 0) {
			quake_Sbar.DrawPic(272,-16,quake_Sbar.items[5]);
		}
		if(quake_COM.rogue) {
			if((quake_CL.state.items & 536870912) != 0) {
				quake_Sbar.DrawPic(288,-16,quake_Sbar.r_items[0]);
			}
			if((quake_CL.state.items & 1073741824) != 0) {
				quake_Sbar.DrawPic(304,-16,quake_Sbar.r_items[1]);
			}
		} else {
			if((quake_CL.state.items >>> 28 & 1) != 0) {
				quake_Sbar.DrawPic(288,-16,quake_Sbar.sigil[0]);
			}
			if((quake_CL.state.items >>> 29 & 1) != 0) {
				quake_Sbar.DrawPic(296,-16,quake_Sbar.sigil[1]);
			}
			if((quake_CL.state.items >>> 30 & 1) != 0) {
				quake_Sbar.DrawPic(304,-16,quake_Sbar.sigil[2]);
			}
			if((quake_CL.state.items >>> 31 & 1) != 0) {
				quake_Sbar.DrawPic(312,-16,quake_Sbar.sigil[3]);
			}
		}
	}
};
quake_Sbar.DrawFrags = function() {
	quake_Sbar.SortFrags();
	var x = 23;
	var xofs = quake_CL.state.gametype == 1 ? 10 : (quake_VID.width >> 1) - 150;
	var y = quake_VID.height - 47;
	var _g = 0;
	var _g1 = quake_Sbar.scoreboardlines <= 4 ? quake_Sbar.scoreboardlines : 4;
	while(_g < _g1) {
		var k = quake_Sbar.fragsort[_g++];
		var s = quake_CL.state.scores[k];
		if(s.name.length == 0) {
			continue;
		}
		quake_Draw.Fill(xofs + (x << 3),y,28,4,(s.colors & 240) + 8);
		quake_Draw.Fill(xofs + (x << 3),y + 4,28,3,((s.colors & 15) << 4) + 8);
		var num = s.frags == null ? "null" : "" + s.frags;
		quake_Sbar.DrawString((x - num.length << 3) + 36,-24,num);
		if(k == quake_CL.state.viewentity - 1) {
			quake_Sbar.DrawCharacter((x << 3) + 2,-24,16);
			quake_Sbar.DrawCharacter((x << 3) + 28,-24,17);
		}
		x += 4;
	}
};
quake_Sbar.DrawFace = function() {
	if(quake_COM.rogue && quake_CL.state.maxclients != 1 && quake_Host.teamplay.value >= 4 && quake_Host.teamplay.value <= 6) {
		var s = quake_CL.state.scores[quake_CL.state.viewentity - 1];
		var top = (s.colors & 240) + 8;
		var xofs = quake_CL.state.gametype == 1 ? 113 : (quake_VID.width >> 1) - 47;
		quake_Sbar.DrawPic(112,0,quake_Sbar.r_teambord);
		quake_Draw.Fill(xofs,quake_VID.height - 21,22,9,top);
		quake_Draw.Fill(xofs,quake_VID.height - 12,22,9,((s.colors & 15) << 4) + 8);
		var num = (top == 8 ? ">>>" : "   ") + s.frags;
		if(num.length > 3) {
			num = num.substring(num.length - 3);
		}
		if(top == 8) {
			quake_Sbar.DrawCharacter(109,3,HxOverrides.cca(num,0) - 30);
			quake_Sbar.DrawCharacter(116,3,HxOverrides.cca(num,1) - 30);
			quake_Sbar.DrawCharacter(123,3,HxOverrides.cca(num,2) - 30);
		} else {
			quake_Sbar.DrawCharacter(109,3,HxOverrides.cca(num,0));
			quake_Sbar.DrawCharacter(116,3,HxOverrides.cca(num,1));
			quake_Sbar.DrawCharacter(123,3,HxOverrides.cca(num,2));
		}
		return;
	}
	if((quake_CL.state.items & (quake_Def.it.invisibility | quake_Def.it.invulnerability)) == (quake_Def.it.invisibility | quake_Def.it.invulnerability)) {
		quake_Sbar.DrawPic(112,0,quake_Sbar.face_invis_invuln);
		return;
	}
	if((quake_CL.state.items & quake_Def.it.quad) != 0) {
		quake_Sbar.DrawPic(112,0,quake_Sbar.face_quad);
		return;
	}
	if((quake_CL.state.items & quake_Def.it.invisibility) != 0) {
		quake_Sbar.DrawPic(112,0,quake_Sbar.face_invis);
		return;
	}
	if((quake_CL.state.items & quake_Def.it.invulnerability) != 0) {
		quake_Sbar.DrawPic(112,0,quake_Sbar.face_invuln);
		return;
	}
	quake_Sbar.DrawPic(112,0,quake_Sbar.faces[quake_CL.state.stats[0] >= 100 ? 4 : quake_CL.state.stats[0] / 20 | 0][quake_CL.state.time <= quake_CL.state.faceanimtime ? 1 : 0]);
};
quake_Sbar.DrawSbar = function() {
	if(quake_SCR.con_current >= 200) {
		return;
	}
	if(quake_Sbar.lines > 24) {
		quake_Sbar.DrawInventory();
		if(quake_CL.state.maxclients != 1) {
			quake_Sbar.DrawFrags();
		}
	}
	if(quake_Sbar.showscores || quake_CL.state.stats[0] <= 0) {
		quake_Sbar.DrawPic(0,0,quake_Sbar.scorebar);
		quake_Sbar.SoloScoreboard();
		if(quake_CL.state.gametype == 1) {
			quake_Sbar.DeathmatchOverlay();
		}
		return;
	}
	if(quake_Sbar.lines == 0) {
		return;
	}
	quake_Sbar.DrawPic(0,0,quake_Sbar.sbar);
	if(quake_COM.hipnotic) {
		if((quake_CL.state.items & quake_Def.it.key1) != 0) {
			quake_Sbar.DrawPic(209,3,quake_Sbar.items[0]);
		}
		if((quake_CL.state.items & quake_Def.it.key2) != 0) {
			quake_Sbar.DrawPic(209,12,quake_Sbar.items[1]);
		}
	}
	var it = quake_COM.rogue ? quake_Def.rit : quake_Def.it;
	if((quake_CL.state.items & quake_Def.it.invulnerability) != 0) {
		quake_Sbar.DrawNum(24,0,666,3,1);
		quake_Sbar.DrawPic(0,0,quake_Sbar.disc);
	} else {
		quake_Sbar.DrawNum(24,0,quake_CL.state.stats[4],3,quake_CL.state.stats[4] <= 25 ? 1 : 0);
		if((quake_CL.state.items & it.armor3) != 0) {
			quake_Sbar.DrawPic(0,0,quake_Sbar.armor[2]);
		} else if((quake_CL.state.items & it.armor2) != 0) {
			quake_Sbar.DrawPic(0,0,quake_Sbar.armor[1]);
		} else if((quake_CL.state.items & it.armor1) != 0) {
			quake_Sbar.DrawPic(0,0,quake_Sbar.armor[0]);
		}
	}
	quake_Sbar.DrawFace();
	quake_Sbar.DrawNum(136,0,quake_CL.state.stats[0],3,quake_CL.state.stats[0] <= 25 ? 1 : 0);
	if((quake_CL.state.items & it.shells) != 0) {
		quake_Sbar.DrawPic(224,0,quake_Sbar.ammo[0]);
	} else if((quake_CL.state.items & it.nails) != 0) {
		quake_Sbar.DrawPic(224,0,quake_Sbar.ammo[1]);
	} else if((quake_CL.state.items & it.rockets) != 0) {
		quake_Sbar.DrawPic(224,0,quake_Sbar.ammo[2]);
	} else if((quake_CL.state.items & it.cells) != 0) {
		quake_Sbar.DrawPic(224,0,quake_Sbar.ammo[3]);
	} else if(quake_COM.rogue) {
		if((quake_CL.state.items & quake_Def.rit.lava_nails) != 0) {
			quake_Sbar.DrawPic(224,0,quake_Sbar.r_ammo[0]);
		} else if((quake_CL.state.items & quake_Def.rit.plasma_ammo) != 0) {
			quake_Sbar.DrawPic(224,0,quake_Sbar.r_ammo[1]);
		} else if((quake_CL.state.items & quake_Def.rit.multi_rockets) != 0) {
			quake_Sbar.DrawPic(224,0,quake_Sbar.r_ammo[2]);
		}
	}
	quake_Sbar.DrawNum(248,0,quake_CL.state.stats[3],3,quake_CL.state.stats[3] <= 10 ? 1 : 0);
	if(quake_VID.width >= 512 && quake_CL.state.gametype == 1) {
		quake_Sbar.MiniDeathmatchOverlay();
	}
};
quake_Sbar.IntermissionNumber = function(x,y,num) {
	var str = num == null ? "null" : "" + num;
	if(str.length > 3) {
		str = str.substring(str.length - 3,str.length);
	} else if(str.length < 3) {
		x += (3 - str.length) * 24;
	}
	var _g = 0;
	var _g1 = str.length;
	while(_g < _g1) {
		var frame = HxOverrides.cca(str,_g++);
		quake_Draw.Pic(x,y,quake_Sbar.nums[0][frame == 45 ? 10 : frame - 48]);
		x += 24;
	}
};
quake_Sbar.DeathmatchOverlay = function() {
	quake_Draw.Pic(quake_VID.width - quake_Sbar.ranking.width >> 1,8,quake_Sbar.ranking);
	quake_Sbar.SortFrags();
	var x = (quake_VID.width >> 1) - 80;
	var y = 40;
	var _g = 0;
	var _g1 = quake_Sbar.scoreboardlines;
	while(_g < _g1) {
		var i = _g++;
		var s = quake_CL.state.scores[quake_Sbar.fragsort[i]];
		if(s.name.length == 0) {
			continue;
		}
		quake_Draw.Fill(x,y,40,4,(s.colors & 240) + 8);
		quake_Draw.Fill(x,y + 4,40,4,((s.colors & 15) << 4) + 8);
		var f = s.frags == null ? "null" : "" + s.frags;
		quake_Draw.String(x + 32 - (f.length << 3),y,f);
		if(quake_Sbar.fragsort[i] == quake_CL.state.viewentity - 1) {
			quake_Draw.Character(x - 8,y,12);
		}
		quake_Draw.String(x + 64,y,s.name);
		y += 10;
	}
};
quake_Sbar.MiniDeathmatchOverlay = function() {
	quake_Sbar.SortFrags();
	var l = quake_Sbar.scoreboardlines;
	var y = quake_VID.height - quake_Sbar.lines;
	var numlines = quake_Sbar.lines >> 3;
	var i = 0;
	while(i < l) {
		if(quake_Sbar.fragsort[i] == quake_CL.state.viewentity - 1) {
			break;
		}
		++i;
	}
	if(i == l) {
		i = 0;
	} else {
		i -= numlines >> 1;
	}
	if(i > l - numlines) {
		i = l - numlines;
	}
	if(i < 0) {
		i = 0;
	}
	while(i < l && y < quake_VID.height - 8) {
		var k = quake_Sbar.fragsort[i++];
		var s = quake_CL.state.scores[k];
		if(s.name.length == 0) {
			continue;
		}
		quake_Draw.Fill(324,y + 1,40,3,(s.colors & 240) + 8);
		quake_Draw.Fill(324,y + 4,40,4,((s.colors & 15) << 4) + 8);
		var num = s.frags == null ? "null" : "" + s.frags;
		quake_Draw.String(356 - (num.length << 3),y,num);
		if(k == quake_CL.state.viewentity - 1) {
			quake_Draw.Character(324,y,16);
			quake_Draw.Character(356,y,17);
		}
		quake_Draw.String(372,y,s.name);
		y += 8;
	}
};
quake_Sbar.IntermissionOverlay = function() {
	if(quake_CL.state.gametype == 1) {
		quake_Sbar.DeathmatchOverlay();
		return;
	}
	quake_Draw.Pic(64,24,quake_Sbar.complete);
	quake_Draw.Pic(0,56,quake_Sbar.inter);
	var dig = Math.floor(quake_CL.state.completed_time / 60.0);
	quake_Sbar.IntermissionNumber(160,64,dig);
	var num = Math.floor(quake_CL.state.completed_time - dig * 60);
	quake_Draw.Pic(234,64,quake_Sbar.colon);
	quake_Draw.Pic(246,64,quake_Sbar.nums[0][Math.floor(num / 10)]);
	quake_Draw.Pic(266,64,quake_Sbar.nums[0][Math.floor(num % 10)]);
	quake_Sbar.IntermissionNumber(160,104,quake_CL.state.stats[13]);
	quake_Draw.Pic(232,104,quake_Sbar.slash);
	quake_Sbar.IntermissionNumber(240,104,quake_CL.state.stats[11]);
	quake_Sbar.IntermissionNumber(160,144,quake_CL.state.stats[14]);
	quake_Draw.Pic(232,144,quake_Sbar.slash);
	quake_Sbar.IntermissionNumber(240,144,quake_CL.state.stats[12]);
};
var quake_V = function() { };
quake_V.__name__ = true;
quake_V.CalcRoll = function(angles,velocity) {
	var right = new Float32Array(3);
	quake__$Vec_Vec_$Impl_$.AngleVectors(angles,null,right);
	var side = velocity[0] * right[0] + velocity[1] * right[1] + velocity[2] * right[2];
	var sign = side < 0 ? -1 : 1;
	side = Math.abs(side);
	if(side < quake_V.rollspeed.value) {
		return side * sign * quake_V.rollangle.value / quake_V.rollspeed.value;
	}
	return quake_V.rollangle.value * sign;
};
quake_V.CalcBob = function() {
	if(quake_V.bobcycle.value <= 0.0 || quake_V.bobcycle.value >= 1.0 || quake_V.bobup.value <= 0.0 || quake_V.bobup.value >= 1.0 || quake_V.bob.value == 0.0) {
		return 0.0;
	}
	var cycle = (quake_CL.state.time - (quake_CL.state.time / quake_V.bobcycle.value | 0) * quake_V.bobcycle.value) / quake_V.bobcycle.value;
	if(cycle < quake_V.bobup.value) {
		cycle = Math.PI * cycle / quake_V.bobup.value;
	} else {
		cycle = Math.PI + Math.PI * (cycle - quake_V.bobup.value) / (1.0 - quake_V.bobup.value);
	}
	var bob = Math.sqrt(quake_CL.state.velocity[0] * quake_CL.state.velocity[0] + quake_CL.state.velocity[1] * quake_CL.state.velocity[1]) * quake_V.bob.value;
	bob = bob * 0.3 + bob * 0.7 * Math.sin(cycle);
	if(bob > 4.0) {
		bob = 4.0;
	} else if(bob < -7.0) {
		bob = -7.0;
	}
	return bob;
};
quake_V.StartPitchDrift = function() {
	if(quake_CL.state.laststop == quake_CL.state.time) {
		return;
	}
	if(quake_CL.state.nodrift || quake_CL.state.pitchvel == 0.0) {
		quake_CL.state.pitchvel = quake_V.centerspeed.value;
		quake_CL.state.nodrift = false;
		quake_CL.state.driftmove = 0.0;
	}
};
quake_V.StopPitchDrift = function() {
	quake_CL.state.laststop = quake_CL.state.time;
	quake_CL.state.nodrift = true;
	quake_CL.state.pitchvel = 0.0;
};
quake_V.DriftPitch = function() {
	if(quake_Host.noclip_anglehack || !quake_CL.state.onground || quake_CL.cls.demoplayback) {
		quake_CL.state.driftmove = 0.0;
		quake_CL.state.pitchvel = 0.0;
		return;
	}
	if(quake_CL.state.nodrift) {
		if(Math.abs(quake_CL.state.cmd.forwardmove) < quake_CL.forwardspeed.value) {
			quake_CL.state.driftmove = 0.0;
		} else {
			quake_CL.state.driftmove += quake_Host.frametime;
		}
		if(quake_CL.state.driftmove > quake_V.centermove.value) {
			quake_V.StartPitchDrift();
		}
		return;
	}
	var delta = quake_CL.state.idealpitch - quake_CL.state.viewangles[0];
	if(delta == 0.0) {
		quake_CL.state.pitchvel = 0.0;
		return;
	}
	var move = quake_Host.frametime * quake_CL.state.pitchvel;
	quake_CL.state.pitchvel += quake_Host.frametime * quake_V.centerspeed.value;
	if(delta > 0) {
		if(move > delta) {
			quake_CL.state.pitchvel = 0.0;
			move = delta;
		}
		quake_CL.state.viewangles[0] += move;
	} else if(delta < 0) {
		if(move > -delta) {
			quake_CL.state.pitchvel = 0.0;
			move = -delta;
		}
		quake_CL.state.viewangles[0] -= move;
	}
};
quake_V.ParseDamage = function() {
	var armor = quake_MSG.ReadByte();
	var blood = quake_MSG.ReadByte();
	var ent = quake_CL.entities[quake_CL.state.viewentity];
	var x = quake_MSG.ReadShort() * 0.125 - ent.origin[0];
	var y = quake_MSG.ReadShort() * 0.125 - ent.origin[1];
	var z = quake_MSG.ReadShort() * 0.125 - ent.origin[2];
	var v = new Float32Array(3);
	v[0] = x;
	v[1] = y;
	v[2] = z;
	quake__$Vec_Vec_$Impl_$.Normalize(v);
	var count = (blood + armor) * 0.5;
	if(count < 10.0) {
		count = 10.0;
	}
	quake_CL.state.faceanimtime = quake_CL.state.time + 0.2;
	var cshift = quake_CL.state.cshifts[1];
	if((cshift[3] += 3.0 * count) < 0.0) {
		cshift[3] = 0.0;
	} else if(cshift[3] > 150.0) {
		cshift[3] = 150.0;
	}
	if(armor > blood) {
		cshift[0] = 200.0;
		cshift[2] = 100.0;
		cshift[1] = 100.0;
	} else if(armor != 0) {
		cshift[0] = 220.0;
		cshift[2] = 50.0;
		cshift[1] = 50.0;
	} else {
		cshift[0] = 255.0;
		cshift[2] = 0.0;
		cshift[1] = 0.0;
	}
	var forward = new Float32Array(3);
	var right = new Float32Array(3);
	quake__$Vec_Vec_$Impl_$.AngleVectors(ent.angles,forward,right);
	quake_V.dmg_roll = count * (v[0] * right[0] + v[1] * right[1] + v[2] * right[2]) * quake_V.kickroll.value;
	quake_V.dmg_pitch = count * (v[0] * forward[0] + v[1] * forward[1] + v[2] * forward[2]) * quake_V.kickpitch.value;
	quake_V.dmg_time = quake_V.kicktime.value;
};
quake_V.cshift_f = function() {
	var cshift = quake_V.cshift_empty;
	cshift[0] = quake_Q.atoi(quake_Cmd.argv[1]);
	cshift[1] = quake_Q.atoi(quake_Cmd.argv[2]);
	cshift[2] = quake_Q.atoi(quake_Cmd.argv[3]);
	cshift[3] = quake_Q.atoi(quake_Cmd.argv[4]);
};
quake_V.BonusFlash_f = function() {
	var cshift = quake_CL.state.cshifts[2];
	cshift[0] = 215.0;
	cshift[1] = 186.0;
	cshift[2] = 69.0;
	cshift[3] = 50.0;
};
quake_V.SetContentsColor = function(contents) {
	switch(contents) {
	case -5:
		quake_CL.state.cshifts[0] = quake_V.cshift_lava;
		break;
	case -4:
		quake_CL.state.cshifts[0] = quake_V.cshift_slime;
		break;
	case -2:case -1:
		quake_CL.state.cshifts[0] = quake_V.cshift_empty;
		break;
	default:
		quake_CL.state.cshifts[0] = quake_V.cshift_water;
	}
};
quake_V.CalcBlend = function() {
	var cshift = quake_CL.state.cshifts[3];
	if((quake_CL.state.items & quake_Def.it.quad) != 0) {
		cshift[0] = 0.0;
		cshift[1] = 0.0;
		cshift[2] = 255.0;
		cshift[3] = 30.0;
	} else if((quake_CL.state.items & quake_Def.it.suit) != 0) {
		cshift[0] = 0.0;
		cshift[1] = 255.0;
		cshift[2] = 0.0;
		cshift[3] = 20.0;
	} else if((quake_CL.state.items & quake_Def.it.invisibility) != 0) {
		cshift[0] = 100.0;
		cshift[1] = 100.0;
		cshift[2] = 100.0;
		cshift[3] = 100.0;
	} else if((quake_CL.state.items & quake_Def.it.invulnerability) != 0) {
		cshift[0] = 255.0;
		cshift[1] = 255.0;
		cshift[2] = 0.0;
		cshift[3] = 30.0;
	} else {
		cshift[3] = 0.0;
	}
	quake_CL.state.cshifts[1][3] -= quake_Host.frametime * 150.0;
	if(quake_CL.state.cshifts[1][3] < 0.0) {
		quake_CL.state.cshifts[1][3] = 0.0;
	}
	quake_CL.state.cshifts[2][3] -= quake_Host.frametime * 100.0;
	if(quake_CL.state.cshifts[2][3] < 0.0) {
		quake_CL.state.cshifts[2][3] = 0.0;
	}
	if(quake_V.cshiftpercent.value == 0) {
		quake_V.blend[1] = quake_V.blend[2] = quake_V.blend[3] = 0.0;
		quake_V.blend[0] = 0.0;
		return;
	}
	var r = 0.0;
	var g = 0.0;
	var b = 0.0;
	var a = 0.0;
	var _g = 0;
	while(_g < 4) {
		var cshift1 = quake_CL.state.cshifts[_g++];
		var a2 = cshift1[3] * quake_V.cshiftpercent.value / 25500.0;
		if(a2 == 0.0) {
			continue;
		}
		a += a2 * (1.0 - a);
		a2 /= a;
		r = r * (1.0 - a2) + cshift1[0] * a2;
		g = g * (1.0 - a2) + cshift1[1] * a2;
		b = b * (1.0 - a2) + cshift1[2] * a2;
	}
	if(a > 1.0) {
		a = 1.0;
	} else if(a < 0.0) {
		a = 0.0;
	}
	quake_V.blend[0] = r;
	quake_V.blend[1] = g;
	quake_V.blend[2] = b;
	quake_V.blend[3] = a;
	if(quake_V.blend[3] > 1.0) {
		quake_V.blend[3] = 1.0;
	} else if(quake_V.blend[3] < 0.0) {
		quake_V.blend[3] = 0.0;
	}
};
quake_V.CalcIntermissionRefdef = function() {
	var ent = quake_CL.entities[quake_CL.state.viewentity];
	quake_Render.refdef.vieworg[0] = ent.origin[0];
	quake_Render.refdef.vieworg[1] = ent.origin[1];
	quake_Render.refdef.vieworg[2] = ent.origin[2];
	quake_Render.refdef.viewangles[0] = ent.angles[0] + Math.sin(quake_CL.state.time * quake_V.ipitch_cycle.value) * quake_V.ipitch_level.value;
	quake_Render.refdef.viewangles[1] = ent.angles[1] + Math.sin(quake_CL.state.time * quake_V.iyaw_cycle.value) * quake_V.iyaw_level.value;
	quake_Render.refdef.viewangles[2] = ent.angles[2] + Math.sin(quake_CL.state.time * quake_V.iroll_cycle.value) * quake_V.iroll_level.value;
	quake_CL.state.viewent.model = null;
};
quake_V.CalcRefdef = function() {
	quake_V.DriftPitch();
	var ent = quake_CL.entities[quake_CL.state.viewentity];
	ent.angles[1] = quake_CL.state.viewangles[1];
	ent.angles[0] = -quake_CL.state.viewangles[0];
	var bob = quake_V.CalcBob();
	quake_Render.refdef.vieworg[0] = ent.origin[0] + 0.03125;
	quake_Render.refdef.vieworg[1] = ent.origin[1] + 0.03125;
	quake_Render.refdef.vieworg[2] = ent.origin[2] + quake_CL.state.viewheight + bob + 0.03125;
	quake_Render.refdef.viewangles[0] = quake_CL.state.viewangles[0];
	quake_Render.refdef.viewangles[1] = quake_CL.state.viewangles[1];
	quake_Render.refdef.viewangles[2] = quake_CL.state.viewangles[2] + quake_V.CalcRoll(quake_CL.entities[quake_CL.state.viewentity].angles,quake_CL.state.velocity);
	if(quake_V.dmg_time > 0.0) {
		if(quake_V.kicktime.value != 0.0) {
			quake_Render.refdef.viewangles[2] += quake_V.dmg_time / quake_V.kicktime.value * quake_V.dmg_roll;
			quake_Render.refdef.viewangles[0] -= quake_V.dmg_time / quake_V.kicktime.value * quake_V.dmg_pitch;
		}
		quake_V.dmg_time -= quake_Host.frametime;
	}
	if(quake_CL.state.stats[0] <= 0) {
		quake_Render.refdef.viewangles[2] = 80.0;
	}
	var ipitch = quake_V.idlescale.value * Math.sin(quake_CL.state.time * quake_V.ipitch_cycle.value) * quake_V.ipitch_level.value;
	var iyaw = quake_V.idlescale.value * Math.sin(quake_CL.state.time * quake_V.iyaw_cycle.value) * quake_V.iyaw_level.value;
	var iroll = quake_V.idlescale.value * Math.sin(quake_CL.state.time * quake_V.iroll_cycle.value) * quake_V.iroll_level.value;
	quake_Render.refdef.viewangles[0] += ipitch;
	quake_Render.refdef.viewangles[1] += iyaw;
	quake_Render.refdef.viewangles[2] += iroll;
	var forward = new Float32Array(3);
	var right = new Float32Array(3);
	var up = new Float32Array(3);
	var v = new Float32Array(3);
	v[0] = -ent.angles[0];
	v[1] = ent.angles[1];
	v[2] = ent.angles[2];
	quake__$Vec_Vec_$Impl_$.AngleVectors(v,forward,right,up);
	quake_Render.refdef.vieworg[0] += quake_V.ofsx.value * forward[0] + quake_V.ofsy.value * right[0] + quake_V.ofsz.value * up[0];
	quake_Render.refdef.vieworg[1] += quake_V.ofsx.value * forward[1] + quake_V.ofsy.value * right[1] + quake_V.ofsz.value * up[1];
	quake_Render.refdef.vieworg[2] += quake_V.ofsx.value * forward[2] + quake_V.ofsy.value * right[2] + quake_V.ofsz.value * up[2];
	if(quake_Render.refdef.vieworg[0] < ent.origin[0] - 14.0) {
		quake_Render.refdef.vieworg[0] = ent.origin[0] - 14.0;
	} else if(quake_Render.refdef.vieworg[0] > ent.origin[0] + 14.0) {
		quake_Render.refdef.vieworg[0] = ent.origin[0] + 14.0;
	}
	if(quake_Render.refdef.vieworg[1] < ent.origin[1] - 14.0) {
		quake_Render.refdef.vieworg[1] = ent.origin[1] - 14.0;
	} else if(quake_Render.refdef.vieworg[1] > ent.origin[1] + 14.0) {
		quake_Render.refdef.vieworg[1] = ent.origin[1] + 14.0;
	}
	if(quake_Render.refdef.vieworg[2] < ent.origin[2] - 22.0) {
		quake_Render.refdef.vieworg[2] = ent.origin[2] - 22.0;
	} else if(quake_Render.refdef.vieworg[2] > ent.origin[2] + 30.0) {
		quake_Render.refdef.vieworg[2] = ent.origin[2] + 30.0;
	}
	var view = quake_CL.state.viewent;
	view.angles[0] = -quake_Render.refdef.viewangles[0] - ipitch;
	view.angles[1] = quake_Render.refdef.viewangles[1] - iyaw;
	view.angles[2] = quake_CL.state.viewangles[2] - iroll;
	view.origin[0] = ent.origin[0] + forward[0] * bob * 0.4;
	view.origin[1] = ent.origin[1] + forward[1] * bob * 0.4;
	view.origin[2] = ent.origin[2] + quake_CL.state.viewheight + forward[2] * bob * 0.4 + bob;
	switch(quake_SCR.viewsize.value) {
	case 80:
		view.origin[2] += 0.5;
		break;
	case 90:case 110:
		view.origin[2] += 1.0;
		break;
	case 100:
		view.origin[2] += 2.0;
		break;
	}
	view.model = quake_CL.state.model_precache[quake_CL.state.stats[2]];
	view.frame = quake_CL.state.stats[5];
	quake_Render.refdef.viewangles[0] += quake_CL.state.punchangle[0];
	quake_Render.refdef.viewangles[1] += quake_CL.state.punchangle[1];
	quake_Render.refdef.viewangles[2] += quake_CL.state.punchangle[2];
	if(quake_CL.state.onground && ent.origin[2] - quake_V.oldz > 0.0) {
		var steptime = quake_CL.state.time - quake_CL.state.oldtime;
		if(steptime < 0.0) {
			steptime = 0.0;
		}
		if((quake_V.oldz += steptime * 80.0) > ent.origin[2]) {
			quake_V.oldz = ent.origin[2];
		} else if(ent.origin[2] - quake_V.oldz > 12.0) {
			quake_V.oldz = ent.origin[2] - 12.0;
		}
		quake_Render.refdef.vieworg[2] += quake_V.oldz - ent.origin[2];
		view.origin[2] += quake_V.oldz - ent.origin[2];
	} else {
		quake_V.oldz = ent.origin[2];
	}
	if(quake_Chase.active.value != 0) {
		quake_Chase.Update();
	}
};
quake_V.RenderView = function() {
	if(quake_Console.forcedup) {
		return;
	}
	if(quake_CL.state.maxclients >= 2) {
		quake_V.ofsx.set("0");
		quake_V.ofsy.set("0");
		quake_V.ofsz.set("0");
	}
	if(quake_CL.state.intermission != 0) {
		quake_V.CalcIntermissionRefdef();
	} else if(!quake_CL.state.paused) {
		quake_V.CalcRefdef();
	}
	quake_Render.PushDlights();
	quake_Render.RenderView();
};
quake_V.Init = function() {
	quake_Cmd.AddCommand("v_cshift",quake_V.cshift_f);
	quake_Cmd.AddCommand("bf",quake_V.BonusFlash_f);
	quake_Cmd.AddCommand("centerview",quake_V.StartPitchDrift);
	quake_V.centermove = quake_Cvar.RegisterVariable("v_centermove","0.15");
	quake_V.centerspeed = quake_Cvar.RegisterVariable("v_centerspeed","500");
	quake_V.iyaw_cycle = quake_Cvar.RegisterVariable("v_iyaw_cycle","2");
	quake_V.iroll_cycle = quake_Cvar.RegisterVariable("v_iroll_cycle","0.5");
	quake_V.ipitch_cycle = quake_Cvar.RegisterVariable("v_ipitch_cycle","1");
	quake_V.iyaw_level = quake_Cvar.RegisterVariable("v_iyaw_level","0.3");
	quake_V.iroll_level = quake_Cvar.RegisterVariable("v_iroll_level","0.1");
	quake_V.ipitch_level = quake_Cvar.RegisterVariable("v_ipitch_level","0.3");
	quake_V.idlescale = quake_Cvar.RegisterVariable("v_idlescale","0");
	quake_V.crosshair = quake_Cvar.RegisterVariable("crosshair","0",true);
	quake_V.crossx = quake_Cvar.RegisterVariable("cl_crossx","0");
	quake_V.crossy = quake_Cvar.RegisterVariable("cl_crossy","0");
	quake_V.cshiftpercent = quake_Cvar.RegisterVariable("gl_cshiftpercent","100");
	quake_V.ofsx = quake_Cvar.RegisterVariable("scr_ofsx","0");
	quake_V.ofsy = quake_Cvar.RegisterVariable("scr_ofsy","0");
	quake_V.ofsz = quake_Cvar.RegisterVariable("scr_ofsz","0");
	quake_V.rollspeed = quake_Cvar.RegisterVariable("cl_rollspeed","200");
	quake_V.rollangle = quake_Cvar.RegisterVariable("cl_rollangle","2.0");
	quake_V.bob = quake_Cvar.RegisterVariable("cl_bob","0.02");
	quake_V.bobcycle = quake_Cvar.RegisterVariable("cl_bobcycle","0.6");
	quake_V.bobup = quake_Cvar.RegisterVariable("cl_bobup","0.5");
	quake_V.kicktime = quake_Cvar.RegisterVariable("v_kicktime","0.5");
	quake_V.kickroll = quake_Cvar.RegisterVariable("v_kickroll","0.6");
	quake_V.kickpitch = quake_Cvar.RegisterVariable("v_kickpitch","0.6");
	quake_V.gamma = quake_Cvar.RegisterVariable("gamma","1",true);
};
var quake_W = function() { };
quake_W.__name__ = true;
quake_W.LoadWadFile = function(filename) {
	var base = quake_COM.LoadFile(filename);
	if(base == null) {
		quake_Sys.Error("W.LoadWadFile: couldn't load " + filename);
	}
	var view = new DataView(base);
	if(view.getUint32(0,true) != 843333975) {
		quake_Sys.Error("Wad file " + filename + " doesn't have WAD2 id");
	}
	var numlumps = view.getUint32(4,true);
	var infotableofs = view.getUint32(8,true);
	var _g = 0;
	while(_g < numlumps) {
		++_g;
		var size = view.getUint32(infotableofs + 4,true);
		var lump = new ArrayBuffer(size);
		new Uint8Array(lump).set(new Uint8Array(base,view.getUint32(infotableofs,true),size));
		var this1 = quake_W.lumps;
		var k = quake_Q.memstr(new Uint8Array(base,infotableofs + 16,16)).toUpperCase();
		var _this = this1;
		if(__map_reserved[k] != null) {
			_this.setReserved(k,lump);
		} else {
			_this.h[k] = lump;
		}
		infotableofs += 32;
	}
};
quake_W.GetLumpName = function(name) {
	var _this = quake_W.lumps;
	var lump = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
	if(lump == null) {
		quake_Sys.Error("W.GetLumpName: " + name + " not found");
	}
	return lump;
};
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
if(typeof $global.$haxeUID == "undefined") $global.$haxeUID = 0;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
quake_CL.temp_entities = [];
quake_CL.kbutton = { mlook : 0, klook : 1, left : 2, right : 3, forward : 4, back : 5, lookup : 6, lookdown : 7, moveleft : 8, moveright : 9, strafe : 10, speed : 11, use : 12, jump : 13, attack : 14, moveup : 15, movedown : 16, num : 17};
quake_CL.kbuttons = [];
quake_CL.sendmovebuf = new quake_MSG(16);
quake_CL.cls = new quake__$CL_ClientStatic();
quake_CL.static_entities = [];
quake_CL.visedicts = [];
quake_CL.svc_strings = ["bad","nop","disconnect","updatestat","version","setview","sound","time","print","stufftext","setangle","serverinfo","lightstyle","updatename","updatefrags","clientdata","stopsound","updatecolors","particle","damage","spawnstatic","OBSOLETE spawnbinary","spawnbaseline","temp_entity","setpause","signonnum","centerprint","killedmonster","foundsecret","spawnstaticsound","intermission","finale","cdtrack","sellscreen","cutscene"];
quake_CL.lastmsg = 0.0;
quake_COM.argv = [];
quake_COM.standard_quake = true;
quake_COM.rogue = false;
quake_COM.hipnotic = false;
quake_COM.modified = false;
quake_COM.searchpaths = [];
quake_COM.localStorage = js_Browser.getLocalStorage();
quake_CRC.table = [0,4129,8258,12387,16516,20645,24774,28903,33032,37161,41290,45419,49548,53677,57806,61935,4657,528,12915,8786,21173,17044,29431,25302,37689,33560,45947,41818,54205,50076,62463,58334,9314,13379,1056,5121,25830,29895,17572,21637,42346,46411,34088,38153,58862,62927,50604,54669,13907,9842,5649,1584,30423,26358,22165,18100,46939,42874,38681,34616,63455,59390,55197,51132,18628,22757,26758,30887,2112,6241,10242,14371,51660,55789,59790,63919,35144,39273,43274,47403,23285,19156,31415,27286,6769,2640,14899,10770,56317,52188,64447,60318,39801,35672,47931,43802,27814,31879,19684,23749,11298,15363,3168,7233,60846,64911,52716,56781,44330,48395,36200,40265,32407,28342,24277,20212,15891,11826,7761,3696,65439,61374,57309,53244,48923,44858,40793,36728,37256,33193,45514,41451,53516,49453,61774,57711,4224,161,12482,8419,20484,16421,28742,24679,33721,37784,41979,46042,49981,54044,58239,62302,689,4752,8947,13010,16949,21012,25207,29270,46570,42443,38312,34185,62830,58703,54572,50445,13538,9411,5280,1153,29798,25671,21540,17413,42971,47098,34713,38840,59231,63358,50973,55100,9939,14066,1681,5808,26199,30326,17941,22068,55628,51565,63758,59695,39368,35305,47498,43435,22596,18533,30726,26663,6336,2273,14466,10403,52093,56156,60223,64286,35833,39896,43963,48026,19061,23124,27191,31254,2801,6864,10931,14994,64814,60687,56684,52557,48554,44427,40424,36297,31782,27655,23652,19525,15522,11395,7392,3265,61215,65342,53085,57212,44955,49082,36825,40952,28183,32310,20053,24180,11923,16050,3793,7920];
quake_Cmd.text = "";
quake_Cmd.argv = [];
quake_Cmd.functions = new haxe_ds_StringMap();
quake_Cmd.alias = new haxe_ds_StringMap();
quake_Cmd.wait = false;
quake_Console.backscroll = 0;
quake_Console.text = [];
quake_Console.current = 0;
quake_Cvar.vars = new haxe_ds_StringMap();
quake_Def.it = { shotgun : 1, super_shotgun : 2, nailgun : 4, super_nailgun : 8, grenade_launcher : 16, rocket_launcher : 32, lightning : 64, super_lightning : 128, shells : 256, nails : 512, rockets : 1024, cells : 2048, axe : 4096, armor1 : 8192, armor2 : 16384, armor3 : 32768, superhealth : 65536, key1 : 131072, key2 : 262144, invisibility : 524288, invulnerability : 1048576, suit : 2097152, quad : 4194304};
quake_Def.rit = { shells : 128, nails : 256, rockets : 512, cells : 1024, axe : 2048, lava_nailgun : 4096, lava_super_nailgun : 8192, multi_grenade : 16384, multi_rocket : 32768, plasma_gun : 65536, armor1 : 8388608, armor2 : 16777216, armor3 : 33554432, lava_nails : 67108864, plasma_ammo : 134217728, multi_rockets : 268435456, shield : 536870912, antigrav : 1073741824, superhealth : 2147483648};
quake_Def.hit = { proximity_gun_bit : 16, mjolnir_bit : 7, laser_cannon_bit : 23, proximity_gun : 65536, mjolnir : 128, laser_cannon : 8388608, wetsuit : 33554432, empathy_shields : 67108864};
quake_GL.textures = [];
quake_GL.programs = [];
quake_GL.ortho = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.00001,0.0,-1.0,1.0,0.0,1.0];
quake_GL.identity = [1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0];
quake_GL.currenttextures = new haxe_ds_IntMap();
quake_Host.initialized = false;
quake_Host.noclip_anglehack = false;
quake_Host.framecount = 0;
quake_Host.timetotal = 0.0;
quake_Host.timecount = 0;
quake_Host.time3 = 0.0;
quake_Host.inerror = false;
quake_Host.isdown = false;
quake_IN.mouse_x = 0.0;
quake_IN.mouse_y = 0.0;
quake_IN.old_mouse_x = 0.0;
quake_IN.old_mouse_y = 0.0;
quake_IN.mouse_avail = false;
quake_Key.lines = [""];
quake_Key.edit_line = "";
quake_Key.history_line = 1;
quake_Key.bindings = [];
quake_Key.consolekeys = [];
quake_Key.shift = [];
quake_Key.down = [];
quake_Key.names = [{ name : "TAB", keynum : 9},{ name : "ENTER", keynum : 13},{ name : "ESCAPE", keynum : 27},{ name : "SPACE", keynum : 32},{ name : "BACKSPACE", keynum : 127},{ name : "UPARROW", keynum : 128},{ name : "DOWNARROW", keynum : 129},{ name : "LEFTARROW", keynum : 130},{ name : "RIGHTARROW", keynum : 131},{ name : "ALT", keynum : 132},{ name : "CTRL", keynum : 133},{ name : "SHIFT", keynum : 134},{ name : "F1", keynum : 135},{ name : "F2", keynum : 136},{ name : "F3", keynum : 137},{ name : "F4", keynum : 138},{ name : "F5", keynum : 139},{ name : "F6", keynum : 140},{ name : "F7", keynum : 141},{ name : "F8", keynum : 142},{ name : "F9", keynum : 143},{ name : "F10", keynum : 144},{ name : "F11", keynum : 145},{ name : "F12", keynum : 146},{ name : "INS", keynum : 147},{ name : "DEL", keynum : 148},{ name : "PGDN", keynum : 149},{ name : "PGUP", keynum : 150},{ name : "HOME", keynum : 151},{ name : "END", keynum : 152},{ name : "MOUSE1", keynum : 200},{ name : "MOUSE2", keynum : 201},{ name : "MOUSE3", keynum : 202},{ name : "PAUSE", keynum : 255},{ name : "MWHEELUP", keynum : 239},{ name : "MWHEELDOWN", keynum : 240},{ name : "SEMICOLON", keynum : 59}];
quake_Key.chat_buffer = "";
quake_Menu.state = 0;
quake_Menu.localStorage = js_Browser.getLocalStorage();
quake_Menu.entersound = false;
quake_Menu.main_cursor = 0;
quake_Menu.singleplayer_cursor = 0;
quake_Menu.load_cursor = 0;
quake_Menu.max_savegames = 12;
quake_Menu.filenames = [];
quake_Menu.loadable = [];
quake_Menu.removable = [];
quake_Menu.multiplayer_cursor = 0;
quake_Menu.multiplayer_cursor_table = [56,72,96,120,156];
quake_Menu.multiplayer_joinname = "";
quake_Menu.options_cursor = 0;
quake_Menu.bindnames = [["+attack","attack"],["impulse 10","change weapon"],["+jump","jump / swim up"],["+forward","walk forward"],["+back","backpedal"],["+left","turn left"],["+right","turn right"],["+speed","run"],["+moveleft","step left"],["+moveright","step right"],["+strafe","sidestep"],["+lookup","look up"],["+lookdown","look down"],["centerview","center view"],["+mlook","mouse look"],["+klook","keyboard look"],["+moveup","swim up"],["+movedown","swim down"]];
quake_Menu.keys_cursor = 0;
quake_Menu.quitMessage = [["  Are you gonna quit","  this game just like","   everything else?",""],[" Milord, methinks that","   thou art a lowly"," quitter. Is this true?",""],[" Do I need to bust your","  face open for trying","        to quit?",""],[" Man, I oughta smack you","   for trying to quit!","     Press Y to get","      smacked out."],[" Press Y to quit like a","   big loser in life.","  Press N to stay proud","    and successful!"],["   If you press Y to","  quit, I will summon","  Satan all over your","      hard drive!"],["  Um, Asmodeus dislikes"," his children trying to"," quit. Press Y to return","   to your Tinkertoys."],["  If you quit now, I'll","  throw a blanket-party","   for you next time!",""]];
quake_Mod.known = [];
quake_NET.activeSockets = [];
quake_NET.message = new quake_MSG(8192);
quake_NET.activeconnections = 0;
quake_NET_$Loop.localconnectpending = false;
quake_NET_$Loop.initialized = false;
quake_NET_$WEBS.available = false;
quake_NET_$WEBS.initialized = false;
quake_PR.localstack_size = 2048;
quake_PR.opnames = ["DONE","MUL_F","MUL_V","MUL_FV","MUL_VF","DIV","ADD_F","ADD_V","SUB_F","SUB_V","EQ_F","EQ_V","EQ_S","EQ_E","EQ_FNC","NE_F","NE_V","NE_S","NE_E","NE_FNC","LE","GE","LT","GT","INDIRECT","INDIRECT","INDIRECT","INDIRECT","INDIRECT","INDIRECT","ADDRESS","STORE_F","STORE_V","STORE_S","STORE_ENT","STORE_FLD","STORE_FNC","STOREP_F","STOREP_V","STOREP_S","STOREP_ENT","STOREP_FLD","STOREP_FNC","RETURN","NOT_F","NOT_V","NOT_S","NOT_ENT","NOT_FNC","IF","IFNOT","CALL0","CALL1","CALL2","CALL3","CALL4","CALL5","CALL6","CALL7","CALL8","STATE","GOTO","AND","OR","BITAND","BITOR"];
quake_VID.d_8to24table = new Uint32Array(new ArrayBuffer(1024));
quake_S.started = false;
quake_S.channels = [];
quake_S.static_channels = [];
quake_S.ambient_channels = [];
quake_S.listener_origin = new Float32Array(3);
quake_S.listener_forward = new Float32Array(3);
quake_S.listener_right = new Float32Array(3);
quake_S.listener_up = new Float32Array(3);
quake_S.known_sfx = [];
quake__$Vec_Vec_$Impl_$.origin = new Float32Array(3);
quake_SCR.con_current = 0;
quake_SCR.centertime_off = 0.0;
quake_SCR.recalc_refdef = false;
quake_SCR.disabled_for_loading = false;
quake_SCR.centerstring = [];
quake_SCR.count = 0;
quake_SCR.screenshot = false;
quake_SV.server = new quake__$SV_ServerState();
quake_SV.svs = new quake__$SV_ServerStatic();
quake_SV.clientdatagram = new quake_MSG(1024);
quake_SV.fatpvs = [];
quake_SV.readClientCmds = ["status","god","notarget","fly","name","noclip","say","say_team","tell","color","kill","pause","spawn","begin","prespawn","kick","ping","give","ban"];
quake_Render.dlightframecount = 0;
quake_Render.lightstylevalue = new Uint8Array(64);
quake_Render.visframecount = 0;
quake_Render.frustum = [new quake_Plane(),new quake_Plane(),new quake_Plane(),new quake_Plane()];
quake_Render.vup = new Float32Array(3);
quake_Render.vpn = new Float32Array(3);
quake_Render.vright = new Float32Array(3);
quake_Render.refdef = new quake__$Render_RefDef();
quake_Render.avertexnormals = new Float32Array([-0.525731,0.000000,0.850651,-0.442863,0.238856,0.864188,-0.295242,0.000000,0.955423,-0.309017,0.500000,0.809017,-0.162460,0.262866,0.951056,0.000000,0.000000,1.000000,0.000000,0.850651,0.525731,-0.147621,0.716567,0.681718,0.147621,0.716567,0.681718,0.000000,0.525731,0.850651,0.309017,0.500000,0.809017,0.525731,0.000000,0.850651,0.295242,0.000000,0.955423,0.442863,0.238856,0.864188,0.162460,0.262866,0.951056,-0.681718,0.147621,0.716567,-0.809017,0.309017,0.500000,-0.587785,0.425325,0.688191,-0.850651,0.525731,0.000000,-0.864188,0.442863,0.238856,-0.716567,0.681718,0.147621,-0.688191,0.587785,0.425325,-0.500000,0.809017,0.309017,-0.238856,0.864188,0.442863,-0.425325,0.688191,0.587785,-0.716567,0.681718,-0.147621,-0.500000,0.809017,-0.309017,-0.525731,0.850651,0.000000,0.000000,0.850651,-0.525731,-0.238856,0.864188,-0.442863,0.000000,0.955423,-0.295242,-0.262866,0.951056,-0.162460,0.000000,1.000000,0.000000,0.000000,0.955423,0.295242,-0.262866,0.951056,0.162460,0.238856,0.864188,0.442863,0.262866,0.951056,0.162460,0.500000,0.809017,0.309017,0.238856,0.864188,-0.442863,0.262866,0.951056,-0.162460,0.500000,0.809017,-0.309017,0.850651,0.525731,0.000000,0.716567,0.681718,0.147621,0.716567,0.681718,-0.147621,0.525731,0.850651,0.000000,0.425325,0.688191,0.587785,0.864188,0.442863,0.238856,0.688191,0.587785,0.425325,0.809017,0.309017,0.500000,0.681718,0.147621,0.716567,0.587785,0.425325,0.688191,0.955423,0.295242,0.000000,1.000000,0.000000,0.000000,0.951056,0.162460,0.262866,0.850651,-0.525731,0.000000,0.955423,-0.295242,0.000000,0.864188,-0.442863,0.238856,0.951056,-0.162460,0.262866,0.809017,-0.309017,0.500000,0.681718,-0.147621,0.716567,0.850651,0.000000,0.525731,0.864188,0.442863,-0.238856,0.809017,0.309017,-0.500000,0.951056,0.162460,-0.262866,0.525731,0.000000,-0.850651,0.681718,0.147621,-0.716567,0.681718,-0.147621,-0.716567,0.850651,0.000000,-0.525731,0.809017,-0.309017,-0.500000,0.864188,-0.442863,-0.238856,0.951056,-0.162460,-0.262866,0.147621,0.716567,-0.681718,0.309017,0.500000,-0.809017,0.425325,0.688191,-0.587785,0.442863,0.238856,-0.864188,0.587785,0.425325,-0.688191,0.688191,0.587785,-0.425325,-0.147621,0.716567,-0.681718,-0.309017,0.500000,-0.809017,0.000000,0.525731,-0.850651,-0.525731,0.000000,-0.850651,-0.442863,0.238856,-0.864188,-0.295242,0.000000,-0.955423,-0.162460,0.262866,-0.951056,0.000000,0.000000,-1.000000,0.295242,0.000000,-0.955423,0.162460,0.262866,-0.951056,-0.442863,-0.238856,-0.864188,-0.309017,-0.500000,-0.809017,-0.162460,-0.262866,-0.951056,0.000000,-0.850651,-0.525731,-0.147621,-0.716567,-0.681718,0.147621,-0.716567,-0.681718,0.000000,-0.525731,-0.850651,0.309017,-0.500000,-0.809017,0.442863,-0.238856,-0.864188,0.162460,-0.262866,-0.951056,0.238856,-0.864188,-0.442863,0.500000,-0.809017,-0.309017,0.425325,-0.688191,-0.587785,0.716567,-0.681718,-0.147621,0.688191,-0.587785,-0.425325,0.587785,-0.425325,-0.688191,0.000000,-0.955423,-0.295242,0.000000,-1.000000,0.000000,0.262866,-0.951056,-0.162460,0.000000,-0.850651,0.525731,0.000000,-0.955423,0.295242,0.238856,-0.864188,0.442863,0.262866,-0.951056,0.162460,0.500000,-0.809017,0.309017,0.716567,-0.681718,0.147621,0.525731,-0.850651,0.000000,-0.238856,-0.864188,-0.442863,-0.500000,-0.809017,-0.309017,-0.262866,-0.951056,-0.162460,-0.850651,-0.525731,0.000000,-0.716567,-0.681718,-0.147621,-0.716567,-0.681718,0.147621,-0.525731,-0.850651,0.000000,-0.500000,-0.809017,0.309017,-0.238856,-0.864188,0.442863,-0.262866,-0.951056,0.162460,-0.864188,-0.442863,0.238856,-0.809017,-0.309017,0.500000,-0.688191,-0.587785,0.425325,-0.681718,-0.147621,0.716567,-0.442863,-0.238856,0.864188,-0.587785,-0.425325,0.688191,-0.309017,-0.500000,0.809017,-0.147621,-0.716567,0.681718,-0.425325,-0.688191,0.587785,-0.162460,-0.262866,0.951056,0.442863,-0.238856,0.864188,0.162460,-0.262866,0.951056,0.309017,-0.500000,0.809017,0.147621,-0.716567,0.681718,0.000000,-0.525731,0.850651,0.425325,-0.688191,0.587785,0.587785,-0.425325,0.688191,0.688191,-0.587785,0.425325,-0.955423,0.295242,0.000000,-0.951056,0.162460,0.262866,-1.000000,0.000000,0.000000,-0.850651,0.000000,0.525731,-0.955423,-0.295242,0.000000,-0.951056,-0.162460,0.262866,-0.864188,0.442863,-0.238856,-0.951056,0.162460,-0.262866,-0.809017,0.309017,-0.500000,-0.864188,-0.442863,-0.238856,-0.951056,-0.162460,-0.262866,-0.809017,-0.309017,-0.500000,-0.681718,0.147621,-0.716567,-0.681718,-0.147621,-0.716567,-0.850651,0.000000,-0.525731,-0.688191,0.587785,-0.425325,-0.587785,0.425325,-0.688191,-0.425325,0.688191,-0.587785,-0.425325,-0.688191,-0.587785,-0.587785,-0.425325,-0.688191,-0.688191,-0.587785,-0.425325]);
quake_Render.perspective = [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,-1.0001220777635353,-1.0,0.0,0.0,-8.0004883110541414,0.0];
quake_Render.ramp1 = [111,109,107,105,103,101,99,97];
quake_Render.ramp2 = [111,110,109,108,107,106,104,102];
quake_Render.ramp3 = [109,107,6,5,4,3];
quake_Render.tracercount = 0;
quake_Render.lightmap_modified = new Uint8Array(1024);
quake_Render.lightmaps = new Uint8Array(new ArrayBuffer(4194304));
quake_Render.dlightmaps = new Uint8Array(new ArrayBuffer(1048576));
quake_PF.builtin = [quake_PF.Fixme,quake_PF.makevectors,quake_PF.setorigin,quake_PF.setmodel,quake_PF.setsize,quake_PF.Fixme,quake_PF.breakstatement,quake_PF.random,quake_PF.sound,quake_PF.normalize,quake_PF.error,quake_PF.objerror,quake_PF.vlen,quake_PF.vectoyaw,quake_PF.Spawn,quake_PF.Remove,quake_PF.traceline,quake_PF.checkclient,quake_PF.Find,quake_PF.precache_sound,quake_PF.precache_model,quake_PF.stuffcmd,quake_PF.findradius,quake_PF.bprint,quake_PF.sprint,quake_PF.dprint,quake_PF.ftos,quake_PF.vtos,quake_PF.coredump,quake_PF.traceon,quake_PF.traceoff,quake_PF.eprint,quake_PF.walkmove,quake_PF.Fixme,quake_PF.droptofloor,quake_PF.lightstyle,quake_PF.rint,quake_PF.floor,quake_PF.ceil,quake_PF.Fixme,quake_PF.checkbottom,quake_PF.pointcontents,quake_PF.Fixme,quake_PF.fabs,quake_PF.aim,quake_PF.cvar,quake_PF.localcmd,quake_PF.nextent,quake_PF.particle,quake_PF.changeyaw,quake_PF.Fixme,quake_PF.vectoangles,quake_PF.WriteByte,quake_PF.WriteChar,quake_PF.WriteShort,quake_PF.WriteLong,quake_PF.WriteCoord,quake_PF.WriteAngle,quake_PF.WriteString,quake_PF.WriteEntity,quake_PF.Fixme,quake_PF.Fixme,quake_PF.Fixme,quake_PF.Fixme,quake_PF.Fixme,quake_PF.Fixme,quake_PF.Fixme,quake_PF.MoveToGoal,quake_PF.precache_file,quake_PF.makestatic,quake_PF.changelevel,quake_PF.Fixme,quake_PF.cvar_set,quake_PF.centerprint,quake_PF.ambientsound,quake_PF.precache_model,quake_PF.precache_sound,quake_PF.precache_file,quake_PF.setspawnparms];
quake_Sbar.fragsort = [];
quake_Sbar.showscores = false;
quake_V.cshift_empty = [130.0,80.0,50.0,0.0];
quake_V.cshift_water = [130.0,80.0,50.0,128.0];
quake_V.cshift_slime = [0.0,25.0,5.0,150.0];
quake_V.cshift_lava = [255.0,80.0,0.0,150.0];
quake_V.blend = [0.0,0.0,0.0,0.0];
quake_V.oldz = 0.0;
quake_V.dmg_time = 0.0;
quake_W.lumps = new haxe_ds_StringMap();
quake_Sys.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
